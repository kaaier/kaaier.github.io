<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Object-Detection]]></title>
    <url>%2F2019%2F08%2F25%2FObject-Detection%2F</url>
    <content type="text"><![CDATA[Object-Detection[TOC] 记录关于object detection的经典论文，针对论文结合开源代码进行论文复现，最新CVPR论文请转CVPR(Latest paper learning). R-CNN Fast R-CNN Faster R-CNN Mask R-CNN Light-Head R-CNN Cascade R-CNN SPP-Net YOLO YOLOv2 YOLOv3 YOLT SSD DSSD FSSD ESSD MDSSD Pelee Fire SSD R-FCN FPN DSOD RetinaNet MegDet RefineNet DetNet SSOD CornerNet M2Det 3D Object Detection ZSD（Zero-Shot Object Detection） OSD（One-Shot object Detection） Weakly Supervised Object Detection Softer-NMS 2018 2019 Other SurveyA Survey of Deep Learning-based Object Detection intro：From Fast R-CNN to NAS-FPN arXiv：https://arxiv.org/abs/1907.09408 Object Detection in 20 Years: A Survey intro：This work has been submitted to the IEEE TPAMI for possible publication arXiv：https://arxiv.org/abs/1905.05055 《Recent Advances in Object Detection in the Age of Deep Convolutional Neural Networks》 intro: awesome arXiv: https://arxiv.org/abs/1809.03193 《Deep Learning for Generic Object Detection: A Survey》 intro: Submitted to IJCV 2018 arXiv: https://arxiv.org/abs/1809.02165 Papers&amp;CodesR-CNNRich feature hierarchies for accurate object detection and semantic segmentation intro: R-CNN arxiv: http://arxiv.org/abs/1311.2524 supp: http://people.eecs.berkeley.edu/~rbg/papers/r-cnn-cvpr-supp.pdf slides: http://www.image-net.org/challenges/LSVRC/2013/slides/r-cnn-ilsvrc2013-workshop.pdf slides: http://www.cs.berkeley.edu/~rbg/slides/rcnn-cvpr14-slides.pdf github: https://github.com/rbgirshick/rcnn notes: http://zhangliliang.com/2014/07/23/paper-note-rcnn/ caffe-pr(“Make R-CNN the Caffe detection example”): https://github.com/BVLC/caffe/pull/482 Fast R-CNNFast R-CNN arxiv: http://arxiv.org/abs/1504.08083 slides: http://tutorial.caffe.berkeleyvision.org/caffe-cvpr15-detection.pdf github: https://github.com/rbgirshick/fast-rcnn github(COCO-branch): https://github.com/rbgirshick/fast-rcnn/tree/coco webcam demo: https://github.com/rbgirshick/fast-rcnn/pull/29 notes: http://zhangliliang.com/2015/05/17/paper-note-fast-rcnn/ notes: http://blog.csdn.net/linj_m/article/details/48930179 github(“Fast R-CNN in MXNet”): https://github.com/precedenceguo/mx-rcnn github: https://github.com/mahyarnajibi/fast-rcnn-torch github: https://github.com/apple2373/chainer-simple-fast-rnn github: https://github.com/zplizzi/tensorflow-fast-rcnn A-Fast-RCNN: Hard Positive Generation via Adversary for Object Detection intro: CVPR 2017 arxiv: https://arxiv.org/abs/1704.03414 paper: http://abhinavsh.info/papers/pdfs/adversarial_object_detection.pdf github(Caffe): https://github.com/xiaolonw/adversarial-frcnn Faster R-CNNFaster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks intro: NIPS 2015 arxiv: http://arxiv.org/abs/1506.01497 gitxiv: http://www.gitxiv.com/posts/8pfpcvefDYn2gSgXk/faster-r-cnn-towards-real-time-object-detection-with-region slides: http://web.cs.hacettepe.edu.tr/~aykut/classes/spring2016/bil722/slides/w05-FasterR-CNN.pdf github(official, Matlab): https://github.com/ShaoqingRen/faster_rcnn github(Caffe): https://github.com/rbgirshick/py-faster-rcnn github(MXNet): https://github.com/msracver/Deformable-ConvNets/tree/master/faster_rcnn github(PyTorch–recommend): https://github.com//jwyang/faster-rcnn.pytorch github: https://github.com/mitmul/chainer-faster-rcnn github(Torch):: https://github.com/andreaskoepf/faster-rcnn.torch github(Torch):: https://github.com/ruotianluo/Faster-RCNN-Densecap-torch github(TensorFlow): https://github.com/smallcorgi/Faster-RCNN_TF github(TensorFlow): https://github.com/CharlesShang/TFFRCNN github(C++ demo): https://github.com/YihangLou/FasterRCNN-Encapsulation-Cplusplus github(Keras): https://github.com/yhenon/keras-frcnn github: https://github.com/Eniac-Xie/faster-rcnn-resnet github(C++): https://github.com/D-X-Y/caffe-faster-rcnn/tree/dev R-CNN minus R intro: BMVC 2015 arxiv: http://arxiv.org/abs/1506.06981 Faster R-CNN in MXNet with distributed implementation and data parallelization github: https://github.com/dmlc/mxnet/tree/master/example/rcnn Contextual Priming and Feedback for Faster R-CNN intro: ECCV 2016. Carnegie Mellon University paper: http://abhinavsh.info/context_priming_feedback.pdf poster: http://www.eccv2016.org/files/posters/P-1A-20.pdf An Implementation of Faster RCNN with Study for Region Sampling intro: Technical Report, 3 pages. CMU arxiv: https://arxiv.org/abs/1702.02138 github: https://github.com/endernewton/tf-faster-rcnn github: https://github.com/ruotianluo/pytorch-faster-rcnn Interpretable R-CNN intro: North Carolina State University &amp; Alibaba keywords: AND-OR Graph (AOG) arxiv: https://arxiv.org/abs/1711.05226 Domain Adaptive Faster R-CNN for Object Detection in the Wild intro: CVPR 2018. ETH Zurich &amp; ESAT/PSI arxiv: https://arxiv.org/abs/1803.03243 Mask R-CNN arxiv: http://arxiv.org/abs/1703.06870 github(Keras): https://github.com/matterport/Mask_RCNN github(Caffe2): https://github.com/facebookresearch/Detectron github(Pytorch): https://github.com/wannabeOG/Mask-RCNN github(MXNet): https://github.com/TuSimple/mx-maskrcnn github(Chainer): https://github.com/DeNA/Chainer_Mask_R-CNN Light-Head R-CNNLight-Head R-CNN: In Defense of Two-Stage Object Detector intro: Tsinghua University &amp; Megvii Inc arxiv: https://arxiv.org/abs/1711.07264 github(offical): https://github.com/zengarden/light_head_rcnn github: https://github.com/terrychenism/Deformable-ConvNets/blob/master/rfcn/symbols/resnet_v1_101_rfcn_light.py#L784 Cascade R-CNNCascade R-CNN: Delving into High Quality Object Detection arxiv: https://arxiv.org/abs/1712.00726 github: https://github.com/zhaoweicai/cascade-rcnn SPP-NetSpatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition intro: ECCV 2014 / TPAMI 2015 arxiv: http://arxiv.org/abs/1406.4729 github: https://github.com/ShaoqingRen/SPP_net notes: http://zhangliliang.com/2014/09/13/paper-note-sppnet/ DeepID-Net: Deformable Deep Convolutional Neural Networks for Object Detection intro: PAMI 2016 intro: an extension of R-CNN. box pre-training, cascade on region proposals, deformation layers and context representations project page: http://www.ee.cuhk.edu.hk/%CB%9Cwlouyang/projects/imagenetDeepId/index.html arxiv: http://arxiv.org/abs/1412.5661 Object Detectors Emerge in Deep Scene CNNs intro: ICLR 2015 arxiv: http://arxiv.org/abs/1412.6856 paper: https://www.robots.ox.ac.uk/~vgg/rg/papers/zhou_iclr15.pdf paper: https://people.csail.mit.edu/khosla/papers/iclr2015_zhou.pdf slides: http://places.csail.mit.edu/slide_iclr2015.pdf segDeepM: Exploiting Segmentation and Context in Deep Neural Networks for Object Detection intro: CVPR 2015 project(code+data): https://www.cs.toronto.edu/~yukun/segdeepm.html arxiv: https://arxiv.org/abs/1502.04275 github: https://github.com/YknZhu/segDeepM Object Detection Networks on Convolutional Feature Maps intro: TPAMI 2015 keywords: NoC arxiv: http://arxiv.org/abs/1504.06066 Improving Object Detection with Deep Convolutional Networks via Bayesian Optimization and Structured Prediction arxiv: http://arxiv.org/abs/1504.03293 slides: http://www.ytzhang.net/files/publications/2015-cvpr-det-slides.pdf github: https://github.com/YutingZhang/fgs-obj DeepBox: Learning Objectness with Convolutional Networks keywords: DeepBox arxiv: http://arxiv.org/abs/1505.02146 github: https://github.com/weichengkuo/DeepBox YOLOYou Only Look Once: Unified, Real-Time Object Detection arxiv: http://arxiv.org/abs/1506.02640 code: https://pjreddie.com/darknet/yolov1/ github: https://github.com/pjreddie/darknet blog: https://pjreddie.com/darknet/yolov1/ slides: https://docs.google.com/presentation/d/1aeRvtKG21KHdD5lg6Hgyhx5rPq_ZOsGjG5rJ1HP7BbA/pub?start=false&amp;loop=false&amp;delayms=3000&amp;slide=id.p reddit: https://www.reddit.com/r/MachineLearning/comments/3a3m0o/realtime_object_detection_with_yolo/ github: https://github.com/gliese581gg/YOLO_tensorflow github: https://github.com/xingwangsfu/caffe-yolo github: https://github.com/frankzhangrui/Darknet-Yolo github: https://github.com/BriSkyHekun/py-darknet-yolo github: https://github.com/tommy-qichang/yolo.torch github: https://github.com/frischzenger/yolo-windows github: https://github.com/AlexeyAB/yolo-windows github: https://github.com/nilboy/tensorflow-yolo darkflow - translate darknet to tensorflow. Load trained weights, retrain/fine-tune them using tensorflow, export constant graph def to C++ blog: https://thtrieu.github.io/notes/yolo-tensorflow-graph-buffer-cpp github: https://github.com/thtrieu/darkflow Start Training YOLO with Our Own Data intro: train with customized data and class numbers/labels. Linux / Windows version for darknet. blog: http://guanghan.info/blog/en/my-works/train-yolo/ github: https://github.com/Guanghan/darknet YOLO: Core ML versus MPSNNGraph intro: Tiny YOLO for iOS implemented using CoreML but also using the new MPS graph API. blog: http://machinethink.net/blog/yolo-coreml-versus-mps-graph/ github: https://github.com/hollance/YOLO-CoreML-MPSNNGraph TensorFlow YOLO object detection on Android intro: Real-time object detection on Android using the YOLO network with TensorFlow github: https://github.com/natanielruiz/android-yolo Computer Vision in iOS – Object Detection blog: https://sriraghu.com/2017/07/12/computer-vision-in-ios-object-detection/ github:https://github.com/r4ghu/iOS-CoreML-Yolo YOLOv2YOLO9000: Better, Faster, Stronger arxiv: https://arxiv.org/abs/1612.08242 code: http://pjreddie.com/yolo9000/ https://pjreddie.com/darknet/yolov2/ github(Chainer): https://github.com/leetenki/YOLOv2 github(Keras): https://github.com/allanzelener/YAD2K github(PyTorch): https://github.com/longcw/yolo2-pytorch github(Tensorflow): https://github.com/hizhangp/yolo_tensorflow github(Windows): https://github.com/AlexeyAB/darknet github: https://github.com/choasUp/caffe-yolo9000 github: https://github.com/philipperemy/yolo-9000 github(TensorFlow): https://github.com/KOD-Chen/YOLOv2-Tensorflow github(Keras): https://github.com/yhcc/yolo2 github(Keras): https://github.com/experiencor/keras-yolo2 github(TensorFlow): https://github.com/WojciechMormul/yolo2 darknet_scripts intro: Auxilary scripts to work with (YOLO) darknet deep learning famework. AKA -&gt; How to generate YOLO anchors? github: https://github.com/Jumabek/darknet_scripts Yolo_mark: GUI for marking bounded boxes of objects in images for training Yolo v2 github: https://github.com/AlexeyAB/Yolo_mark LightNet: Bringing pjreddie’s DarkNet out of the shadows https://github.com//explosion/lightnet YOLO v2 Bounding Box Tool intro: Bounding box labeler tool to generate the training data in the format YOLO v2 requires. github: https://github.com/Cartucho/yolo-boundingbox-labeler-GUI Loss Rank Mining: A General Hard Example Mining Method for Real-time Detectors intro: LRM is the first hard example mining strategy which could fit YOLOv2 perfectly and make it better applied in series of real scenarios where both real-time rates and accurate detection are strongly demanded. arxiv: https://arxiv.org/abs/1804.04606 Object detection at 200 Frames Per Second intro: faster than Tiny-Yolo-v2 arxiv: https://arxiv.org/abs/1805.06361 Event-based Convolutional Networks for Object Detection in Neuromorphic Cameras intro: YOLE–Object Detection in Neuromorphic Cameras arxiv:https://arxiv.org/abs/1805.07931 OmniDetector: With Neural Networks to Bounding Boxes intro: a person detector on n fish-eye images of indoor scenes（NIPS 2018） arxiv:https://arxiv.org/abs/1805.08503 datasets:https://gitlab.com/omnidetector/omnidetector YOLOv3YOLOv3: An Incremental Improvement arxiv:https://arxiv.org/abs/1804.02767 paper:https://pjreddie.com/media/files/papers/YOLOv3.pdf code: https://pjreddie.com/darknet/yolo/ github(Official):https://github.com/pjreddie/darknet github:https://github.com/mystic123/tensorflow-yolo-v3 github:https://github.com/experiencor/keras-yolo3 github:https://github.com/qqwweee/keras-yolo3 github:https://github.com/marvis/pytorch-yolo3 github:https://github.com/ayooshkathuria/pytorch-yolo-v3 github:https://github.com/ayooshkathuria/YOLO_v3_tutorial_from_scratch github:https://github.com/eriklindernoren/PyTorch-YOLOv3 github:https://github.com/ultralytics/yolov3 github:https://github.com/BobLiu20/YOLOv3_PyTorch github:https://github.com/andy-yun/pytorch-0.4-yolov3 github:https://github.com/DeNA/PyTorch_YOLOv3 YOLTYou Only Look Twice: Rapid Multi-Scale Object Detection In Satellite Imagery intro: Small Object Detection arxiv:https://arxiv.org/abs/1805.09512 github:https://github.com/avanetten/yolt SSDSSD: Single Shot MultiBox Detector intro: ECCV 2016 Oral arxiv: http://arxiv.org/abs/1512.02325 paper: http://www.cs.unc.edu/~wliu/papers/ssd.pdf slides: http://www.cs.unc.edu/%7Ewliu/papers/ssd_eccv2016_slide.pdf github(Official): https://github.com/weiliu89/caffe/tree/ssd video: http://weibo.com/p/2304447a2326da963254c963c97fb05dd3a973 github: https://github.com/zhreshold/mxnet-ssd github: https://github.com/zhreshold/mxnet-ssd.cpp github: https://github.com/rykov8/ssd_keras github: https://github.com/balancap/SSD-Tensorflow github: https://github.com/amdegroot/ssd.pytorch github(Caffe): https://github.com/chuanqi305/MobileNet-SSD What’s the diffience in performance between this new code you pushed and the previous code? #327 https://github.com/weiliu89/caffe/issues/327 DSSDDSSD : Deconvolutional Single Shot Detector intro: UNC Chapel Hill &amp; Amazon Inc arxiv: https://arxiv.org/abs/1701.06659 github: https://github.com/chengyangfu/caffe/tree/dssd github: https://github.com/MTCloudVision/mxnet-dssd demo: http://120.52.72.53/www.cs.unc.edu/c3pr90ntc0td/~cyfu/dssd_lalaland.mp4 Enhancement of SSD by concatenating feature maps for object detection intro: rainbow SSD (R-SSD) arxiv: https://arxiv.org/abs/1705.09587 Context-aware Single-Shot Detector keywords: CSSD, DiCSSD, DeCSSD, effective receptive fields (ERFs), theoretical receptive fields (TRFs) arxiv: https://arxiv.org/abs/1707.08682 Feature-Fused SSD: Fast Detection for Small Objects https://arxiv.org/abs/1709.05054 FSSDFSSD: Feature Fusion Single Shot Multibox Detector https://arxiv.org/abs/1712.00960 Weaving Multi-scale Context for Single Shot Detector intro: WeaveNet keywords: fuse multi-scale information arxiv: https://arxiv.org/abs/1712.03149 ESSDExtend the shallow part of Single Shot MultiBox Detector via Convolutional Neural Network https://arxiv.org/abs/1801.05918 Tiny SSD: A Tiny Single-shot Detection Deep Convolutional Neural Network for Real-time Embedded Object Detection https://arxiv.org/abs/1802.06488 MDSSDMDSSD: Multi-scale Deconvolutional Single Shot Detector for small objects arxiv: https://arxiv.org/abs/1805.07009 PeleePelee: A Real-Time Object Detection System on Mobile Devices https://github.com/Robert-JunWang/Pelee intro: (ICLR 2018 workshop track) arxiv: https://arxiv.org/abs/1804.06882 github: https://github.com/Robert-JunWang/Pelee Fire SSDFire SSD: Wide Fire Modules based Single Shot Detector on Edge Device intro:low cost, fast speed and high mAP on factor edge computing devices arxiv:https://arxiv.org/abs/1806.05363 R-FCNR-FCN: Object Detection via Region-based Fully Convolutional Networks arxiv: http://arxiv.org/abs/1605.06409 github: https://github.com/daijifeng001/R-FCN github(MXNet): https://github.com/msracver/Deformable-ConvNets/tree/master/rfcn github: https://github.com/Orpine/py-R-FCN github: https://github.com/PureDiors/pytorch_RFCN github: https://github.com/bharatsingh430/py-R-FCN-multiGPU github: https://github.com/xdever/RFCN-tensorflow R-FCN-3000 at 30fps: Decoupling Detection and Classification https://arxiv.org/abs/1712.01802 Recycle deep features for better object detection arxiv: http://arxiv.org/abs/1607.05066 FPNFeature Pyramid Networks for Object Detection intro: Facebook AI Research arxiv: https://arxiv.org/abs/1612.03144 Action-Driven Object Detection with Top-Down Visual Attentions arxiv: https://arxiv.org/abs/1612.06704 Beyond Skip Connections: Top-Down Modulation for Object Detection intro: CMU &amp; UC Berkeley &amp; Google Research arxiv: https://arxiv.org/abs/1612.06851 Wide-Residual-Inception Networks for Real-time Object Detection intro: Inha University arxiv: https://arxiv.org/abs/1702.01243 Attentional Network for Visual Object Detection intro: University of Maryland &amp; Mitsubishi Electric Research Laboratories arxiv: https://arxiv.org/abs/1702.01478 Learning Chained Deep Features and Classifiers for Cascade in Object Detection keykwords: CC-Net intro: chained cascade network (CC-Net). 81.1% mAP on PASCAL VOC 2007 arxiv: https://arxiv.org/abs/1702.07054 DeNet: Scalable Real-time Object Detection with Directed Sparse Sampling intro: ICCV 2017 (poster) arxiv: https://arxiv.org/abs/1703.10295 Discriminative Bimodal Networks for Visual Localization and Detection with Natural Language Queries intro: CVPR 2017 arxiv: https://arxiv.org/abs/1704.03944 Spatial Memory for Context Reasoning in Object Detection arxiv: https://arxiv.org/abs/1704.04224 Accurate Single Stage Detector Using Recurrent Rolling Convolution intro: CVPR 2017. SenseTime keywords: Recurrent Rolling Convolution (RRC) arxiv: https://arxiv.org/abs/1704.05776 github: https://github.com/xiaohaoChen/rrc_detection Deep Occlusion Reasoning for Multi-Camera Multi-Target Detection https://arxiv.org/abs/1704.05775 LCDet: Low-Complexity Fully-Convolutional Neural Networks for Object Detection in Embedded Systems intro: Embedded Vision Workshop in CVPR. UC San Diego &amp; Qualcomm Inc arxiv: https://arxiv.org/abs/1705.05922 Point Linking Network for Object Detection intro: Point Linking Network (PLN) arxiv: https://arxiv.org/abs/1706.03646 Perceptual Generative Adversarial Networks for Small Object Detection https://arxiv.org/abs/1706.05274 Few-shot Object Detection https://arxiv.org/abs/1706.08249 Yes-Net: An effective Detector Based on Global Information https://arxiv.org/abs/1706.09180 SMC Faster R-CNN: Toward a scene-specialized multi-object detector https://arxiv.org/abs/1706.10217 Towards lightweight convolutional neural networks for object detection https://arxiv.org/abs/1707.01395 RON: Reverse Connection with Objectness Prior Networks for Object Detection intro: CVPR 2017 arxiv: https://arxiv.org/abs/1707.01691 github: https://github.com/taokong/RON Mimicking Very Efficient Network for Object Detection intro: CVPR 2017. SenseTime &amp; Beihang University paper: http://openaccess.thecvf.com/content_cvpr_2017/papers/Li_Mimicking_Very_Efficient_CVPR_2017_paper.pdf Residual Features and Unified Prediction Network for Single Stage Detection https://arxiv.org/abs/1707.05031 Deformable Part-based Fully Convolutional Network for Object Detection intro: BMVC 2017 (oral). Sorbonne Universités &amp; CEDRIC arxiv: https://arxiv.org/abs/1707.06175 Adaptive Feeding: Achieving Fast and Accurate Detections by Adaptively Combining Object Detectors intro: ICCV 2017 arxiv: https://arxiv.org/abs/1707.06399 Recurrent Scale Approximation for Object Detection in CNN intro: ICCV 2017 keywords: Recurrent Scale Approximation (RSA) arxiv: https://arxiv.org/abs/1707.09531 github: https://github.com/sciencefans/RSA-for-object-detection DSODDSOD: Learning Deeply Supervised Object Detectors from Scratch intro: ICCV 2017. Fudan University &amp; Tsinghua University &amp; Intel Labs China arxiv: https://arxiv.org/abs/1708.01241 github: https://github.com/szq0214/DSOD github:https://github.com/Windaway/DSOD-Tensorflow github:https://github.com/chenyuntc/dsod.pytorch Learning Object Detectors from Scratch with Gated Recurrent Feature Pyramids arxiv:https://arxiv.org/abs/1712.00886 github:https://github.com/szq0214/GRP-DSOD Tiny-DSOD: Lightweight Object Detection for Resource-Restricted Usages intro: BMVC 2018 arXiv: https://arxiv.org/abs/1807.11013 Object Detection from Scratch with Deep Supervision intro: This is an extended version of DSOD arXiv: https://arxiv.org/abs/1809.09294 RetinaNetFocal Loss for Dense Object Detection intro: ICCV 2017 Best student paper award. Facebook AI Research keywords: RetinaNet arxiv: https://arxiv.org/abs/1708.02002 CoupleNet: Coupling Global Structure with Local Parts for Object Detection intro: ICCV 2017 arxiv: https://arxiv.org/abs/1708.02863 Incremental Learning of Object Detectors without Catastrophic Forgetting intro: ICCV 2017. Inria arxiv: https://arxiv.org/abs/1708.06977 Zoom Out-and-In Network with Map Attention Decision for Region Proposal and Object Detection https://arxiv.org/abs/1709.04347 StairNet: Top-Down Semantic Aggregation for Accurate One Shot Detection https://arxiv.org/abs/1709.05788 Dynamic Zoom-in Network for Fast Object Detection in Large Images https://arxiv.org/abs/1711.05187 Zero-Annotation Object Detection with Web Knowledge Transfer intro: NTU, Singapore &amp; Amazon keywords: multi-instance multi-label domain adaption learning framework arxiv: https://arxiv.org/abs/1711.05954 MegDetMegDet: A Large Mini-Batch Object Detector intro: Peking University &amp; Tsinghua University &amp; Megvii Inc arxiv: https://arxiv.org/abs/1711.07240 Receptive Field Block Net for Accurate and Fast Object Detection intro: RFBNet arxiv: https://arxiv.org/abs/1711.07767 github: https://github.com//ruinmessi/RFBNet An Analysis of Scale Invariance in Object Detection - SNIP arxiv: https://arxiv.org/abs/1711.08189 github: https://github.com/bharatsingh430/snip Feature Selective Networks for Object Detection https://arxiv.org/abs/1711.08879 Learning a Rotation Invariant Detector with Rotatable Bounding Box arxiv: https://arxiv.org/abs/1711.09405 github: https://github.com/liulei01/DRBox Scalable Object Detection for Stylized Objects intro: Microsoft AI &amp; Research Munich arxiv: https://arxiv.org/abs/1711.09822 Learning Object Detectors from Scratch with Gated Recurrent Feature Pyramids arxiv: https://arxiv.org/abs/1712.00886 github: https://github.com/szq0214/GRP-DSOD Deep Regionlets for Object Detection keywords: region selection network, gating network arxiv: https://arxiv.org/abs/1712.02408 Training and Testing Object Detectors with Virtual Images intro: IEEE/CAA Journal of Automatica Sinica arxiv: https://arxiv.org/abs/1712.08470 Large-Scale Object Discovery and Detector Adaptation from Unlabeled Video keywords: object mining, object tracking, unsupervised object discovery by appearance-based clustering, self-supervised detector adaptation arxiv: https://arxiv.org/abs/1712.08832 Spot the Difference by Object Detection intro: Tsinghua University &amp; JD Group arxiv: https://arxiv.org/abs/1801.01051 Localization-Aware Active Learning for Object Detection arxiv: https://arxiv.org/abs/1801.05124 Object Detection with Mask-based Feature Encoding arxiv: https://arxiv.org/abs/1802.03934 LSTD: A Low-Shot Transfer Detector for Object Detection intro: AAAI 2018 arxiv: https://arxiv.org/abs/1803.01529 Pseudo Mask Augmented Object Detection https://arxiv.org/abs/1803.05858 Revisiting RCNN: On Awakening the Classification Power of Faster RCNN https://arxiv.org/abs/1803.06799 Learning Region Features for Object Detection intro: Peking University &amp; MSRA arxiv: https://arxiv.org/abs/1803.07066 Single-Shot Bidirectional Pyramid Networks for High-Quality Object Detection intro: Singapore Management University &amp; Zhejiang University arxiv: https://arxiv.org/abs/1803.08208 Object Detection for Comics using Manga109 Annotations intro: University of Tokyo &amp; National Institute of Informatics, Japan arxiv: https://arxiv.org/abs/1803.08670 Task-Driven Super Resolution: Object Detection in Low-resolution Images arxiv: https://arxiv.org/abs/1803.11316 Transferring Common-Sense Knowledge for Object Detection arxiv: https://arxiv.org/abs/1804.01077 Multi-scale Location-aware Kernel Representation for Object Detection intro: CVPR 2018 arxiv: https://arxiv.org/abs/1804.00428 github: https://github.com/Hwang64/MLKP Loss Rank Mining: A General Hard Example Mining Method for Real-time Detectors intro: National University of Defense Technology arxiv: https://arxiv.org/abs/1804.04606 Robust Physical Adversarial Attack on Faster R-CNN Object Detector arxiv: https://arxiv.org/abs/1804.05810 RefineNetSingle-Shot Refinement Neural Network for Object Detection intro: CVPR 2018 arxiv: https://arxiv.org/abs/1711.06897 github: https://github.com/sfzhang15/RefineDet github: https://github.com/lzx1413/PytorchSSD github: https://github.com/ddlee96/RefineDet_mxnet github: https://github.com/MTCloudVision/RefineDet-Mxnet DetNetDetNet: A Backbone network for Object Detection intro: Tsinghua University &amp; Face++ arxiv: https://arxiv.org/abs/1804.06215 SSODSelf-supervisory Signals for Object Discovery and Detection Google Brain arxiv:https://arxiv.org/abs/1806.03370 CornerNetCornerNet: Detecting Objects as Paired Keypoints intro: ECCV 2018 arXiv: https://arxiv.org/abs/1808.01244 github: https://github.com/umich-vl/CornerNet M2DetM2Det: A Single-Shot Object Detector based on Multi-Level Feature Pyramid Network intro: AAAI 2019 arXiv: https://arxiv.org/abs/1811.04533 github: https://github.com/qijiezhao/M2Det 3D Object Detection3D Backbone Network for 3D Object Detection arXiv: https://arxiv.org/abs/1901.08373 LMNet: Real-time Multiclass Object Detection on CPU using 3D LiDARs arxiv: https://arxiv.org/abs/1805.04902 github: https://github.com/CPFL/Autoware/tree/feature/cnn_lidar_detection ZSD（Zero-Shot Object Detection）Zero-Shot Detection intro: Australian National University keywords: YOLO arxiv: https://arxiv.org/abs/1803.07113 Zero-Shot Object Detection arxiv: https://arxiv.org/abs/1804.04340 Zero-Shot Object Detection: Learning to Simultaneously Recognize and Localize Novel Concepts arxiv: https://arxiv.org/abs/1803.06049 Zero-Shot Object Detection by Hybrid Region Embedding arxiv: https://arxiv.org/abs/1805.06157 OSD（One-Shot Object Detection）Comparison Network for One-Shot Conditional Object Detection arXiv: https://arxiv.org/abs/1904.02317 One-Shot Object Detection RepMet: Representative-based metric learning for classification and one-shot object detection intro: IBM Research AI arxiv:https://arxiv.org/abs/1806.04728 github: TODO Weakly Supervised Object DetectionWeakly Supervised Object Detection in Artworks intro: ECCV 2018 Workshop Computer Vision for Art Analysis arXiv: https://arxiv.org/abs/1810.02569 Datasets: https://wsoda.telecom-paristech.fr/downloads/dataset/IconArt_v1.zip Cross-Domain Weakly-Supervised Object Detection through Progressive Domain Adaptation intro: CVPR 2018 arXiv: https://arxiv.org/abs/1803.11365 homepage: https://naoto0804.github.io/cross_domain_detection/ paper: http://openaccess.thecvf.com/content_cvpr_2018/html/Inoue_Cross-Domain_Weakly-Supervised_Object_CVPR_2018_paper.html github: https://github.com/naoto0804/cross-domain-detection Softer-NMS《Softer-NMS: Rethinking Bounding Box Regression for Accurate Object Detection》 intro: CMU &amp; Face++ arXiv: https://arxiv.org/abs/1809.08545 github: https://github.com/yihui-he/softer-NMS 2019Feature Selective Anchor-Free Module for Single-Shot Object Detection intro: CVPR 2019 arXiv: https://arxiv.org/abs/1903.00621 Object Detection based on Region Decomposition and Assembly intro: AAAI 2019 arXiv: https://arxiv.org/abs/1901.08225 Bottom-up Object Detection by Grouping Extreme and Center Points intro: one stage 43.2% on COCO test-dev arXiv: https://arxiv.org/abs/1901.08043 github: https://github.com/xingyizhou/ExtremeNet ORSIm Detector: A Novel Object Detection Framework in Optical Remote Sensing Imagery Using Spatial-Frequency Channel Features intro: IEEE TRANSACTIONS ON GEOSCIENCE AND REMOTE SENSING arXiv: https://arxiv.org/abs/1901.07925 Consistent Optimization for Single-Shot Object Detection intro: improves RetinaNet from 39.1 AP to 40.1 AP on COCO datase arXiv: https://arxiv.org/abs/1901.06563 Learning Pairwise Relationship for Multi-object Detection in Crowded Scenes arXiv: https://arxiv.org/abs/1901.03796 RetinaMask: Learning to predict masks improves state-of-the-art single-shot detection for free arXiv: https://arxiv.org/abs/1901.03353 github: https://github.com/chengyangfu/retinamask Region Proposal by Guided Anchoring intro: CUHK - SenseTime Joint Lab arXiv: https://arxiv.org/abs/1901.03278 Scale-Aware Trident Networks for Object Detection intro: mAP of 48.4 on the COCO dataset arXiv: https://arxiv.org/abs/1901.01892 2018Large-Scale Object Detection of Images from Network Cameras in Variable Ambient Lighting Conditions arXiv: https://arxiv.org/abs/1812.11901 Strong-Weak Distribution Alignment for Adaptive Object Detection arXiv: https://arxiv.org/abs/1812.04798 AutoFocus: Efficient Multi-Scale Inference intro: AutoFocus obtains an mAP of 47.9% (68.3% at 50% overlap) on the COCO test-dev set while processing 6.4 images per second on a Titan X (Pascal) GPU arXiv: https://arxiv.org/abs/1812.01600 NOTE-RCNN: NOise Tolerant Ensemble RCNN for Semi-Supervised Object Detection intro: Google Could arXiv: https://arxiv.org/abs/1812.00124 SPLAT: Semantic Pixel-Level Adaptation Transforms for Detection intro: UC Berkeley arXiv: https://arxiv.org/abs/1812.00929 Grid R-CNN intro: SenseTime arXiv: https://arxiv.org/abs/1811.12030 Deformable ConvNets v2: More Deformable, Better Results intro: Microsoft Research Asia arXiv: https://arxiv.org/abs/1811.11168 Anchor Box Optimization for Object Detection intro: Microsoft Research arXiv: https://arxiv.org/abs/1812.00469 Efficient Coarse-to-Fine Non-Local Module for the Detection of Small Objects intro: https://arxiv.org/abs/1811.12152 NOTE-RCNN: NOise Tolerant Ensemble RCNN for Semi-Supervised Object Detection arXiv: https://arxiv.org/abs/1812.00124 Learning RoI Transformer for Detecting Oriented Objects in Aerial Images arXiv: https://arxiv.org/abs/1812.00155 Integrated Object Detection and Tracking with Tracklet-Conditioned Detection intro: Microsoft Research Asia arXiv: https://arxiv.org/abs/1811.11167 Deep Regionlets: Blended Representation and Deep Learning for Generic Object Detection arXiv: https://arxiv.org/abs/1811.11318 Gradient Harmonized Single-stage Detector intro: AAAI 2019 arXiv: https://arxiv.org/abs/1811.05181 CFENet: Object Detection with Comprehensive Feature Enhancement Module intro: ACCV 2018 github: https://github.com/qijiezhao/CFENet DeRPN: Taking a further step toward more general object detection intro: AAAI 2019 arXiv: https://arxiv.org/abs/1811.06700 github: https://github.com/HCIILAB/DeRPN Hybrid Knowledge Routed Modules for Large-scale Object Detection intro: Sun Yat-Sen University &amp; Huawei Noah’s Ark Lab arXiv: https://arxiv.org/abs/1810.12681 github: https://github.com/chanyn/HKRM 《Receptive Field Block Net for Accurate and Fast Object Detection》 intro: ECCV 2018 arXiv: https://arxiv.org/abs/1711.07767 github: https://github.com/ruinmessi/RFBNet Deep Feature Pyramid Reconfiguration for Object Detection intro: ECCV 2018 arXiv: https://arxiv.org/abs/1808.07993 Unsupervised Hard Example Mining from Videos for Improved Object Detection intro: ECCV 2018 arXiv: https://arxiv.org/abs/1808.04285 Acquisition of Localization Confidence for Accurate Object Detection intro: ECCV 2018 arXiv: https://arxiv.org/abs/1807.11590 github: https://github.com/vacancy/PreciseRoIPooling Toward Scale-Invariance and Position-Sensitive Region Proposal Networks intro: ECCV 2018 arXiv: https://arxiv.org/abs/1807.09528 MetaAnchor: Learning to Detect Objects with Customized Anchors arxiv: https://arxiv.org/abs/1807.00980 Relation Network for Object Detection intro: CVPR 2018 arxiv: https://arxiv.org/abs/1711.11575 github:https://github.com/msracver/Relation-Networks-for-Object-Detection Quantization Mimic: Towards Very Tiny CNN for Object Detection Tsinghua University1 &amp; The Chinese University of Hong Kong2 &amp;SenseTime3 arxiv: https://arxiv.org/abs/1805.02152 Learning Rich Features for Image Manipulation Detection intro: CVPR 2018 Camera Ready arxiv: https://arxiv.org/abs/1805.04953 SNIPER: Efficient Multi-Scale Training arxiv:https://arxiv.org/abs/1805.09300 github:https://github.com/mahyarnajibi/SNIPER Soft Sampling for Robust Object Detection intro: the robustness of object detection under the presence of missing annotations arxiv:https://arxiv.org/abs/1806.06986 Cost-effective Object Detection: Active Sample Mining with Switchable Selection Criteria intro: TNNLS 2018 arxiv:https://arxiv.org/abs/1807.00147 code: http://kezewang.com/codes/ASM_ver1.zip OtherR3-Net: A Deep Network for Multi-oriented Vehicle Detection in Aerial Images and Videos arxiv: https://arxiv.org/abs/1808.05560 youtube: https://youtu.be/xCYD-tYudN0 Detection Toolbox Detectron(FAIR): Detectron is Facebook AI Research’s software system that implements state-of-the-art object detection algorithms, including Mask R-CNN. It is written in Python and powered by the Caffe2 deep learning framework. maskrcnn-benchmark(FAIR): Fast, modular reference implementation of Instance Segmentation and Object Detection algorithms in PyTorch. mmdetection(SenseTime&amp;CUHK): mmdetection is an open source object detection toolbox based on PyTorch. It is a part of the open-mmlab project developed by Multimedia Laboratory, CUHK.]]></content>
      <categories>
        <category>Computer-Vision</category>
      </categories>
      <tags>
        <tag>Object-Detection</tag>
        <tag>Computer-Vision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中STL总结]]></title>
    <url>%2F2019%2F06%2F17%2FSTL%2F</url>
    <content type="text"><![CDATA[STL组成 容器（containers） 算法（algorithms） 迭代器（iterators） 仿函数（functors） 配接器（adapters） 空间配置器（allocator） 容器（containers） 序列式容器（sequence containers）：元素都是可序（ordered），但未必是有序（sorted） 关联式容器（associattive containers） array array是固定大小的顺序容器，它们保存了一个以严格的线性顺序排列的特定数量的元素。 在内部，一个数组除了它所包含的元素（甚至不是它的大小，它是一个模板参数，在编译时是固定的）以外不保存任何数据。存储大小与用语言括号语法（[]）声明的普通数组一样高效。这个类只是增加了一层成员函数和全局函数，所以数组可以作为标准容器使用。 与其他标准容器不同，数组具有固定的大小，并且不通过分配器管理其元素的分配：它们是封装固定大小数组元素的聚合类型。因此，他们不能动态地扩大或缩小。 零大小的数组是有效的，但是它们不应该被解除引用（成员的前面，后面和数据）。 与标准库中的其他容器不同，交换两个数组容器是一种线性操作，它涉及单独交换范围内的所有元素，这通常是相当低效的操作。另一方面，这允许迭代器在两个容器中的元素保持其原始容器关联。 数组容器的另一个独特特性是它们可以被当作元组对象来处理：array头部重载get函数来访问数组元素，就像它是一个元组，以及专门的tuple_size和tuple_element类型。 1template &lt; class T, size_t N &gt; class array; array::begin返回指向数组容器中第一个元素的迭代器。 12 iterator begin() noexcept;const_iterator begin() const noexcept; Example 12345678910111213#include &lt;iostream&gt;#include &lt;array&gt;int main()&#123; std::array&lt;int, 5&gt; myarray = &#123;2, 16, 77,34, 50&#125;; std::cout &lt;&lt; "myarray contains:"; for(auto it = myarray.begin(); it != myarray.end(); ++i) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 2 16 77 34 50 array::end返回指向数组容器中最后一个元素之后的理论元素的迭代器。 12 iterator end() noexcept;const_iterator end() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123; 5, 19, 77, 34, 99 &#125;; std::cout &lt;&lt; "myarray contains:"; for ( auto it = myarray.begin(); it != myarray.end(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 5 19 77 34 99 array::rbegin返回指向数组容器中最后一个元素的反向迭代器。 12 reverse_iterator rbegin（）noexcept;const_reverse_iterator rbegin（）const noexcept; Example 12345678910111213#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,4&gt; myarray = &#123;4, 26, 80, 14&#125; ; for(auto rit = myarray.rbegin(); rit &lt; myarray.rend(); ++rit) std::cout &lt;&lt; ' ' &lt;&lt; *rit; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 14 80 26 4 array::rend返回一个反向迭代器，指向数组中第一个元素之前的理论元素（这被认为是它的反向结束）。 12 reverse_iterator rend() noexcept;const_reverse_iterator rend() const noexcept; Example 1234567891011121314#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,4&gt; myarray = &#123;4, 26, 80, 14&#125;; std::cout &lt;&lt; "myarray contains"; for(auto rit = myarray.rbegin(); rit &lt; myarray.rend(); ++rit) std::cout &lt;&lt; ' ' &lt;&lt; *rit; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 14 80 26 4 array::cbegin返回指向数组容器中第一个元素的常量迭代器（const_iterator）；这个迭代器可以增加和减少，但是不能用来修改它指向的内容。 1const_iterator cbegin（）const noexcept; Example 12345678910111213141516#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123;2, 16, 77, 34, 50&#125;; std::cout &lt;&lt; "myarray contains:"; for ( auto it = myarray.cbegin(); it != myarray.cend(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; // cannot modify *it std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 2 16 77 34 50 array::cend返回指向数组容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）。这个迭代器可以增加和减少，但是不能用来修改它指向的内容。 1const_iterator cend() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123; 15, 720, 801, 1002, 3502 &#125;; std::cout &lt;&lt; "myarray contains:"; for ( auto it = myarray.cbegin(); it != myarray.cend(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; // cannot modify *it std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 2 16 77 34 50 array::crbegin返回指向数组容器中最后一个元素的常量反向迭代器（const_reverse_iterator） 1const_reverse_iterator crbegin（）const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,6&gt; myarray = &#123;10, 20, 30, 40, 50, 60&#125; ; std::cout &lt;&lt; "myarray backwards:"; for ( auto rit=myarray.crbegin() ; rit &lt; myarray.crend(); ++rit ) std::cout &lt;&lt; ' ' &lt;&lt; *rit; // cannot modify *rit std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray backwards: 60 50 40 30 20 10 array::crend返回指向数组中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator），它被认为是其反向结束。 1const_reverse_iterator crend() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,6&gt; myarray = &#123;10, 20, 30, 40, 50, 60&#125; ; std::cout &lt;&lt; "myarray backwards:"; for ( auto rit=myarray.crbegin() ; rit &lt; myarray.crend(); ++rit ) std::cout &lt;&lt; ' ' &lt;&lt; *rit; // cannot modify *rit std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray backwards: 60 50 40 30 20 10 array::size返回数组容器中元素的数量。 1constexpr size_type size（）noexcept; Example 1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myints; std::cout &lt;&lt; "size of myints:" &lt;&lt; myints.size() &lt;&lt; std::endl; std::cout &lt;&lt; "sizeof(myints):" &lt;&lt; sizeof(myints) &lt;&lt; std::endl; return 0;&#125; Possible Output 12size of myints: 5sizeof(myints): 20 array::max_size返回数组容器可容纳的最大元素数。数组对象的max_size与其size一样，始终等于用于实例化数组模板类的第二个模板参数。 1constexpr size_type max_size() noexcept; Example 1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,10&gt; myints; std::cout &lt;&lt; "size of myints: " &lt;&lt; myints.size() &lt;&lt; '\n'; std::cout &lt;&lt; "max_size of myints: " &lt;&lt; myints.max_size() &lt;&lt; '\n'; return 0;&#125; Output 12size of myints: 10max_size of myints: 10 array::empty返回一个布尔值，指示数组容器是否为空，即它的size()是否为0。 1constexpr bool empty() noexcept; Example 1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,0&gt; first; std::array&lt;int,5&gt; second; std::cout &lt;&lt; "first " &lt;&lt; (first.empty() ? "is empty" : "is not empty") &lt;&lt; '\n'; std::cout &lt;&lt; "second " &lt;&lt; (second.empty() ? "is empty" : "is not empty") &lt;&lt; '\n'; return 0;&#125; Output: 12first is emptysecond is not empt array::operator[]返回数组中第n个位置的元素的引用。与array::at相似，但array::at会检查数组边界并通过抛出一个out_of_range异常来判断n是否超出范围，而array::operator[]不检查边界。 12 reference operator[] (size_type n);const_reference operator[] (size_type n) const; Example 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,10&gt; myarray; unsigned int i; // assign some values: for(i=0; i&lt;10; i++) myarray[i] = i; // print content std::cout &lt;&lt; "myarray contains:"; for(i=0; i&lt;10; i++) std::cout &lt;&lt; ' ' &lt;&lt; myarray[i]; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 0 1 2 3 4 5 6 7 8 9 array::at返回数组中第n个位置的元素的引用。与array::operator[]相似，但array::at会检查数组边界并通过抛出一个out_of_range异常来判断n是否超出范围，而array::operator[]不检查边界。 12 reference at ( size_type n );const_reference at ( size_type n ) const; Example 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main()&#123; std::array&lt;int, 10&gt; myarray; unsigned int i; // assign some values: for (i = 0; i&lt;10; i++) myarray[i] = i; // print content std::cout &lt;&lt; "myarray contains:"; for (i = 0; i&lt;10; i++) std::cout &lt;&lt; ' ' &lt;&lt; myarray.at(i); std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 0 1 2 3 4 5 6 7 8 9 array::front返回对数组容器中第一个元素的引用。array::begin返回的是迭代器，array::front返回的是直接引用。在空容器上调用此函数会导致未定义的行为。 12 reference front();const_reference front() const; Example 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;2, 16, 77&#125;; std::cout &lt;&lt; "front is: " &lt;&lt; myarray.front() &lt;&lt; std::endl; // 2 std::cout &lt;&lt; "back is: " &lt;&lt; myarray.back() &lt;&lt; std::endl; // 77 myarray.front() = 100; std::cout &lt;&lt; "myarray now contains:"; for ( int&amp; x : myarray ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 123front is: 2back is: 77myarray now contains: 100 16 77 array::back返回对数组容器中最后一个元素的引用。array::end返回的是迭代器，array::back返回的是直接引用。在空容器上调用此函数会导致未定义的行为。 12 reference back();const_reference back() const; Example 123456789101112131415161718#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;5, 19, 77&#125;; std::cout &lt;&lt; "front is: " &lt;&lt; myarray.front() &lt;&lt; std::endl; // 5 std::cout &lt;&lt; "back is: " &lt;&lt; myarray.back() &lt;&lt; std::endl; // 77 myarray.back() = 50; std::cout &lt;&lt; "myarray now contains:"; for ( int&amp; x : myarray ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 123front is: 5back is: 77myarray now contains: 5 19 50 array::data返回指向数组对象中第一个元素的指针。 由于数组中的元素存储在连续的存储位置，所以检索到的指针可以偏移以访问数组中的任何元素。 12 value_type* data() noexcept;const value_type* data() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;array&gt;int main ()&#123; const char* cstr = "Test string"; std::array&lt;char,12&gt; charray; std::memcpy (charray.data(),cstr,12); std::cout &lt;&lt; charray.data() &lt;&lt; '\n'; return 0;&#125; Output 1Test string array::fill用val填充数组所有元素，将val设置为数组对象中所有元素的值。 1void fill (const value_type&amp; val); Example 123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main () &#123; std::array&lt;int,6&gt; myarray; myarray.fill(5); std::cout &lt;&lt; "myarray contains:"; for ( int&amp; x : myarray) &#123; std::cout &lt;&lt; ' ' &lt;&lt; x; &#125; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 5 5 5 5 5 5 array::swap通过x的内容交换数组的内容，这是另一个相同类型的数组对象（包括相同的大小）。 与其他容器的交换成员函数不同，此成员函数通过在各个元素之间执行与其大小相同的单独交换操作，以线性时间运行。 1void swap (array&amp; x) noexcept(noexcept(swap(declval&lt;value_type&amp;&gt;(),declval&lt;value_type&amp;&gt;()))); Example 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; first = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; second = &#123;11, 22, 33, 44, 55&#125;; first.swap (second); std::cout &lt;&lt; "first:"; for (int&amp; x : first) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "second:"; for (int&amp; x : second) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 12first: 11 22 33 44 55second: 10 20 30 40 50 get（array）形如：std::get&lt;0&gt;(myarray)；传入一个数组容器，返回指定位置元素的引用。 123template &lt;size_t I，class T，size_t N&gt; T＆get（array &lt;T，N&gt;＆arr）noexcept; template &lt;size_t I，class T，size_t N&gt; T &amp;&amp; get（array &lt;T，N&gt; &amp;&amp; arr）noexcept; template &lt;size_t I，class T，size_t N&gt; const T＆get（const array &lt;T，N&gt;＆arr）noexcept; Example 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;#include &lt;tuple&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;10, 20, 30&#125;; std::tuple&lt;int,int,int&gt; mytuple (10, 20, 30); std::tuple_element&lt;0,decltype(myarray)&gt;::type myelement; // int myelement myelement = std::get&lt;2&gt;(myarray); std::get&lt;2&gt;(myarray) = std::get&lt;0&gt;(myarray); std::get&lt;0&gt;(myarray) = myelement; std::cout &lt;&lt; "first element in myarray: " &lt;&lt; std::get&lt;0&gt;(myarray) &lt;&lt; "\n"; std::cout &lt;&lt; "first element in mytuple: " &lt;&lt; std::get&lt;0&gt;(mytuple) &lt;&lt; "\n"; return 0;&#125; Output 12first element in myarray: 30first element in mytuple: 10 relational operators (array)形如：arrayA != arrayB、arrayA &gt; arrayB；依此比较数组每个元素的大小关系。 123456789101112131415161718（1） template &lt;class T，size_T N&gt; bool operator ==（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（2） template &lt;class T，size_T N&gt; bool operator！=（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（3） template &lt;class T，size_T N&gt; bool operator &lt;（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（4） template &lt;class T，size_T N&gt; bool operator &lt;=（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（5） template &lt;class T，size_T N&gt; bool operator&gt;（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（6） template &lt;class T，size_T N&gt; bool operator&gt; =（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）; Example 123456789101112131415161718#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; a = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; b = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; c = &#123;50, 40, 30, 20, 10&#125;; if (a==b) std::cout &lt;&lt; "a and b are equal\n"; if (b!=c) std::cout &lt;&lt; "b and c are not equal\n"; if (b&lt;c) std::cout &lt;&lt; "b is less than c\n"; if (c&gt;b) std::cout &lt;&lt; "c is greater than b\n"; if (a&lt;=b) std::cout &lt;&lt; "a is less than or equal to b\n"; if (a&gt;=b) std::cout &lt;&lt; "a is greater than or equal to b\n"; return 0;&#125; Output 123456a and b are equalb and c are not equalb is less than cc is greater than ba is less than or equal to ba is greater than or equal to b vectorvector是表示可以改变大小的数组的序列容器。 就像数组一样，vector为它们的元素使用连续的存储位置，这意味着它们的元素也可以使用到其元素的常规指针上的偏移来访问，而且和数组一样高效。但是与数组不同的是，它们的大小可以动态地改变，它们的存储由容器自动处理。 在内部，vector使用一个动态分配的数组来存储它们的元素。这个数组可能需要重新分配，以便在插入新元素时增加大小，这意味着分配一个新数组并将所有元素移动到其中。就处理时间而言，这是一个相对昂贵的任务，因此每次将元素添加到容器时矢量都不会重新分配。 相反，vector容器可以分配一些额外的存储以适应可能的增长，并且因此容器可以具有比严格需要包含其元素（即，其大小）的存储更大的实际容量。库可以实现不同的策略的增长到内存使用和重新分配之间的平衡，但在任何情况下，再分配应仅在对数生长的间隔发生尺寸，使得在所述载体的末端各个元件的插入可以与提供分期常量时间复杂性。 因此，与数组相比，载体消耗更多的内存来交换管理存储和以有效方式动态增长的能力。 与其他动态序列容器（deques，lists和 forward_lists ）相比，vector非常有效地访问其元素（就像数组一样），并相对有效地从元素末尾添加或移除元素。对于涉及插入或移除除了结尾之外的位置的元素的操作，它们执行比其他位置更差的操作，并且具有比列表和 forward_lists 更不一致的迭代器和引用。 针对 vector 的各种常见操作的复杂度（效率）如下： 随机访问 - 常数 O(1) 在尾部增删元素 - 平摊（amortized）常数 O(1)}} 增删元素 - 至 vector 尾部的线性距离 O(n)}} 1template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class vector; vector::vector（1）empty容器构造函数（默认构造函数）构造一个空的容器，没有元素。（2）fill构造函数用n个元素构造一个容器。每个元素都是val的副本（如果提供）。（3）范围（range）构造器使用与[ range，first，last]范围内的元素相同的顺序构造一个容器，其中的每个元素都是emplace -从该范围内相应的元素构造而成。（4）复制（copy）构造函数（并用分配器复制）按照相同的顺序构造一个包含x中每个元素的副本的容器。（5）移动（move）构造函数（和分配器移动）构造一个获取x元素的容器。如果指定了alloc并且与x的分配器不同，那么元素将被移动。否则，没有构建元素（他们的所有权直接转移）。x保持未指定但有效的状态。（6）初始化列表构造函数构造一个容器中的每个元件中的一个拷贝的IL，以相同的顺序。 12345678910111213141516171819default (1) explicit vector (const allocator_type&amp; alloc = allocator_type());fill (2) explicit vector (size_type n); vector (size_type n, const value_type&amp; val, const allocator_type&amp; alloc = allocator_type());range (3) template &lt;class InputIterator&gt; vector (InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type());copy (4) vector (const vector&amp; x);vector (const vector&amp; x, const allocator_type&amp; alloc);move (5) vector (vector&amp;&amp; x);vector (vector&amp;&amp; x, const allocator_type&amp; alloc);initializer list (6) vector (initializer_list&lt;value_type&gt; il, const allocator_type&amp; alloc = allocator_type()); Example 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; // constructors used in the same order as described above: std::vector&lt;int&gt; first; // empty vector of ints std::vector&lt;int&gt; second(4, 100); // four ints with value 100 std::vector&lt;int&gt; third(second.begin(), second.end());// iterating through second std::vector&lt;int&gt; fourth(third); // a copy of third // the iterator constructor can also be used to construct from arrays: int myints[] = &#123;16,2,77,29&#125;; std::vector&lt;int&gt; fifth(myints, myints + sizeof(myints) / sizeof(int)); std::cout &lt;&lt; "The contents of fifth are:"; for(std::vector&lt;int&gt;::iterator it = fifth.begin(); it != fifth.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1The contents of fifth are: 16 2 77 29 vector::~vector销毁容器对象。这将在每个包含的元素上调用allocator_traits::destroy，并使用其分配器释放由矢量分配的所有存储容量。 1~vector(); vector::operator=将新内容分配给容器，替换其当前内容，并相应地修改其大小。 123456copy (1) vector&amp; operator= (const vector&amp; x);move (2) vector&amp; operator= (vector&amp;&amp; x);initializer list (3) vector&amp; operator= (initializer_list&lt;value_type&gt; il); Example 123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; foo (3,0); std::vector&lt;int&gt; bar (5,0); bar = foo; foo = std::vector&lt;int&gt;(); std::cout &lt;&lt; &quot;Size of foo: &quot; &lt;&lt; int(foo.size()) &lt;&lt; &apos;\n&apos;; std::cout &lt;&lt; &quot;Size of bar: &quot; &lt;&lt; int(bar.size()) &lt;&lt; &apos;\n&apos;; return 0;&#125; Output 12Size of foo: 0Size of bar: 3 vector::beginvector::endvector::rbeginvector::rendvector::cbeginvector::cendvector::rcbeginvector::rcendvector::size返回vector中元素的数量。 这是vector中保存的实际对象的数量，不一定等于其存储容量。 1size_type size() const noexcept; Example 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myints; std::cout &lt;&lt; "0. size: " &lt;&lt; myints.size() &lt;&lt; '\n'; for (int i=0; i&lt;10; i++) myints.push_back(i); std::cout &lt;&lt; "1. size: " &lt;&lt; myints.size() &lt;&lt; '\n'; myints.insert (myints.end(),10,100); std::cout &lt;&lt; "2. size: " &lt;&lt; myints.size() &lt;&lt; '\n'; myints.pop_back(); std::cout &lt;&lt; "3. size: " &lt;&lt; myints.size() &lt;&lt; '\n'; return 0;&#125; Output 12340. size: 01. size: 102. size: 203. size: 19 vector::max_size返回该vector可容纳的元素的最大数量。由于已知的系统或库实现限制， 这是容器可以达到的最大潜在大小，但容器无法保证能够达到该大小：在达到该大小之前的任何时间，仍然无法分配存储。 1size_type max_size() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some content in the vector: for (int i=0; i&lt;100; i++) myvector.push_back(i); std::cout &lt;&lt; "size: " &lt;&lt; myvector.size() &lt;&lt; "\n"; std::cout &lt;&lt; "capacity: " &lt;&lt; myvector.capacity() &lt;&lt; "\n"; std::cout &lt;&lt; "max_size: " &lt;&lt; myvector.max_size() &lt;&lt; "\n"; return 0;&#125; A possible output for this program could be: 123size: 100capacity: 128max_size: 1073741823 vector::resize调整容器的大小，使其包含n个元素。 如果n小于当前的容器size，内容将被缩小到前n个元素，将其删除（并销毁它们）。 如果n大于当前容器size，则通过在末尾插入尽可能多的元素以达到大小n来扩展内容。如果指定了val，则新元素将初始化为val的副本，否则将进行值初始化。 如果n也大于当前的容器的capacity（容量），分配的存储空间将自动重新分配。 注意这个函数通过插入或者删除元素的内容来改变容器的实际内容。 12void resize (size_type n);void resize (size_type n, const value_type&amp; val); Example 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some initial content: for (int i=1;i&lt;10;i++) myvector.push_back(i); myvector.resize(5); myvector.resize(8,100); myvector.resize(12); std::cout &lt;&lt; "myvector contains:"; for (int i=0;i&lt;myvector.size();i++) std::cout &lt;&lt; ' ' &lt;&lt; myvector[i]; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myvector contains: 1 2 3 4 5 100 100 100 0 0 0 0 vector::capacity返回当前为vector分配的存储空间的大小，用元素表示。这个capacity(容量)不一定等于vector的size。它可以相等或更大，额外的空间允许适应增长，而不需要重新分配每个插入。 1size_type capacity() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some content in the vector: for (int i=0; i&lt;100; i++) myvector.push_back(i); std::cout &lt;&lt; "size: " &lt;&lt; (int) myvector.size() &lt;&lt; '\n'; std::cout &lt;&lt; "capacity: " &lt;&lt; (int) myvector.capacity() &lt;&lt; '\n'; std::cout &lt;&lt; "max_size: " &lt;&lt; (int) myvector.max_size() &lt;&lt; '\n'; return 0;&#125; A possible output for this program could be: 123size: 100capacity: 128max_size: 1073741823 vector::empty返回vector是否为空（即，它的size是否为0） 1bool empty() const noexcept; Example 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int sum (0); for (int i=1;i&lt;=10;i++) myvector.push_back(i); while (!myvector.empty()) &#123; sum += myvector.back(); myvector.pop_back(); &#125; std::cout &lt;&lt; "total: " &lt;&lt; sum &lt;&lt; '\n'; return 0;&#125; Output 1total: 55 vector::reserve请求vector容量至少足以包含n个元素。 如果n大于当前vector容量，则该函数使容器重新分配其存储容量，从而将其容量增加到n（或更大）。 在所有其他情况下，函数调用不会导致重新分配，并且vector容量不受影响。 这个函数对vector大小没有影响，也不能改变它的元素。 1void reserve (size_type n); Example 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt;::size_type sz; std::vector&lt;int&gt; foo; sz = foo.capacity(); std::cout &lt;&lt; "making foo grow:\n"; for (int i=0; i&lt;100; ++i) &#123; foo.push_back(i); if (sz!=foo.capacity()) &#123; sz = foo.capacity(); std::cout &lt;&lt; "capacity changed: " &lt;&lt; sz &lt;&lt; '\n'; &#125; &#125; std::vector&lt;int&gt; bar; sz = bar.capacity(); bar.reserve(100); // this is the only difference with foo above std::cout &lt;&lt; "making bar grow:\n"; for (int i=0; i&lt;100; ++i) &#123; bar.push_back(i); if (sz!=bar.capacity()) &#123; sz = bar.capacity(); std::cout &lt;&lt; "capacity changed: " &lt;&lt; sz &lt;&lt; '\n'; &#125; &#125; return 0;&#125; Possible output 1234567891011making foo grow:capacity changed: 1capacity changed: 2capacity changed: 4capacity changed: 8capacity changed: 16capacity changed: 32capacity changed: 64capacity changed: 128making bar grow:capacity changed: 100 vector::shrink_to_fit要求容器减小其capacity(容量)以适应其尺寸。 该请求是非绑定的，并且容器实现可以自由地进行优化，并且保持capacity大于其size的vector。 这可能导致重新分配，但对矢量大小没有影响，并且不能改变其元素。 1void shrink_to_fit(); Example 12345678910111213141516#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector (100); std::cout &lt;&lt; "1. capacity of myvector: " &lt;&lt; myvector.capacity() &lt;&lt; '\n'; myvector.resize(10); std::cout &lt;&lt; "2. capacity of myvector: " &lt;&lt; myvector.capacity() &lt;&lt; '\n'; myvector.shrink_to_fit(); std::cout &lt;&lt; "3. capacity of myvector: " &lt;&lt; myvector.capacity() &lt;&lt; '\n'; return 0;&#125; Possible output 1231. capacity of myvector: 1002. capacity of myvector: 1003. capacity of myvector: 10 vector::operator[]vector::atvector::frontvector::backvector::datavector::assign将新内容分配给vector，替换其当前内容，并相应地修改其大小。 在范围版本（1）中，新内容是从第一个和最后一个范围内的每个元素按相同顺序构造的元素。 在填充版本（2）中，新内容是n个元素，每个元素都被初始化为一个val的副本。 在初始化列表版本（3）中，新内容是以相同顺序作为初始化列表传递的值的副本。 所述内部分配器被用于（通过其性状），以分配和解除分配存储器如果重新分配发生。它也习惯于摧毁所有现有的元素，并构建新的元素。 1234567range (1) template &lt;class InputIterator&gt; void assign (InputIterator first, InputIterator last);fill (2) void assign (size_type n, const value_type&amp; val);initializer list (3) void assign (initializer_list&lt;value_type&gt; il); Example 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; first; std::vector&lt;int&gt; second; std::vector&lt;int&gt; third; first.assign (7,100); // 7 ints with a value of 100 std::vector&lt;int&gt;::iterator it; it=first.begin()+1; second.assign (it,first.end()-1); // the 5 central values of first int myints[] = &#123;1776,7,4&#125;; third.assign (myints,myints+3); // assigning from array. std::cout &lt;&lt; "Size of first: " &lt;&lt; int (first.size()) &lt;&lt; '\n'; std::cout &lt;&lt; "Size of second: " &lt;&lt; int (second.size()) &lt;&lt; '\n'; std::cout &lt;&lt; "Size of third: " &lt;&lt; int (third.size()) &lt;&lt; '\n'; return 0;&#125; Output 123Size of first: 7Size of second: 5Size of third: 3 补充：vector::assign 与 vector::operator= 的区别： vector::assign 实现源码 12345678910111213141516void assign(size_type __n, const _Tp&amp; __val) &#123; _M_fill_assign(__n, __val); &#125;template &lt;class _Tp, class _Alloc&gt;void vector&lt;_Tp, _Alloc&gt;::_M_fill_assign(size_t __n, const value_type&amp; __val) &#123; if (__n &gt; capacity()) &#123; vector&lt;_Tp, _Alloc&gt; __tmp(__n, __val, get_allocator()); __tmp.swap(*this); &#125; else if (__n &gt; size()) &#123; fill(begin(), end(), __val); _M_finish = uninitialized_fill_n(_M_finish, __n - size(), __val); &#125; else erase(fill_n(begin(), __n, __val), end());&#125; vector::operator= 实现源码 12345678910111213141516171819202122232425template &lt;class _Tp, class _Alloc&gt;vector&lt;_Tp,_Alloc&gt;&amp; vector&lt;_Tp,_Alloc&gt;::operator=(const vector&lt;_Tp, _Alloc&gt;&amp; __x)&#123; if (&amp;__x != this) &#123; const size_type __xlen = __x.size(); if (__xlen &gt; capacity()) &#123; iterator __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end()); destroy(_M_start, _M_finish); _M_deallocate(_M_start, _M_end_of_storage - _M_start); _M_start = __tmp; _M_end_of_storage = _M_start + __xlen; &#125; else if (size() &gt;= __xlen) &#123; iterator __i = copy(__x.begin(), __x.end(), begin()); destroy(__i, _M_finish); &#125; else &#123; copy(__x.begin(), __x.begin() + size(), _M_start); uninitialized_copy(__x.begin() + size(), __x.end(), _M_finish); &#125; _M_finish = _M_start + __xlen; &#125; return *this;&#125; vector::push_back在vector的最后一个元素之后添加一个新元素。val的内容被复制（或移动）到新的元素。 这有效地将容器size增加了一个，如果新的矢量size超过了当前vector的capacity，则导致所分配的存储空间自动重新分配。 12void push_back (const value_type&amp; val);void push_back (value_type&amp;&amp; val); Example 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int myint; std::cout &lt;&lt; "Please enter some integers (enter 0 to end):\n"; do &#123; std::cin &gt;&gt; myint; myvector.push_back (myint); &#125; while (myint); std::cout &lt;&lt; "myvector stores " &lt;&lt; int(myvector.size()) &lt;&lt; " numbers.\n"; return 0;&#125; vector::pop_back删除vector中的最后一个元素，有效地将容器size减少一个。 这破坏了被删除的元素。 1void pop_back(); Example 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int sum (0); myvector.push_back (100); myvector.push_back (200); myvector.push_back (300); while (!myvector.empty()) &#123; sum+=myvector.back(); myvector.pop_back(); &#125; std::cout &lt;&lt; "The elements of myvector add up to " &lt;&lt; sum &lt;&lt; '\n'; return 0;&#125; Output 1The elements of myvector add up to 600 vector::insert通过在指定位置的元素之前插入新元素来扩展该vector，通过插入元素的数量有效地增加容器大小。 这会导致分配的存储空间自动重新分配，只有在新的vector的size超过当前的vector的capacity的情况下。 由于vector使用数组作为其基础存储，因此除了将元素插入到vector末尾之后，或vector的begin之前，其他位置会导致容器重新定位位置之后的所有元素到他们的新位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。 1234567891011single element (1) iterator insert (const_iterator position, const value_type&amp; val);fill (2) iterator insert (const_iterator position, size_type n, const value_type&amp; val);range (3) template &lt;class InputIterator&gt;iterator insert (const_iterator position, InputIterator first, InputIterator last);move (4) iterator insert (const_iterator position, value_type&amp;&amp; val);initializer list (5) iterator insert (const_iterator position, initializer_list&lt;value_type&gt; il); Example 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector (3,100); std::vector&lt;int&gt;::iterator it; it = myvector.begin(); it = myvector.insert ( it , 200 ); myvector.insert (it,2,300); // "it" no longer valid, get a new one: it = myvector.begin(); std::vector&lt;int&gt; anothervector (2,400); myvector.insert (it+2,anothervector.begin(),anothervector.end()); int myarray [] = &#123; 501,502,503 &#125;; myvector.insert (myvector.begin(), myarray, myarray+3); std::cout &lt;&lt; "myvector contains:"; for (it=myvector.begin(); it&lt;myvector.end(); it++) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myvector contains: 501 502 503 300 300 400 400 200 100 100 100 补充：insert 迭代器野指针错误： 123456789101112131415int main()&#123; std::vector&lt;int&gt; v(5, 0); std::vector&lt;int&gt;::iterator vi; // 获取vector第一个元素的迭代器 vi = v.begin(); // push_back 插入元素之后可能会因为 push_back 的骚操作（创建一个新vector把旧vector的值复制到新vector），导致vector迭代器iterator的指针变成野指针，而导致insert出错 v.push_back(10); v.insert(vi, 2, 300); return 0;&#125; 改正：应该把vi = v.begin();放到v.push_back(10);后面 vector::erase从vector中删除单个元素（position）或一系列元素（[first，last））。 这有效地减少了被去除的元素的数量，从而破坏了容器的大小。 由于vector使用一个数组作为其底层存储，所以删除除vector结束位置之后，或vector的begin之前的元素外，将导致容器将段被擦除后的所有元素重新定位到新的位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。 12iterator erase (const_iterator position);iterator erase (const_iterator first, const_iterator last); Example 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some values (from 1 to 10) for (int i=1; i&lt;=10; i++) myvector.push_back(i); // erase the 6th element myvector.erase (myvector.begin()+5); // erase the first 3 elements: myvector.erase (myvector.begin(),myvector.begin()+3); std::cout &lt;&lt; "myvector contains:"; for (unsigned i=0; i&lt;myvector.size(); ++i) std::cout &lt;&lt; ' ' &lt;&lt; myvector[i]; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myvector contains: 4 5 7 8 9 10 vector::swap通过x的内容交换容器的内容，x是另一个相同类型的vector对象。尺寸可能不同。 在调用这个成员函数之后，这个容器中的元素是那些在调用之前在x中的元素，而x的元素是在这个元素中的元素。所有迭代器，引用和指针对交换对象保持有效。 请注意，非成员函数存在具有相同名称的交换，并使用与此成员函数相似的优化来重载该算法。 1void swap (vector&amp; x); Example 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; foo (3,100); // three ints with a value of 100 std::vector&lt;int&gt; bar (5,200); // five ints with a value of 200 foo.swap(bar); std::cout &lt;&lt; "foo contains:"; for (unsigned i=0; i&lt;foo.size(); i++) std::cout &lt;&lt; ' ' &lt;&lt; foo[i]; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "bar contains:"; for (unsigned i=0; i&lt;bar.size(); i++) std::cout &lt;&lt; ' ' &lt;&lt; bar[i]; std::cout &lt;&lt; '\n'; return 0;&#125; Output 12foo contains: 200 200 200 200 200 bar contains: 100 100 100 vector::clear从vector中删除所有的元素（被销毁），留下size为0的容器。 不保证重新分配，并且由于调用此函数， vector的capacity不保证发生变化。强制重新分配的典型替代方法是使用swap：vector&lt;T&gt;().swap(x); // clear x reallocating 1void clear() noexcept; Example 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;void printVector(const std::vector&lt;int&gt; &amp;v)&#123; for (auto it = v.begin(); it != v.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; ' '; &#125; std::cout &lt;&lt; std::endl;&#125;int main()&#123; std::vector&lt;int&gt; v1(5, 50); printVector(v1); std::cout &lt;&lt; "v1 size = " &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; "v1 capacity = " &lt;&lt; v1.capacity() &lt;&lt; std::endl; v1.clear(); printVector(v1); std::cout &lt;&lt; "v1 size = " &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; "v1 capacity = " &lt;&lt; v1.capacity() &lt;&lt; std::endl; v1.push_back(11); v1.push_back(22); printVector(v1); std::cout &lt;&lt; "v1 size = " &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; "v1 capacity = " &lt;&lt; v1.capacity() &lt;&lt; std::endl; return 0;&#125; Output 12345678950 50 50 50 50v1 size = 5v1 capacity = 5v1 size = 0v1 capacity = 511 22v1 size = 2v1 capacity = 5 vector::emplace通过在position位置处插入新元素args来扩展容器。这个新元素是用args作为构建的参数来构建的。 这有效地增加了一个容器的大小。 分配存储空间的自动重新分配发生在新的vector的size超过当前向量容量的情况下。 由于vector使用数组作为其基础存储，因此除了将元素插入到vector末尾之后，或vector的begin之前，其他位置会导致容器重新定位位置之后的所有元素到他们的新位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。 该元素是通过调用allocator_traits::construct来转换args来创建的。插入一个类似的成员函数，将现有对象复制或移动到容器中。 12template &lt;class... Args&gt;iterator emplace (const_iterator position, Args&amp;&amp;... args); Example 123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector = &#123;10,20,30&#125;; auto it = myvector.emplace ( myvector.begin()+1, 100 ); myvector.emplace ( it, 200 ); myvector.emplace ( myvector.end(), 300 ); std::cout &lt;&lt; "myvector contains:"; for (auto&amp; x: myvector) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myvector contains: 10 200 100 20 30 300 vector::emplace_back在vector的末尾插入一个新的元素，紧跟在当前的最后一个元素之后。这个新元素是用args作为构造函数的参数来构造的。 这有效地将容器大小增加了一个，如果新的矢量大小超过了当前的vector容量，则导致所分配的存储空间自动重新分配。 该元素是通过调用allocator_traits :: construct来转换args来创建的。 与push_back相比，emplace_back可以避免额外的复制和移动操作。 12template &lt;class... Args&gt; void emplace_back (Args&amp;&amp;... args); Example 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt; struct President&#123; std::string name; std::string country; int year; President(std::string p_name, std::string p_country, int p_year) : name(std::move(p_name)), country(std::move(p_country)), year(p_year) &#123; std::cout &lt;&lt; "I am being constructed.\n"; &#125; President(President&amp;&amp; other) : name(std::move(other.name)), country(std::move(other.country)), year(other.year) &#123; std::cout &lt;&lt; "I am being moved.\n"; &#125; President&amp; operator=(const President&amp; other) = default;&#125;; int main()&#123; std::vector&lt;President&gt; elections; std::cout &lt;&lt; "emplace_back:\n"; elections.emplace_back("Nelson Mandela", "South Africa", 1994); std::vector&lt;President&gt; reElections; std::cout &lt;&lt; "\npush_back:\n"; reElections.push_back(President("Franklin Delano Roosevelt", "the USA", 1936)); std::cout &lt;&lt; "\nContents:\n"; for (President const&amp; president: elections) &#123; std::cout &lt;&lt; president.name &lt;&lt; " was elected president of " &lt;&lt; president.country &lt;&lt; " in " &lt;&lt; president.year &lt;&lt; ".\n"; &#125; for (President const&amp; president: reElections) &#123; std::cout &lt;&lt; president.name &lt;&lt; " was re-elected president of " &lt;&lt; president.country &lt;&lt; " in " &lt;&lt; president.year &lt;&lt; ".\n"; &#125;&#125; Output 12345678910emplace_back:I am being constructed. push_back:I am being constructed.I am being moved. Contents:Nelson Mandela was elected president of South Africa in 1994.Franklin Delano Roosevelt was re-elected president of the USA in 1936. vector::get_allocator返回与vector关联的构造器对象的副本。 1allocator_type get_allocator() const noexcept; Example 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int * p; unsigned int i; // allocate an array with space for 5 elements using vector's allocator: p = myvector.get_allocator().allocate(5); // construct values in-place on the array: for (i=0; i&lt;5; i++) myvector.get_allocator().construct(&amp;p[i],i); std::cout &lt;&lt; "The allocated array contains:"; for (i=0; i&lt;5; i++) std::cout &lt;&lt; ' ' &lt;&lt; p[i]; std::cout &lt;&lt; '\n'; // destroy and deallocate: for (i=0; i&lt;5; i++) myvector.get_allocator().destroy(&amp;p[i]); myvector.get_allocator().deallocate(p,5); return 0;&#125; Output 1The allocated array contains: 0 1 2 3 4 注意：deallocate和destory的关系： deallocate实现的源码： template &lt;class T&gt; inline void _deallocate(T* buffer) { ::operator delete(buffer); //为什么不用 delete [] ? ,operator delete 区别于 delete //operator delete 是一个底层操作符 }destory： template &lt;class T&gt; inline void _destory(T *ptr) { ptr-&gt;~T(); }destory负责调用类型的析构函数，销毁相应内存上的内容（但销毁后内存地址仍保留） deallocate负责释放内存（此时相应内存中的值在此之前应调用destory销毁，将内存地址返回给系统，代表这部分地址使用引用-1） relational operators (vector)swap (vector)vector dequedeque（[‘dek]）（双端队列）是double-ended queue 的一个不规则缩写。deque是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩。 特定的库可以以不同的方式实现deques，通常作为某种形式的动态数组。但是在任何情况下，它们都允许通过随机访问迭代器直接访问各个元素，通过根据需要扩展和收缩容器来自动处理存储。 因此，它们提供了类似于vector的功能，但是在序列的开始部分也可以高效地插入和删除元素，而不仅仅是在结尾。但是，与vector不同，deques并不保证将其所有元素存储在连续的存储位置：deque通过偏移指向另一个元素的指针访问元素会导致未定义的行为。 两个vector和deques提供了一个非常相似的接口，可以用于类似的目的，但内部工作方式完全不同：虽然vector使用单个数组需要偶尔重新分配以增长，但是deque的元素可以分散在不同的块的容器，容器在内部保存必要的信息以提供对其任何元素的持续时间和统一的顺序接口（通过迭代器）的直接访问。因此，deques在内部比vector更复杂一点，但是这使得他们在某些情况下更有效地增长，尤其是在重新分配变得更加昂贵的很长序列的情况下。 对于频繁插入或删除开始或结束位置以外的元素的操作，deques表现得更差，并且与列表和转发列表相比，迭代器和引用的一致性更低。 deque上常见操作的复杂性（效率）如下： 随机访问 - 常数O(1) 在结尾或开头插入或移除元素 - 摊销不变O(1) 插入或移除元素 - 线性O(n)1template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class deque; deque::deque构造一个deque容器对象，根据所使用的构造函数版本初始化它的内容： Example 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; unsigned int i; // constructors used in the same order as described above: std::deque&lt;int&gt; first; // empty deque of ints std::deque&lt;int&gt; second (4,100); // four ints with value 100 std::deque&lt;int&gt; third (second.begin(),second.end()); // iterating through second std::deque&lt;int&gt; fourth (third); // a copy of third // the iterator constructor can be used to copy arrays: int myints[] = &#123;16,2,77,29&#125;; std::deque&lt;int&gt; fifth (myints, myints + sizeof(myints) / sizeof(int) ); std::cout &lt;&lt; "The contents of fifth are:"; for (std::deque&lt;int&gt;::iterator it = fifth.begin(); it!=fifth.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1The contents of fifth are: 16 2 77 29 deque::push_back在当前的最后一个元素之后 ，在deque容器的末尾添加一个新元素。val的内容被复制（或移动）到新的元素。 这有效地增加了一个容器的大小。 12void push_back (const value_type&amp; val);void push_back (value_type&amp;&amp; val); Example 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; int myint; std::cout &lt;&lt; "Please enter some integers (enter 0 to end):\n"; do &#123; std::cin &gt;&gt; myint; mydeque.push_back (myint); &#125; while (myint); std::cout &lt;&lt; "mydeque stores " &lt;&lt; (int) mydeque.size() &lt;&lt; " numbers.\n"; return 0;&#125; deque::push_front在deque容器的开始位置插入一个新的元素，位于当前的第一个元素之前。val的内容被复制（或移动）到插入的元素。 这有效地增加了一个容器的大小。 12void push_front (const value_type&amp; val);void push_front (value_type&amp;&amp; val); Example 12345678910111213141516#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque (2,100); // two ints with a value of 100 mydeque.push_front (200); mydeque.push_front (300); std::cout &lt;&lt; "mydeque contains:"; for (std::deque&lt;int&gt;::iterator it = mydeque.begin(); it != mydeque.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1300 200 100 100 deque::pop_back删除deque容器中的最后一个元素，有效地将容器大小减少一个。 这破坏了被删除的元素。 1void pop_back(); Example 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; int sum (0); mydeque.push_back (10); mydeque.push_back (20); mydeque.push_back (30); while (!mydeque.empty()) &#123; sum+=mydeque.back(); mydeque.pop_back(); &#125; std::cout &lt;&lt; "The elements of mydeque add up to " &lt;&lt; sum &lt;&lt; '\n'; return 0;&#125; Output 1The elements of mydeque add up to 60 deque::pop_front删除deque容器中的第一个元素，有效地减小其大小。 这破坏了被删除的元素。 1void pop_front(); Example 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; mydeque.push_back (100); mydeque.push_back (200); mydeque.push_back (300); std::cout &lt;&lt; "Popping out the elements in mydeque:"; while (!mydeque.empty()) &#123; std::cout &lt;&lt; ' ' &lt;&lt; mydeque.front(); mydeque.pop_front(); &#125; std::cout &lt;&lt; "\nThe final size of mydeque is " &lt;&lt; int(mydeque.size()) &lt;&lt; '\n'; return 0;&#125; Output 12Popping out the elements in mydeque: 100 200 300The final size of mydeque is 0 deque::emplace_front在deque的开头插入一个新的元素，就在其当前的第一个元素之前。这个新的元素是用args作为构建的参数来构建的。 这有效地增加了一个容器的大小。 该元素是通过调用allocator_traits::construct来转换args来创建的。 存在一个类似的成员函数push_front，它可以将现有对象复制或移动到容器中。 12template &lt;class... Args&gt; void emplace_front (Args&amp;&amp;... args); Example 1234567891011121314151617#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque = &#123;10,20,30&#125;; mydeque.emplace_front (111); mydeque.emplace_front (222); std::cout &lt;&lt; "mydeque contains:"; for (auto&amp; x: mydeque) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1mydeque contains: 222 111 10 20 30 deque::emplace_back在deque的末尾插入一个新的元素，紧跟在当前的最后一个元素之后。这个新的元素是用args作为构建的参数来构建的。 这有效地增加了一个容器的大小。 该元素是通过调用allocator_traits::construct来转换args来创建的。 存在一个类似的成员函数push_back，它可以将现有对象复制或移动到容器中 12template &lt;class... Args&gt; void emplace_back (Args&amp;&amp;... args); Example 1234567891011121314151617#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque = &#123;10,20,30&#125;; mydeque.emplace_back (100); mydeque.emplace_back (200); std::cout &lt;&lt; "mydeque contains:"; for (auto&amp; x: mydeque) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1mydeque contains: 10 20 30 100 200 forward_listforward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。 forward_list（单向链表）被实现为单链表; 单链表可以将它们包含的每个元素存储在不同和不相关的存储位置中。通过关联到序列中下一个元素的链接的每个元素来保留排序。forward_list容器和列表 之间的主要设计区别容器是第一个内部只保留一个到下一个元素的链接，而后者每个元素保留两个链接：一个指向下一个元素，一个指向前一个元素，允许在两个方向上有效的迭代，但是每个元素消耗额外的存储空间并且插入和移除元件的时间开销略高。因此，forward_list对象比列表对象更有效率，尽管它们只能向前迭代。 与其他基本的标准序列容器（array，vector和deque），forward_list通常在插入，提取和移动容器内任何位置的元素方面效果更好，因此也适用于密集使用这些元素的算法，如排序算法。 的主要缺点修饰符Modifiers S和列表相比这些其它序列容器s是说，他们缺乏可以通过位置的元素的直接访问; 例如，要访问forward_list中的第六个元素，必须从开始位置迭代到该位置，这需要在这些位置之间的线性时间。它们还消耗一些额外的内存来保持与每个元素相关联的链接信息（这可能是大型小元素列表的重要因素）。 该修饰符Modifiersclass模板的设计考虑到效率：按照设计，它与简单的手写C型单链表一样高效，实际上是唯一的标准容器，为了效率的考虑故意缺少尺寸成员函数：由于其性质作为一个链表，具有一个需要一定时间的大小的成员将需要它保持一个内部计数器的大小（如列表所示）。这会消耗一些额外的存储空间，并使插入和删除操作效率稍低。要获取forward_list对象的大小，可以使用距离算法的开始和结束，这是一个需要线性时间的操作。 forward_list::forward_list12345678910111213141516171819default (1) explicit forward_list (const allocator_type&amp; alloc = allocator_type());fill (2) explicit forward_list (size_type n);explicit forward_list (size_type n, const value_type&amp; val, const allocator_type&amp; alloc = allocator_type());range (3) template &lt;class InputIterator&gt; forward_list (InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type());copy (4) forward_list (const forward_list&amp; fwdlst);forward_list (const forward_list&amp; fwdlst, const allocator_type&amp; alloc);move (5) forward_list (forward_list&amp;&amp; fwdlst);forward_list (forward_list&amp;&amp; fwdlst, const allocator_type&amp; alloc);initializer list (6) forward_list (initializer_list&lt;value_type&gt; il, const allocator_type&amp; alloc = allocator_type()); Example 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; // constructors used in the same order as described above: std::forward_list&lt;int&gt; first; // default: empty std::forward_list&lt;int&gt; second (3,77); // fill: 3 seventy-sevens std::forward_list&lt;int&gt; third (second.begin(), second.end()); // range initialization std::forward_list&lt;int&gt; fourth (third); // copy constructor std::forward_list&lt;int&gt; fifth (std::move(fourth)); // move ctor. (fourth wasted) std::forward_list&lt;int&gt; sixth = &#123;3, 52, 25, 90&#125;; // initializer_list constructor std::cout &lt;&lt; "first:" ; for (int&amp; x: first) std::cout &lt;&lt; " " &lt;&lt; x; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "second:"; for (int&amp; x: second) std::cout &lt;&lt; " " &lt;&lt; x; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "third:"; for (int&amp; x: third) std::cout &lt;&lt; " " &lt;&lt; x; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "fourth:"; for (int&amp; x: fourth) std::cout &lt;&lt; " " &lt;&lt; x; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "fifth:"; for (int&amp; x: fifth) std::cout &lt;&lt; " " &lt;&lt; x; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "sixth:"; for (int&amp; x: sixth) std::cout &lt;&lt; " " &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Possible output 1234567forward_list constructor examples:first:second: 77 77 77third: 77 77 77fourth:fifth: 77 77 77sixth: 3 52 25 90 forward_list::~forward_listforward_list::before_begin返回指向容器中第一个元素之前的位置的迭代器。 返回的迭代器不应被解除引用：它是为了用作成员函数的参数emplace_after，insert_after，erase_after或splice_after，指定序列，其中执行该动作的位置的开始位置。 12 iterator before_begin() noexcept;const_iterator before_begin() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; std::forward_list&lt;int&gt; mylist = &#123;20, 30, 40, 50&#125;; mylist.insert_after ( mylist.before_begin(), 11 ); std::cout &lt;&lt; "mylist contains:"; for ( int&amp; x: mylist ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1mylist contains: 11 20 30 40 50 forward_list::cbefore_begin返回指向容器中第一个元素之前的位置的const_iterator。 一个常量性是指向常量内容的迭代器。这个迭代器可以增加和减少（除非它本身也是const），就像forward_list::before_begin返回的迭代器一样，但不能用来修改它指向的内容。 返回的价值不得解除引用。 1const_iterator cbefore_begin() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; std::forward_list&lt;int&gt; mylist = &#123;77, 2, 16&#125;; mylist.insert_after ( mylist.cbefore_begin(), 19 ); std::cout &lt;&lt; "mylist contains:"; for ( int&amp; x: mylist ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1mylist contains: 19 77 2 16 liststackqueuepriority_queuesetmultisetmapmap 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。 在映射中，键值通常用于对元素进行排序和唯一标识，而映射的值存储与此键关联的内容。该类型的键和映射的值可能不同，并且在部件类型被分组在一起VALUE_TYPE，这是一种对类型结合两种： 1typedef pair&lt;const Key, T&gt; value_type; 在内部，映射中的元素总是按照由其内部比较对象（比较类型）指示的特定的严格弱排序标准按键排序。映射容器通常比unordered_map容器慢，以通过它们的键来访问各个元素，但是它们允许基于它们的顺序对子集进行直接迭代。 在该映射值地图可以直接通过使用其相应的键来访问括号运算符（（操作符[] ）。 映射通常如实施 12345template &lt; class Key, // map::key_type class T, // map::mapped_type class Compare = less&lt;Key&gt;, // map::key_compare class Alloc = allocator&lt;pair&lt;const Key,T&gt; &gt; // map::allocator_type &gt; class map; map::map构造一个映射容器对象，根据所使用的构造器版本初始化其内容： （1）空容器构造函数（默认构造函数） 构造一个空的容器，没有元素。 （2）范围构造函数 构造具有一样多的元素的范围内的容器[第一，最后一个），其中每个元件布设构造的从在该范围内它的相应的元件。 （3）复制构造函数（并用分配器复制） 使用x中的每个元素的副本构造一个容器。 （4）移动构造函数（并与分配器一起移动） 构造一个获取x元素的容器。如果指定了alloc并且与x的分配器不同，那么元素将被移动。否则，没有构建元素（他们的所有权直接转移）。x保持未指定但有效的状态。 （5）初始化列表构造函数 用il中的每个元素的副本构造一个容器。 12345678910111213141516171819empty (1) explicit map (const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type());explicit map (const allocator_type&amp; alloc);range (2) template &lt;class InputIterator&gt; map (InputIterator first, InputIterator last, const key_compare&amp; comp = key_compare(), const allocator_type&amp; = allocator_type());copy (3) map (const map&amp; x);map (const map&amp; x, const allocator_type&amp; alloc);move (4) map (map&amp;&amp; x);map (map&amp;&amp; x, const allocator_type&amp; alloc);initializer list (5) map (initializer_list&lt;value_type&gt; il, const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type()); Example 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;map&gt;bool fncomp (char lhs, char rhs) &#123;return lhs&lt;rhs;&#125;struct classcomp &#123; bool operator() (const char&amp; lhs, const char&amp; rhs) const &#123;return lhs&lt;rhs;&#125;&#125;;int main ()&#123; std::map&lt;char,int&gt; first; first['a']=10; first['b']=30; first['c']=50; first['d']=70; std::map&lt;char,int&gt; second (first.begin(),first.end()); std::map&lt;char,int&gt; third (second); std::map&lt;char,int,classcomp&gt; fourth; // class as Compare bool(*fn_pt)(char,char) = fncomp; std::map&lt;char,int,bool(*)(char,char)&gt; fifth (fn_pt); // function pointer as Compare return 0;&#125; map::begin返回引用map容器中第一个元素的迭代器。 由于map容器始终保持其元素的顺序，所以开始指向遵循容器排序标准的元素。 如果容器是空的，则返回的迭代器值不应被解除引用。 12 iterator begin() noexcept;const_iterator begin() const noexcept; Example 1234567891011121314151617#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['b'] = 100; mymap['a'] = 200; mymap['c'] = 300; // show content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; " =&gt; " &lt;&lt; it-&gt;second &lt;&lt; '\n'; return 0;&#125; Output 123a =&gt; 200b =&gt; 100c =&gt; 300 map::key_comp返回容器用于比较键的比较对象的副本。 1key_compare key_comp() const; Example 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::key_compare mycomp = mymap.key_comp(); mymap['a']=100; mymap['b']=200; mymap['c']=300; std::cout &lt;&lt; "mymap contains:\n"; char highest = mymap.rbegin()-&gt;first; // key value of last element std::map&lt;char,int&gt;::iterator it = mymap.begin(); do &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; " =&gt; " &lt;&lt; it-&gt;second &lt;&lt; '\n'; &#125; while ( mycomp((*it++).first, highest) ); std::cout &lt;&lt; '\n'; return 0;&#125; Output 1234mymap contains:a =&gt; 100b =&gt; 200c =&gt; 300 map::value_comp返回可用于比较两个元素的比较对象，以获取第一个元素的键是否在第二个元素之前。 1value_compare value_comp() const; Example 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['x']=1001; mymap['y']=2002; mymap['z']=3003; std::cout &lt;&lt; "mymap contains:\n"; std::pair&lt;char,int&gt; highest = *mymap.rbegin(); // last element std::map&lt;char,int&gt;::iterator it = mymap.begin(); do &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; " =&gt; " &lt;&lt; it-&gt;second &lt;&lt; '\n'; &#125; while ( mymap.value_comp()(*it++, highest) ); return 0;&#125; Output 1234mymap contains:x =&gt; 1001y =&gt; 2002z =&gt; 3003 map::find在容器中搜索具有等于k的键的元素，如果找到则返回一个迭代器，否则返回map::end的迭代器。 如果容器的比较对象自反地返回假（即，不管元素作为参数传递的顺序），则两个key被认为是等同的。 另一个成员函数map::count可以用来检查一个特定的键是否存在。 12 iterator find (const key_type&amp; k);const_iterator find (const key_type&amp; k) const; Example 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator it; mymap['a']=50; mymap['b']=100; mymap['c']=150; mymap['d']=200; it = mymap.find('b'); if (it != mymap.end()) mymap.erase (it); // print content: std::cout &lt;&lt; "elements in mymap:" &lt;&lt; '\n'; std::cout &lt;&lt; "a =&gt; " &lt;&lt; mymap.find('a')-&gt;second &lt;&lt; '\n'; std::cout &lt;&lt; "c =&gt; " &lt;&lt; mymap.find('c')-&gt;second &lt;&lt; '\n'; std::cout &lt;&lt; "d =&gt; " &lt;&lt; mymap.find('d')-&gt;second &lt;&lt; '\n'; return 0;&#125; Output 1234elements in mymap:a =&gt; 50c =&gt; 150d =&gt; 200 map::count在容器中搜索具有等于k的键的元素，并返回匹配的数量。 由于地图容器中的所有元素都是唯一的，因此该函数只能返回1（如果找到该元素）或返回零（否则）。 如果容器的比较对象自反地返回错误（即，不管按键作为参数传递的顺序），则两个键被认为是等同的。 1size_type count (const key_type&amp; k) const; Example 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; char c; mymap ['a']=101; mymap ['c']=202; mymap ['f']=303; for (c='a'; c&lt;'h'; c++) &#123; std::cout &lt;&lt; c; if (mymap.count(c)&gt;0) std::cout &lt;&lt; " is an element of mymap.\n"; else std::cout &lt;&lt; " is not an element of mymap.\n"; &#125; return 0;&#125; Output 1234567a is an element of mymap.b is not an element of mymap.c is an element of mymap.d is not an element of mymap.e is not an element of mymap.f is an element of mymap.g is not an element of mymap. map::lower_bound将迭代器返回到下限 返回指向容器中第一个元素的迭代器，该元素的键不会在k之前出现（即，它是等价的或者在其后）。 该函数使用其内部比较对象（key_comp）来确定这一点，将迭代器返回到key_comp（element_key，k）将返回false的第一个元素。 如果map类用默认的比较类型（less）实例化，则函数返回一个迭代器到第一个元素，其键不小于k。 一个类似的成员函数upper_bound具有相同的行为lower_bound，除非映射包含一个key值等于k的元素：在这种情况下，lower_bound返回指向该元素的迭代器，而upper_bound返回指向下一个元素的迭代器。 12 iterator lower_bound (const key_type&amp; k);const_iterator lower_bound (const key_type&amp; k) const; Example 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator itlow,itup; mymap['a']=20; mymap['b']=40; mymap['c']=60; mymap['d']=80; mymap['e']=100; itlow=mymap.lower_bound ('b'); // itlow points to b itup=mymap.upper_bound ('d'); // itup points to e (not d!) mymap.erase(itlow,itup); // erases [itlow,itup) // print content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; " =&gt; " &lt;&lt; it-&gt;second &lt;&lt; '\n'; return 0;&#125; Output 12a =&gt; 20e =&gt; 100 map::upper_bound将迭代器返回到上限 返回一个指向容器中第一个元素的迭代器，它的关键字被认为是在k之后。 该函数使用其内部比较对象（key_comp）来确定这一点，将迭代器返回到key_comp（k，element_key）将返回true的第一个元素。 如果map类用默认的比较类型（less）实例化，则函数返回一个迭代器到第一个元素，其键大于k。 类似的成员函数lower_bound具有与upper_bound相同的行为，除了map包含一个元素，其键值等于k：在这种情况下，lower_bound返回指向该元素的迭代器，而upper_bound返回指向下一个元素的迭代器。 12 iterator upper_bound (const key_type&amp; k);const_iterator upper_bound (const key_type&amp; k) const; Example 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator itlow,itup; mymap['a']=20; mymap['b']=40; mymap['c']=60; mymap['d']=80; mymap['e']=100; itlow=mymap.lower_bound ('b'); // itlow points to b itup=mymap.upper_bound ('d'); // itup points to e (not d!) mymap.erase(itlow,itup); // erases [itlow,itup) // print content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; " =&gt; " &lt;&lt; it-&gt;second &lt;&lt; '\n'; return 0;&#125; Output 12a =&gt; 20e =&gt; 100 map::equal_range获取相同元素的范围 返回包含容器中所有具有与k等价的键的元素的范围边界。 由于地图容器中的元素具有唯一键，所以返回的范围最多只包含一个元素。 如果没有找到匹配，则返回的范围具有零的长度，与两个迭代器指向具有考虑去后一个密钥对所述第一元件ķ根据容器的内部比较对象（key_comp）。如果容器的比较对象返回false，则两个键被认为是等价的。 12pair&lt;const_iterator,const_iterator&gt; equal_range (const key_type&amp; k) const;pair&lt;iterator,iterator&gt; equal_range (const key_type&amp; k); Example 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['a']=10; mymap['b']=20; mymap['c']=30; std::pair&lt;std::map&lt;char,int&gt;::iterator,std::map&lt;char,int&gt;::iterator&gt; ret; ret = mymap.equal_range('b'); std::cout &lt;&lt; "lower bound points to: "; std::cout &lt;&lt; ret.first-&gt;first &lt;&lt; " =&gt; " &lt;&lt; ret.first-&gt;second &lt;&lt; '\n'; std::cout &lt;&lt; "upper bound points to: "; std::cout &lt;&lt; ret.second-&gt;first &lt;&lt; " =&gt; " &lt;&lt; ret.second-&gt;second &lt;&lt; '\n'; return 0;&#125; Output 12lower bound points to: &apos;b&apos; =&gt; 20upper bound points to: &apos;c&apos; =&gt; 30 multimap无序容器（Unordered Container）：unordered_set、unordered_multiset、unordered_map、unordered_multimap包括： unordered_set unordered_multiset unordered_map unordered_multimap 都是以哈希表实现的。 unordered_set、unodered_multiset结构： unordered_map、unodered_multimap结构： unordered_setunordered_multisetunordered_mapunordered_multimaptuple元组是一个能够容纳元素集合的对象。每个元素可以是不同的类型。 1template &lt;class... Types&gt; class tuple; Example 1234567891011121314151617181920212223242526#include &lt;iostream&gt; // std::cout#include &lt;tuple&gt; // std::tuple, std::get, std::tie, std::ignoreint main ()&#123; std::tuple&lt;int,char&gt; foo (10,'x'); auto bar = std::make_tuple ("test", 3.1, 14, 'y'); std::get&lt;2&gt;(bar) = 100; // access element int myint; char mychar; std::tie (myint, mychar) = foo; // unpack elements std::tie (std::ignore, std::ignore, myint, mychar) = bar; // unpack (with ignore) mychar = std::get&lt;3&gt;(bar); std::get&lt;0&gt;(foo) = std::get&lt;2&gt;(bar); std::get&lt;1&gt;(foo) = mychar; std::cout &lt;&lt; "foo contains: "; std::cout &lt;&lt; std::get&lt;0&gt;(foo) &lt;&lt; ' '; std::cout &lt;&lt; std::get&lt;1&gt;(foo) &lt;&lt; '\n'; return 0;&#125; Output 1foo contains: 100 y tuple::tuple构建一个 tuple（元组）对象。 这涉及单独构建其元素，初始化取决于调用的构造函数形式： （1）默认的构造函数 构建一个 元组对象的元素值初始化。 （2）复制/移动构造函数 该对象使用tpl的内容进行初始化 元组目的。tpl的相应元素被传递给每个元素的构造函数。 （3）隐式转换构造函数 同上。tpl中的所有类型都可以隐含地转换为构造中它们各自元素的类型元组 目的。 （4）初始化构造函数用elems中的相应元素初始化每个元素。elems的相应元素被传递给每个元素的构造函数。 （5）对转换构造函数 该对象有两个对应于pr.first和的元素pr.second。PR中的所有类型都应该隐含地转换为其中各自元素的类型元组 目的。 （6）分配器版本 和上面的版本一样，除了每个元素都是使用allocator alloc构造的。 1234567891011121314151617181920212223242526272829303132333435363738default (1) constexpr tuple();copy / move (2) tuple (const tuple&amp; tpl) = default;tuple (tuple&amp;&amp; tpl) = default;implicit conversion (3) template &lt;class... UTypes&gt; tuple (const tuple&lt;UTypes...&gt;&amp; tpl);template &lt;class... UTypes&gt; tuple (tuple&lt;UTypes...&gt;&amp;&amp; tpl);initialization (4) explicit tuple (const Types&amp;... elems);template &lt;class... UTypes&gt; explicit tuple (UTypes&amp;&amp;... elems);conversion from pair (5) template &lt;class U1, class U2&gt; tuple (const pair&lt;U1,U2&gt;&amp; pr);template &lt;class U1, class U2&gt; tuple (pair&lt;U1,U2&gt;&amp;&amp; pr);allocator (6) template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const tuple&amp; tpl);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, tuple&amp;&amp; tpl);template&lt;class Alloc,class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const tuple&lt;UTypes...&gt;&amp; tpl);template&lt;class Alloc, class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, tuple&lt;UTypes...&gt;&amp;&amp; tpl);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const Types&amp;... elems);template&lt;class Alloc, class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, UTypes&amp;&amp;... elems);template&lt;class Alloc, class U1, class U2&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const pair&lt;U1,U2&gt;&amp; pr);template&lt;class Alloc, class U1, class U2&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, pair&lt;U1,U2&gt;&amp;&amp; pr); Example 123456789101112131415161718#include &lt;iostream&gt; // std::cout#include &lt;utility&gt; // std::make_pair#include &lt;tuple&gt; // std::tuple, std::make_tuple, std::getint main ()&#123; std::tuple&lt;int,char&gt; first; // default std::tuple&lt;int,char&gt; second (first); // copy std::tuple&lt;int,char&gt; third (std::make_tuple(20,'b')); // move std::tuple&lt;long,char&gt; fourth (third); // implicit conversion std::tuple&lt;int,char&gt; fifth (10,'a'); // initialization std::tuple&lt;int,char&gt; sixth (std::make_pair(30,'c')); // from pair / move std::cout &lt;&lt; "sixth contains: " &lt;&lt; std::get&lt;0&gt;(sixth); std::cout &lt;&lt; " and " &lt;&lt; std::get&lt;1&gt;(sixth) &lt;&lt; '\n'; return 0;&#125; Output 1sixth contains: 30 and c pair这个类把一对值（values）结合在一起，这些值可能是不同的类型（T1 和 T2）。每个值可以被公有的成员变量first、second访问。 pair是tuple（元组）的一个特例。 pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。 应用： 可以将两个类型数据组合成一个如map&lt;key, value&gt; 当某个函数需要两个返回值时 1template &lt;class T1, class T2&gt; struct pair; pair::pair构建一个pair对象。 这涉及到单独构建它的两个组件对象，初始化依赖于调用的构造器形式： （1）默认的构造函数 构建一个 对对象的元素值初始化。 （2）复制/移动构造函数（和隐式转换） 该对象被初始化为pr的内容 对目的。pr的相应成员被传递给每个成员的构造函数。 （3）初始化构造函数 会员 第一是由一个和成员构建的第二与b。 （4）分段构造 构造成员 first 和 second 到位，传递元素first_args 作为参数的构造函数 first，和元素 second_args 到的构造函数 second 。 1234567891011121314default (1) constexpr pair();copy / move (2) template&lt;class U, class V&gt; pair (const pair&lt;U,V&gt;&amp; pr);template&lt;class U, class V&gt; pair (pair&lt;U,V&gt;&amp;&amp; pr);pair (const pair&amp; pr) = default;pair (pair&amp;&amp; pr) = default;initialization (3) pair (const first_type&amp; a, const second_type&amp; b);template&lt;class U, class V&gt; pair (U&amp;&amp; a, V&amp;&amp; b);piecewise (4) template &lt;class... Args1, class... Args2&gt; pair (piecewise_construct_t pwc, tuple&lt;Args1...&gt; first_args, tuple&lt;Args2...&gt; second_args); Example 12345678910111213141516171819#include &lt;utility&gt; // std::pair, std::make_pair#include &lt;string&gt; // std::string#include &lt;iostream&gt; // std::coutint main () &#123; std::pair &lt;std::string,double&gt; product1; // default constructor std::pair &lt;std::string,double&gt; product2 ("tomatoes",2.30); // value init std::pair &lt;std::string,double&gt; product3 (product2); // copy constructor product1 = std::make_pair(std::string("lightbulbs"),0.99); // using make_pair (move) product2.first = "shoes"; // the type of first is string product2.second = 39.90; // the type of second is double std::cout &lt;&lt; "The price of " &lt;&lt; product1.first &lt;&lt; " is $" &lt;&lt; product1.second &lt;&lt; '\n'; std::cout &lt;&lt; "The price of " &lt;&lt; product2.first &lt;&lt; " is $" &lt;&lt; product2.second &lt;&lt; '\n'; std::cout &lt;&lt; "The price of " &lt;&lt; product3.first &lt;&lt; " is $" &lt;&lt; product3.second &lt;&lt; '\n'; return 0;&#125; Output 123The price of lightbulbs is $0.99The price of shoes is $39.9The price of tomatoes is $2.3]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++容器及算法]]></title>
    <url>%2F2019%2F06%2F15%2FC%2B%2B%2F</url>
    <content type="text"><![CDATA[容器（containers）arrayarray 是固定大小的顺序容器，它们保存了一个以严格的线性顺序排列的特定数量的元素。 方法 含义 begin 返回指向数组容器中第一个元素的迭代器 end 返回指向数组容器中最后一个元素之后的理论元素的迭代器 rbegin 返回指向数组容器中最后一个元素的反向迭代器 rend 返回一个反向迭代器，指向数组中第一个元素之前的理论元素 cbegin 返回指向数组容器中第一个元素的常量迭代器（const_iterator） cend 返回指向数组容器中最后一个元素之后的理论元素的常量迭代器（const_iterator） crbegin 返回指向数组容器中最后一个元素的常量反向迭代器（const_reverse_iterator） crend 返回指向数组中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator） size 返回数组容器中元素的数量 max_size 返回数组容器可容纳的最大元素数 empty 返回一个布尔值，指示数组容器是否为空 operator[] 返回容器中第 n（参数）个位置的元素的引用 at 返回容器中第 n（参数）个位置的元素的引用 front 返回对容器中第一个元素的引用 back 返回对容器中最后一个元素的引用 data 返回指向容器中第一个元素的指针 fill 用 val（参数）填充数组所有元素 swap 通过 x（参数）的内容交换数组的内容 get（array） 形如 std::get&lt;0&gt;(myarray)；传入一个数组容器，返回指定位置元素的引用 relational operators (array) 形如 arrayA &gt; arrayB；依此比较数组每个元素的大小关系 ## vector vector 是表示可以改变大小的数组的序列容器。 方法 含义 vector 构造函数 ~vector 析构函数，销毁容器对象 operator= 将新内容分配给容器，替换其当前内容，并相应地修改其大小 begin 返回指向容器中第一个元素的迭代器 end 返回指向容器中最后一个元素之后的理论元素的迭代器 rbegin 返回指向容器中最后一个元素的反向迭代器 rend 返回一个反向迭代器，指向中第一个元素之前的理论元素 cbegin 返回指向容器中第一个元素的常量迭代器（const_iterator） cend 返回指向容器中最后一个元素之后的理论元素的常量迭代器（const_iterator） crbegin 返回指向容器中最后一个元素的常量反向迭代器（const_reverse_iterator） crend 返回指向容器中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator） size 返回容器中元素的数量 max_size 返回容器可容纳的最大元素数 resize 调整容器的大小，使其包含 n（参数）个元素 capacity 返回当前为 vector 分配的存储空间（容量）的大小 empty 返回 vector 是否为空 reserve 请求 vector 容量至少足以包含 n（参数）个元素 shrink_to_fit 要求容器减小其 capacity（容量）以适应其 size（元素数量） operator[] 返回容器中第 n（参数）个位置的元素的引用 at 返回容器中第 n（参数）个位置的元素的引用 front 返回对容器中第一个元素的引用 back 返回对容器中最后一个元素的引用 data 返回指向容器中第一个元素的指针 assign 将新内容分配给 vector，替换其当前内容，并相应地修改其 size push_back 在容器的最后一个元素之后添加一个新元素 pop_back 删除容器中的最后一个元素，有效地将容器 size 减少一个 insert 通过在指定位置的元素之前插入新元素来扩展该容器，通过插入元素的数量有效地增加容器大小 erase 从 vector 中删除单个元素（position）或一系列元素（[first，last)），这有效地减少了被去除的元素的数量，从而破坏了容器的大小 swap 通过 x（参数）的内容交换容器的内容，x 是另一个类型相同、size 可能不同的 vector 对象 clear 从 vector 中删除所有的元素（被销毁），留下 size 为 0 的容器 emplace 通过在 position（参数）位置处插入新元素 args（参数）来扩展容器 emplace_back 在 vector 的末尾插入一个新的元素，紧跟在当前的最后一个元素之后 get_allocator 返回与vector关联的构造器对象的副本 swap(vector) 容器 x（参数）的内容与容器 y（参数）的内容交换。两个容器对象都必须是相同的类型（相同的模板参数），尽管大小可能不同 relational operators (vector) 形如 vectorA &gt; vectorB；依此比较每个元素的大小关系 dequedeque（[‘dek]）（双端队列）是double-ended queue 的一个不规则缩写。deque是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩。 方法 含义 deque 构造函数 push_back 在当前的最后一个元素之后 ，在 deque 容器的末尾添加一个新元素 push_front 在 deque 容器的开始位置插入一个新的元素，位于当前的第一个元素之前 pop_back 删除 deque 容器中的最后一个元素，有效地将容器大小减少一个 pop_front 删除 deque 容器中的第一个元素，有效地减小其大小 emplace_front 在 deque 的开头插入一个新的元素，就在其当前的第一个元素之前 emplace_back 在 deque 的末尾插入一个新的元素，紧跟在当前的最后一个元素之后 forward_listforward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。 方法 含义 forward_list 返回指向容器中第一个元素之前的位置的迭代器 cbefore_begin 返回指向容器中第一个元素之前的位置的 const_iterator listlist，双向链表，是序列容器，允许在序列中的任何地方进行常数时间插入和擦除操作，并在两个方向上进行迭代。 stackstack 是一种容器适配器，用于在LIFO（后进先出）的操作，其中元素仅从容器的一端插入和提取。 queuequeue 是一种容器适配器，用于在FIFO（先入先出）的操作，其中元素插入到容器的一端并从另一端提取。 priority_queuesetset 是按照特定顺序存储唯一元素的容器。 multisetmapmap 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。 方法 含义 map 构造函数 begin 返回引用容器中第一个元素的迭代器 key_comp 返回容器用于比较键的比较对象的副本 value_comp 返回可用于比较两个元素的比较对象，以获取第一个元素的键是否在第二个元素之前 find 在容器中搜索具有等于 k（参数）的键的元素，如果找到则返回一个迭代器，否则返回 map::end 的迭代器 count 在容器中搜索具有等于 k（参数）的键的元素，并返回匹配的数量 lower_bound 返回一个非递减序列 [first, last)（参数）中的第一个大于等于值 val（参数）的位置的迭代器 upper_bound 返回一个非递减序列 [first, last)（参数）中第一个大于 val（参数）的位置的迭代器 equal_range 获取相同元素的范围，返回包含容器中所有具有与 k（参数）等价的键的元素的范围边界（pair&lt; map&lt;char,int&gt;::iterator, map&lt;char,int&gt;::iterator &gt;） multimapunordered_setunordered_multisetunordered_mapunordered_multimaptuple元组是一个能够容纳元素集合的对象。每个元素可以是不同的类型。 pair这个类把一对值（values）结合在一起，这些值可能是不同的类型（T1 和 T2）。每个值可以被公有的成员变量first、second访问。 算法（algorithms）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136// 简单查找算法，要求输入迭代器（input iterator）find(beg, end, val); // 返回一个迭代器，指向输入序列中第一个等于 val 的元素，未找到返回 endfind_if(beg, end, unaryPred); // 返回一个迭代器，指向第一个满足 unaryPred 的元素，未找到返回 endfind_if_not(beg, end, unaryPred); // 返回一个迭代器，指向第一个令 unaryPred 为 false 的元素，未找到返回 endcount(beg, end, val); // 返回一个计数器，指出 val 出现了多少次count_if(beg, end, unaryPred); // 统计有多少个元素满足 unaryPredall_of(beg, end, unaryPred); // 返回一个 bool 值，判断是否所有元素都满足 unaryPredany_of(beg, end, unaryPred); // 返回一个 bool 值，判断是否任意（存在）一个元素满足 unaryPrednone_of(beg, end, unaryPred); // 返回一个 bool 值，判断是否所有元素都不满足 unaryPred// 查找重复值的算法，传入向前迭代器（forward iterator）adjacent_find(beg, end); // 返回指向第一对相邻重复元素的迭代器，无相邻元素则返回 endadjacent_find(beg, end, binaryPred); // 返回指向第一对相邻重复元素的迭代器，无相邻元素则返回 endsearch_n(beg, end, count, val); // 返回一个迭代器，从此位置开始有 count 个相等元素，不存在则返回 endsearch_n(beg, end, count, val, binaryPred); // 返回一个迭代器，从此位置开始有 count 个相等元素，不存在则返回 end// 查找子序列算法，除 find_first_of（前两个输入迭代器，后两个前向迭代器） 外，都要求两个前向迭代器search(beg1, end1, beg2, end2); // 返回第二个输入范围（子序列）在爹一个输入范围中第一次出现的位置，未找到则返回 end1search(beg1, end1, beg2, end2, binaryPred); // 返回第二个输入范围（子序列）在爹一个输入范围中第一次出现的位置，未找到则返回 end1find_first_of(beg1, end1, beg2, end2); // 返回一个迭代器，指向第二个输入范围中任意元素在第一个范围中首次出现的位置，未找到则返回end1find_first_of(beg1, end1, beg2, end2, binaryPred); // 返回一个迭代器，指向第二个输入范围中任意元素在第一个范围中首次出现的位置，未找到则返回end1find_end(beg1, end1, beg2, end2); // 类似 search，但返回的最后一次出现的位置。如果第二个输入范围为空，或者在第一个输入范围为空，或者在第一个输入范围中未找到它，则返回 end1find_end(beg1, end1, beg2, end2, binaryPred); // 类似 search，但返回的最后一次出现的位置。如果第二个输入范围为空，或者在第一个输入范围为空，或者在第一个输入范围中未找到它，则返回 end1// 其他只读算法，传入输入迭代器for_each(beg, end, unaryOp); // 对输入序列中的每个元素应用可调用对象 unaryOp，unaryOp 的返回值被忽略mismatch(beg1, end1, beg2); // 比较两个序列中的元素。返回一个迭代器的 pair，表示两个序列中第一个不匹配的元素mismatch(beg1, end1, beg2, binaryPred); // 比较两个序列中的元素。返回一个迭代器的 pair，表示两个序列中第一个不匹配的元素equal(beg1, end1, beg2); // 比较每个元素，确定两个序列是否相等。equal(beg1, end1, beg2, binaryPred); // 比较每个元素，确定两个序列是否相等。// 二分搜索算法，传入前向迭代器或随机访问迭代器（random-access iterator），要求序列中的元素已经是有序的。通过小于运算符（&lt;）或 comp 比较操作实现比较。lower_bound(beg, end, val); // 返回一个非递减序列 [beg, end) 中的第一个大于等于值 val 的位置的迭代器，不存在则返回 endlower_bound(beg, end, val, comp); // 返回一个非递减序列 [beg, end) 中的第一个大于等于值 val 的位置的迭代器，不存在则返回 endupper_bound(beg, end, val); // 返回一个非递减序列 [beg, end) 中第一个大于 val 的位置的迭代器，不存在则返回 endupper_bound(beg, end, val, comp); // 返回一个非递减序列 [beg, end) 中第一个大于 val 的位置的迭代器，不存在则返回 endequal_range(beg, end, val); // 返回一个 pair，其 first 成员是 lower_bound 返回的迭代器，其 second 成员是 upper_bound 返回的迭代器binary_search(beg, end, val); // 返回一个 bool 值，指出序列中是否包含等于 val 的元素。对于两个值 x 和 y，当 x 不小于 y 且 y 也不小于 x 时，认为它们相等。// 只写不读算法，要求输出迭代器（output iterator）fill(beg, end, val); // 将 val 赋予每个元素，返回 voidfill_n(beg, cnt, val); // 将 val 赋予 cnt 个元素，返回指向写入到输出序列最有一个元素之后位置的迭代器genetate(beg, end, Gen); // 每次调用 Gen() 生成不同的值赋予每个序列，返回 voidgenetate_n(beg, cnt, Gen); // 每次调用 Gen() 生成不同的值赋予 cnt 个序列，返回指向写入到输出序列最有一个元素之后位置的迭代器// 使用输入迭代器的写算法，读取一个输入序列，将值写入到一个输出序列（dest）中copy(beg, end, dest); // 从输入范围将元素拷贝所有元素到 dest 指定定的目的序列copy_if(beg, end, dest, unaryPred); // 从输入范围将元素拷贝满足 unaryPred 的元素到 dest 指定定的目的序列copy_n(beg, n, dest); // 从输入范围将元素拷贝前 n 个元素到 dest 指定定的目的序列move(beg, end, dest); // 对输入序列中的每个元素调用 std::move，将其移动到迭代器 dest 开始始的序列中transform(beg, end, dest, unaryOp); // 调用给定操作（一元操作），并将结果写到dest中transform(beg, end, beg2, dest, binaryOp); // 调用给定操作（二元操作），并将结果写到dest中replace_copy(beg, end, dest, old_val, new_val); // 将每个元素拷贝到 dest，将等于 old_val 的的元素替换为 new_valreplace_copy_if(beg, end, dest, unaryPred, new_val); // 将每个元素拷贝到 dest，将满足 unaryPred 的的元素替换为 new_valmerge(beg1, end1, beg2, end2, dest); // 两个输入序列必须都是有序的，用 &lt; 运算符将合并后的序列写入到 dest 中merge(beg1, end1, beg2, end2, dest, comp); // 两个输入序列必须都是有序的，使用给定的比较操作（comp）将合并后的序列写入到 dest 中// 使用前向迭代器的写算法，要求前向迭代器iter_swap(iter1, iter2); // 交换 iter1 和 iter2 所表示的元素，返回 voidswap_ranges(beg1, end1, beg2); // 将输入范围中所有元素与 beg2 开始的第二个序列中所有元素进行交换。返回递增后的的 beg2，指向最后一个交换元素之后的位置。replace(beg, end, old_val, new_val); // 用 new_val 替换等于 old_val 的每个匹配元素replace_if(beg, end, unaryPred, new_val); // 用 new_val 替换满足 unaryPred 的每个匹配元素// 使用双向迭代器的写算法，要求双向选代器（bidirectional iterator）copy_backward(beg, end, dest); // 从输入范围中拷贝元素到指定目的位置。如果范围为空,则返回值为 dest；否则，返回值表示从 *beg 中拷贝或移动的元素。move_backward(beg, end, dest); // 从输入范围中移动元素到指定目的位置。如果范围为空,则返回值为 dest；否则,返回值表示从 *beg 中拷贝或移动的元素。inplace_merge(beg, mid, end); // 将同一个序列中的两个有序子序列合并为单一的有序序列。beg 到 mid 间的子序列和 mid 到 end 间的子序列被合并，并被写入到原序列中。使用 &lt; 比较元素。inplace_merge(beg, mid, end, comp); // 将同一个序列中的两个有序子序列合并为单一的有序序列。beg 到 mid 间的子序列和 mid 到 end 间的子序列被合并，并被写入到原序列中。使用给定的 comp 操作。// 划分算法，要求双向选代器（bidirectional iterator）is_partitioned(beg, end, unaryPred); // 如果所有满足谓词 unaryPred 的元素都在不满足 unarypred 的元素之前，则返回 true。若序列为空，也返回 truepartition_copy(beg, end, dest1, dest2, unaryPred); // 将满足 unaryPred 的元素拷贝到到 dest1，并将不满足 unaryPred 的元素拷贝到到 dest2。返回一个迭代器 pair，其 first 成员表示拷贝到 dest1 的的元素的末尾，second 表示拷贝到 dest2 的元素的末尾。partitioned_point(beg, end, unaryPred); // 输入序列必须是已经用 unaryPred 划分过的。返回满足 unaryPred 的范围的尾后迭代器。如果返回的迭代器不是 end，则它指向的元素及其后的元素必须都不满足 unaryPredstable_partition(beg, end, unaryPred); // 使用 unaryPred 划分输入序列。满足 unaryPred 的元素放置在序列开始，不满足的元素放在序列尾部。返回一个迭代器，指向最后一个满足 unaryPred 的元素之后的位置如果所有元素都不满足 unaryPred，则返回 begpartition(beg, end, unaryPred); // 使用 unaryPred 划分输入序列。满足 unaryPred 的元素放置在序列开始，不满足的元素放在序列尾部。返回一个迭代器，指向最后一个满足 unaryPred 的元素之后的位置如果所有元素都不满足 unaryPred，则返回 beg// 排序算法，要求随机访问迭代器（random-access iterator）sort(beg, end); // 排序整个范围stable_sort(beg, end); // 排序整个范围（稳定排序）sort(beg, end, comp); // 排序整个范围stable_sort(beg, end, comp); // 排序整个范围（稳定排序）is_sorted(beg, end); // 返回一个 bool 值，指出整个输入序列是否有序is_sorted(beg, end, comp); // 返回一个 bool 值，指出整个输入序列是否有序is_sorted_until(beg, end); // 在输入序列中査找最长初始有序子序列，并返回子序列的尾后迭代器is_sorted_until(beg, end, comp); // 在输入序列中査找最长初始有序子序列，并返回子序列的尾后迭代器partial_sort(beg, mid, end); // 排序 mid-beg 个元素。即，如果 mid-beg 等于 42，则此函数将值最小的 42 个元素有序放在序列前 42 个位置partial_sort(beg, mid, end, comp); // 排序 mid-beg 个元素。即，如果 mid-beg 等于 42，则此函数将值最小的 42 个元素有序放在序列前 42 个位置partial_sort_copy(beg, end, destBeg, destEnd); // 排序输入范围中的元素，并将足够多的已排序元素放到 destBeg 和 destEnd 所指示的序列中partial_sort_copy(beg, end, destBeg, destEnd, comp); // 排序输入范围中的元素，并将足够多的已排序元素放到 destBeg 和 destEnd 所指示的序列中nth_element(beg, nth, end); // nth 是一个迭代器，指向输入序列中第 n 大的元素。nth 之前的元素都小于等于它，而之后的元素都大于等于它nth_element(beg, nth, end, comp); // nth 是一个迭代器，指向输入序列中第 n 大的元素。nth 之前的元素都小于等于它，而之后的元素都大于等于它// 使用前向迭代器的重排算法。普通版本在输入序列自身内部重拍元素，_copy 版本完成重拍后写入到指定目的序列中，而不改变输入序列remove(beg, end, val); // 通过用保留的元素覆盖要删除的元素实现删除 ==val 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器remove_if(beg, end, unaryPred); // 通过用保留的元素覆盖要删除的元素实现删除满足 unaryPred 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器remove_copy(beg, end, dest, val); // 通过用保留的元素覆盖要删除的元素实现删除 ==val 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器remove_copy_if(beg, end, dest, unaryPred); // 通过用保留的元素覆盖要删除的元素实现删除满足 unaryPred 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器unique(beg, end); // 通过对覆盖相邻的重复元素（用 == 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置unique (beg, end, binaryPred); // 通过对覆盖相邻的重复元素（用 binaryPred 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置unique_copy(beg, end, dest); // 通过对覆盖相邻的重复元素（用 == 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置unique_copy_if(beg, end, dest, binaryPred); // 通过对覆盖相邻的重复元素（用 binaryPred 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置rotate(beg, mid, end); // 围绕 mid 指向的元素进行元素转动。元素 mid 成为为首元素，随后是 mid+1 到到 end 之前的元素，再接着是 beg 到 mid 之前的元素。返回一个迭代器，指向原来在 beg 位置的元素rotate_copy(beg, mid, end, dest); // 围绕 mid 指向的元素进行元素转动。元素 mid 成为为首元素，随后是 mid+1 到到 end 之前的元素，再接着是 beg 到 mid 之前的元素。返回一个迭代器，指向原来在 beg 位置的元素// 使用双向迭代器的重排算法reverse(beg, end); // 翻转序列中的元素，返回 voidreverse_copy(beg, end, dest);; // 翻转序列中的元素，返回一个迭代器，指向拷贝到目的序列的元素的尾后位置// 使用随机访问迭代器的重排算法random_shuffle(beg, end); // 混洗输入序列中的元素，返回 voidrandom_shuffle(beg, end, rand); // 混洗输入序列中的元素，rand 接受一个正整数的随机对象，返回 voidshuffle(beg, end, Uniform_rand); // 混洗输入序列中的元素，Uniform_rand 必须满足均匀分布随机数生成器的要求，返回 void// 最小值和最大值，使用 &lt; 运算符或给定的比较操作 comp 进行比较min(val1, va12); // 返回 val1 和 val2 中的最小值，两个实参的类型必须完全一致。参数和返回类型都是 const的引引用，意味着对象不会被拷贝。下略min(val1, val2, comp);min(init_list);min(init_list, comp);max(val1, val2);max(val1, val2, comp);max(init_list);max(init_list, comp);minmax(val1, val2); // 返回一个 pair，其 first 成员为提供的值中的较小者，second 成员为较大者。下略minmax(vall, val2, comp);minmax(init_list);minmax(init_list, comp);min_element(beg, end); // 返回指向输入序列中最小元素的迭代器min_element(beg, end, comp); // 返回指向输入序列中最小元素的迭代器max_element(beg, end); // 返回指向输入序列中最大元素的迭代器max_element(beg, end, comp); // 返回指向输入序列中最大元素的迭代器minmax_element(beg, end); // 返回一个 pair，其中 first 成员为最小元素，second 成员为最大元素minmax_element(beg, end, comp); // 返回一个 pair，其中 first 成员为最小元素，second 成员为最大元素// 字典序比较，根据第一对不相等的元素的相对大小来返回结果。如果第一个序列在字典序中小于第二个序列，则返回 true。否则，返回 fa1se。如果个序列比另一个短，且所有元素都与较长序列的对应元素相等，则较短序列在字典序中更小。如果序列长度相等，且对应元素都相等，则在字典序中任何一个都不大于另外一个。lexicographical_compare(beg1, end1, beg2, end2);lexicographical_compare(beg1, end1, beg2, end2, comp);]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVPR(Latest paper learning)]]></title>
    <url>%2F2019%2F06%2F15%2FCVPR(Latest%20paper%20learning)%2F</url>
    <content type="text"><![CDATA[CVPR关于目标检测最新论文(2D目标检测、3D目标检测、视频目标检测).2019-07-24 Update 1 paper A Survey of Deep Learning-based Object Detection intro：From Fast R-CNN to NAS-FPN arXiv：https://arxiv.org/abs/1907.09408 2019-05-17 Update 1 paper Object Detection in 20 Years: A Survey intro：This work has been submitted to the IEEE TPAMI for possible publication arXiv：https://arxiv.org/abs/1905.05055 2019-04-05 Update 1 paper Comparison Network for One-Shot Conditional Object Detection arXiv: https://arxiv.org/abs/1904.02317 2019-03-05 Update 1 paper Feature Selective Anchor-Free Module for Single-Shot Object Detection intro: CVPR 2019 arXiv: https://arxiv.org/abs/1903.00621 2019-02-15 Update 3 detection toolbox Detectron(FAIR): Detectron is Facebook AI Research’s software system that implements state-of-the-art object detection algorithms, including Mask R-CNN. It is written in Python and powered by the Caffe2 deep learning framework. maskrcnn-benchmark(FAIR): Fast, modular reference implementation of Instance Segmentation and Object Detection algorithms in PyTorch. mmdetection(SenseTime&amp;CUHK): mmdetection is an open source object detection toolbox based on PyTorch. It is a part of the open-mmlab project developed by Multimedia Laboratory, CUHK. 2019-01-25 Update 5 papers 3D Backbone Network for 3D Object Detection arXiv: https://arxiv.org/abs/1901.08373 Object Detection based on Region Decomposition and Assembly intro: AAAI 2019 arXiv: https://arxiv.org/abs/1901.08225 Bottom-up Object Detection by Grouping Extreme and Center Points intro: one stage 43.2% on COCO test-dev arXiv: https://arxiv.org/abs/1901.08043 github: https://github.com/xingyizhou/ExtremeNet ORSIm Detector: A Novel Object Detection Framework in Optical Remote Sensing Imagery Using Spatial-Frequency Channel Features intro: IEEE TRANSACTIONS ON GEOSCIENCE AND REMOTE SENSING arXiv: https://arxiv.org/abs/1901.07925 Consistent Optimization for Single-Shot Object Detection intro: improves RetinaNet from 39.1 AP to 40.1 AP on COCO datase arXiv: https://arxiv.org/abs/1901.06563 2019-01-15 Update 1 paper Learning Pairwise Relationship for Multi-object Detection in Crowded Scenes arXiv: https://arxiv.org/abs/1901.03796 2019-01-14 Update 1 paper RetinaMask: Learning to predict masks improves state-of-the-art single-shot detection for free arXiv: https://arxiv.org/abs/1901.03353 github: https://github.com/chengyangfu/retinamask 2019-01-12 Update 1 paper Region Proposal by Guided Anchoring intro: CUHK - SenseTime Joint Lab arXiv: https://arxiv.org/abs/1901.03278 2019-01-08 Update 1 paper Scale-Aware Trident Networks for Object Detection intro: mAP of 48.4 on the COCO dataset arXiv: https://arxiv.org/abs/1901.01892 2019-01-04 Update 1 paper Large-Scale Object Detection of Images from Network Cameras in Variable Ambient Lighting Conditions arXiv: https://arxiv.org/abs/1812.11901 2018-12-13 Update 1 paper Strong-Weak Distribution Alignment for Adaptive Object Detection arXiv: https://arxiv.org/abs/1812.04798 2018-12-05 Update 3 papers AutoFocus: Efficient Multi-Scale Inference intro: AutoFocus obtains an mAP of 47.9% (68.3% at 50% overlap) on the COCO test-dev set while processing 6.4 images per second on a Titan X (Pascal) GPU arXiv: https://arxiv.org/abs/1812.01600 NOTE-RCNN: NOise Tolerant Ensemble RCNN for Semi-Supervised Object Detection intro: Google Could arXiv: https://arxiv.org/abs/1812.00124 SPLAT: Semantic Pixel-Level Adaptation Transforms for Detection intro: UC Berkeley arXiv: https://arxiv.org/abs/1812.00929 2018-12-04 Update 10 papers Grid R-CNN intro: SenseTime arXiv: https://arxiv.org/abs/1811.12030 Deformable ConvNets v2: More Deformable, Better Results intro: Microsoft Research Asia arXiv: https://arxiv.org/abs/1811.11168 Anchor Box Optimization for Object Detection intro: Microsoft Research arXiv: https://arxiv.org/abs/1812.00469 Efficient Coarse-to-Fine Non-Local Module for the Detection of Small Objects intro: https://arxiv.org/abs/1811.12152 NOTE-RCNN: NOise Tolerant Ensemble RCNN for Semi-Supervised Object Detection arXiv: https://arxiv.org/abs/1812.00124 Learning RoI Transformer for Detecting Oriented Objects in Aerial Images arXiv: https://arxiv.org/abs/1812.00155 Integrated Object Detection and Tracking with Tracklet-Conditioned Detection intro: Microsoft Research Asia arXiv: https://arxiv.org/abs/1811.11167 Deep Regionlets: Blended Representation and Deep Learning for Generic Object Detection arXiv: https://arxiv.org/abs/1811.11318 Gradient Harmonized Single-stage Detector intro: AAAI 2019 arXiv: https://arxiv.org/abs/1811.05181 CFENet: Object Detection with Comprehensive Feature Enhancement Module intro: ACCV 2018 github: https://github.com/qijiezhao/CFENet 2018-11-19 DeRPN: Taking a further step toward more general object detection intro: AAAI 2019 arXiv: https://arxiv.org/abs/1811.06700 github: https://github.com/HCIILAB/DeRPN 2018-11-14 M2Det: A Single-Shot Object Detector based on Multi-Level Feature Pyramid Network intro: AAAI 2019 arXiv: https://arxiv.org/abs/1811.04533 github: https://github.com/qijiezhao/M2Det 2018-10-31 Hybrid Knowledge Routed Modules for Large-scale Object Detection intro: Sun Yat-Sen University &amp; Huawei Noah’s Ark Lab arXiv: https://arxiv.org/abs/1810.12681 github: https://github.com/chanyn/HKRM 2018-10-08 Weakly Supervised Object Detection in Artworks intro: ECCV 2018 Workshop Computer Vision for Art Analysis arXiv: https://arxiv.org/abs/1810.02569 Datasets: https://wsoda.telecom-paristech.fr/downloads/dataset/IconArt_v1.zip Cross-Domain Weakly-Supervised Object Detection through Progressive Domain Adaptation intro: CVPR 2018 arXiv: https://arxiv.org/abs/1803.11365 homepage: https://naoto0804.github.io/cross_domain_detection/ paper: http://openaccess.thecvf.com/content_cvpr_2018/html/Inoue_Cross-Domain_Weakly-Supervised_Object_CVPR_2018_paper.html github: https://github.com/naoto0804/cross-domain-detection 2018-09-26 Object Detection from Scratch with Deep Supervision intro: This is an extended version of DSOD arXiv: https://arxiv.org/abs/1809.09294 2018-09-25 《Softer-NMS: Rethinking Bounding Box Regression for Accurate Object Detection》 intro: CMU &amp; Face++ arXiv: https://arxiv.org/abs/1809.08545 github: https://github.com/yihui-he/softer-NMS 2018-09-21 《Receptive Field Block Net for Accurate and Fast Object Detection》 intro: ECCV 2018 arXiv: https://arxiv.org/abs/1711.07767 github: https://github.com/ruinmessi/RFBNet 2018-09-11 《Recent Advances in Object Detection in the Age of Deep Convolutional Neural Networks》 intro: awesome arXiv: https://arxiv.org/abs/1809.03193 2018-09-10 《Deep Learning for Generic Object Detection: A Survey》 intro: Submitted to IJCV 2018 arXiv: https://arxiv.org/abs/1809.02165 2018-08-27 Deep Feature Pyramid Reconfiguration for Object Detection intro: ECCV 2018 arXiv: https://arxiv.org/abs/1808.07993 2018-08-17 R3-Net: A Deep Network for Multi-oriented Vehicle Detection in Aerial Images and Videos arxiv: https://arxiv.org/abs/1808.05560 youtube: https://youtu.be/xCYD-tYudN0 2018-08-14 《Unsupervised Hard Example Mining from Videos for Improved Object Detection》 intro: ECCV 2018 arXiv: https://arxiv.org/abs/1808.04285 2018-08-10 CornerNet: Detecting Objects as Paired Keypoints intro: ECCV 2018 arXiv: https://arxiv.org/abs/1808.01244 2018-07-30 Acquisition of Localization Confidence for Accurate Object Detection intro: ECCV 2018 arXiv: https://arxiv.org/abs/1807.11590 github: https://github.com/vacancy/PreciseRoIPooling]]></content>
      <categories>
        <category>Computer-Vision</category>
      </categories>
      <tags>
        <tag>CV</tag>
        <tag>Object-Detection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Non-Maximum-Suppression]]></title>
    <url>%2F2019%2F05%2F25%2FNMS%2F</url>
    <content type="text"><![CDATA[Non-Maximum-Suppression非极大值抑制（Non-Maximum-Suppression，NMS）是抑制非极大值的元素，可以理解为局部最大搜索。NMS算法在计算机视觉中有广泛应用，特别是目标检测领域。本文将以目标检测举例，讨论NMS算法的实现过程。 TODO: 记录关于NMS的相关实现以及SoftNMS等目标检测后处理方法 参考 《Efficient Non-Maximum Suppression》 非极大值抑制（Non-Maximum Suppression，NMS） NMS——非极大值抑制 非极大抑制（Non-Maximum Suppression） 吴恩达（Non-max Suppression）视频 Non-Maximum Suppression for Object Detection in Python 非极大值抑制(Non-Maximum Suppression) nonMaximumSuppression：非极大值抑制，包含了matlab，c,，c++，3种实现的代码 Non-Maximum-Suppression：C++实现 deep-learning-tools：Python实现]]></content>
      <categories>
        <category>Computer-Vision</category>
      </categories>
      <tags>
        <tag>Object-Detection</tag>
        <tag>Computer-Vision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reinforcement Learning Tutorila]]></title>
    <url>%2F2019%2F04%2F15%2FReinforcement-learning%2F</url>
    <content type="text"><![CDATA[Reinforcement Learning Methods and Tutorials转自莫烦大佬强化学习教程，方便自己后期知识巩固。感谢！教程链接 liufuyang’s notebook filesTable of Contents Tutorials Simple entry example Q-learning Sarsa Sarsa(lambda) Deep Q Network (DQN) Using OpenAI Gym Double DQN DQN with Prioitized Experience Replay Dueling DQN Policy Gradients Actor-Critic Deep Deterministic Policy Gradient (DDPG) A3C Dyna-Q Proximal Policy Optimization (PPO) Curiosity Model, Random Network Distillation (RND) Some of my experiments 2D Car Robot arm BipedalWalker LunarLander Some RL NetworksDeep Q Network Double DQN Dueling DQN Actor Critic Deep Deterministic Policy Gradient A3C Proximal Policy Optimization (PPO) Curiosity Model]]></content>
      <categories>
        <category>Deep-Learning</category>
      </categories>
      <tags>
        <tag>Data Structures and Algorithms</tag>
        <tag>Deep-Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow Tutorials]]></title>
    <url>%2F2019%2F03%2F16%2FTensorflow%20Tutorila%2F</url>
    <content type="text"><![CDATA[Tensorflow Tutorials转自莫烦大佬Tensorflow学习教程，方便自己后期知识巩固。感谢！教程链接 liufuyang’s notebook files Tensorflow basic Session Placeholder Variable Activation Build your first network Regression Classification Save and reload Optimizers Tensorboard Dataset Advanced neural network CNN RNN-Classification RNN-Regression AutoEncoder DQN Reinforcement Learning GAN (Generative Adversarial Nets) / Conditional GAN Transfer Learning Others (WIP) Dropout Batch Normalization Visualize Gradient Descent Distributed training Regression Classification CNN RNN Autoencoder GAN (Generative Adversarial Nets) Dropout Batch Normalization Visualize Gradient Descent]]></content>
      <categories>
        <category>Deep-Learning</category>
      </categories>
      <tags>
        <tag>Data Structures and Algorithms</tag>
        <tag>Deep-Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pytorch Tutorila]]></title>
    <url>%2F2019%2F03%2F15%2FPytorch%20Tutorila%2F</url>
    <content type="text"><![CDATA[pyTorch Tutorials转自莫烦大佬Pytorch学习教程，方便自己后期知识巩固。感谢！教程链接 liufuyang’s notebook files pyTorch basic torch and numpy Variable Activation Build your first network Regression Classification An easy way Save and reload Train on batch Optimizers Advanced neural network CNN RNN-Classification RNN-Regression AutoEncoder DQN Reinforcement Learning A3C Reinforcement Learning GAN (Generative Adversarial Nets) / Conditional GAN Others (WIP) Why torch dynamic Train on GPU Dropout Batch Normalization For Chinese speakers: All methods mentioned below have their video and text tutorial in Chinese.Visit 莫烦 Python for more.You can watch my Youtube channel as well. Regression Classification CNN RNN Autoencoder GAN (Generative Adversarial Nets) Dropout Batch Normalization]]></content>
      <categories>
        <category>Deep-Learning</category>
      </categories>
      <tags>
        <tag>Data Structures and Algorithms</tag>
        <tag>Deep-Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理知识点——(1)]]></title>
    <url>%2F2018%2F07%2F30%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94-1%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Computer-Vision</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux相关总结]]></title>
    <url>%2F2018%2F05%2F13%2FLinux%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Linux工具 Linux下还是有很多超棒的开发工具的。 在Linux日常使用中，最常用的命令自然是sudo, ls, cp, mv, cat等，但作为后台开发者，上述命令远远不够。从我的理解来看，合格的C/C++开发者至少需要从开发及调试工具、文件处理、性能分析、网络工具四个方面针对性使用一些开发工具。这里我罗列了一些，大部分都是开发中经常需要使用的命令，有些功能比较简单的命令我会给出一些基本用法，有些本身自带体系（比如vim, gdb等）的命令只能附上链接了。 开发及调试工具介绍了从“编辑 -&gt; 编译 -&gt; 分析目标文件 -&gt; 追踪调用过程”的全套命令，文件处理部分介绍了查找、统计、替换等基本文本操作命令，性能分析介绍了查看进程信息、CPU负载、I/O负载、内存使用情况等基本命令，网络工具介绍了可以查看“链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层”信息的工具。除此以外，其他命令中也列出了开发者经常会用到的一些命令，基本可以满足日常开发需要。 目录 Chapter 1 Chapter 2 Chapter 3 Chapter 4 Chapter 5 开发及调试 文件处理 性能分析 网络工具 其他 开发及调试 编辑器：vim 编译器：gcc/g++ 调试工具：gdb 查看依赖库：ldd 二进制文件分析：objdump ELF文件格式分析：readelf 跟踪进程中系统调用：strace 跟踪进程栈：pstack 进程内存映射：pmap 文件处理 文件查找：find 文本搜索：grep 排序：sort 转换：tr 按列切分文本：cut 按列拼接文本：paste 统计行和字符：wc 文本替换：sed 数据流处理：awk 性能分析 进程查询：ps 进程监控：top 打开文件查询：lsof 内存使用量：free 监控性能指标：sar 网络工具 网卡配置：ifconfig 查看当前网络连接：netstat 查看路由表：route 检查网络连通性：ping 转发路径：traceroute 网络Debug分析：nc 命令行抓包：tcpdump 域名解析工具：dig 网络请求：curl 其他 终止进程：kill 修改文件权限：chmod 创建链接：ln 显示文件尾：tail 版本控制：git 设置别名：alias 内容开发及调试 开发工具大部分都提供了完善的功能，所以这里不一一列举用法。从技术层面来说，调试工具比开发工具更考验一个人的工程能力。 编辑器：vim 服务器端开发必知必会，功能强大，这里不一一列举，但基本的打开文件、保存退出要会。 详见 编译器：gcc/g++ C/C++编译器，必知必会，除此以外需要了解预处理-&gt; 编译 -&gt; 汇编 -&gt; 链接等一系列流程。 详见 调试工具：gdb 服务器端调试必备。 详见 查看依赖库：ldd 程序依赖库查询12345# ldd后接可执行文件# 第一列为程序依赖什么库，第二列为系统提供的与程序需要的库所对应的库，第三列为库加载的开始地址# 前两列可以判断系统提供的库和需要的库是否匹配，第三列可以知道当前库在进程地址空间中对应的开始位置ldd a.out 二进制文件分析：objdump 反汇编，需要理解汇编语言 详见 ELF文件格式分析：readelf 可以得到ELF文件各段内容，分析链接、符号表等需要用到 详见 跟踪进程中系统调用：strace 详见 跟踪进程栈：pstack 详见 进程内存映射：pmap 显示进程内存映射1234567891011# -x显示扩展信息，后接进程pid# Address: 内存开始地址# 显示信息： Kbytes: 占用内存的字节数 RSS: 保留内存的字节数 Dirty: 脏页的字节数（包括共享和私有的） Mode: 内存的权限：read、write、execute、shared、private Mapping: 占用内存的文件、或[anon]（分配的内存）、或[stack]（堆栈） Device: 设备名 (major:minor)pmap -x 12345 文件处理 Everything is file. 在Linux环境下，对文本处理相当频繁，所以有些命令的参数还是需要记忆的。另外其他很多命令的输出信息都需要通过文件处理命令来筛选有用信息。 文件查找：find 按名查找： 查找具体文件（一般方式） 1find . -name *.cpp 查找具体文件（正则方式） 123# -regex为正则查找，-iregex为忽略大小写的正则查找 find -regex ".*.cpp$" 定制查找： 按类型查找 123# f(file)为文件，d(dictionary)为目录，l(link)为链接find . -type f 按时间查找 1234# atime为访问时间，x天内加参数"-atime -x"，超过x天加"-atime -x"# mtime为修改时间find . -type f -atime -7 按大小查找 123# -size后接文件大小，单位可以为k(kb)，m(MB)，g(GB)find . -type f -size -1k 按权限查询 123# -perm后接权限find . -type -perm 644 文本搜索：grep 模式匹配 123# 匹配test.cpp文件中含有"iostream"串的内容grep "iostream" test.cpp 多个模式匹配 123# 匹配test.cpp文件中含有"iostream"和"using"串的内容grep -e "using" -e "iostream" test.cpp 输出信息 123# -n为打印匹配的行号；-i搜索时忽略大小写；-c统计包含文本次数grep -n "iostream" test.cpp 排序：sort 文件内容行排序123456# 排序在内存进行，不改变文件# -n(number)表示按数字排序，-d(dictionary)表示按字典序# -k N表示按各行第N列进行排序# -r(reverse)为逆序排序sort -n -k 1 test 转换：tr 字符替换 1234# 转换在内存进行，不改变文件# 将打开文件中所有目标字符替换cat test | tr '1' '2' 字符删除 1234# 转换在内存进行，不改变文件# -d删除(delete)cat test | tr -d '1' 字符压缩 1234# 转换在内存进行，不改变文件# -s位于后部cat test | tr ' ' -s 按列切分文本：cut 截取特定列 12345# 截取的内存进行，不改变文件# -b(byte)以字节为单位，-c(character)以字符为单位，-f以字段为单位# 数字为具体列范围cut -f 1,2 test 指定界定符 1234# 截取的内存进行，不改变文件# -d后接界定符cut -f 2 -d ',' new 按列拼接文本：paste 按列拼接 123456# 在内存中拼接，不改变文件# 将两个文件按对应列拼接# 最后加上-d "x"会将x作为指定分隔符（paste test1 test2 -d ","）# 两文件列数可以不同 paste test1 test2 指定界定符拼接 1234# 在内存中拼接，不改变文件# 按照-d之后给出的界定符拼接paste test1 test2 -d "," 统计行和字符：wc 基本统计123# -l统计行数(line)，-w统计单词数(word)，-c统计字符数(character)wc -l test 文本替换：sed 区别于上面的命令，sed是可以直接改变被编辑文件内容的。 详见 数据流处理：awk 区别于上面的命令，awk是可以直接改变被编辑文件内容的。 详见 系统信息 性能监视工具对于程序员的作用就像是听诊器对于医生的作用一样。系统信息主要针对于服务器性能较低时的排查工作，主要包括CPU信息，文件I/O和内存使用情况，通过进程为纽带得到系统运行的瓶颈。 进程查询：ps 查看正在运行进程 123# 常结合grep筛选信息(e.g, ps -ef | grep xxx)ps -ef 以完整格式显示所有进程 123# 常结合grep筛选信息ps -ajx 进程监控：top 显示实时进程信息123456# 这是个大招，都不带参数的，具体信息通过grep筛选# 交互模式下键入M进程列表按内存使用大小降序排列，键入P进程列表按CPU使用大小降序排列# %id表示CPU空闲率，过低表示可能存在CPU存在瓶颈# %wa表示等待I/O的CPU时间百分比，过高则I/O存在瓶颈 &gt; 用iostat进一步分析top 打开文件查询：lsof 查看占用某端口的进程 1234# 最常见的就是mysql端口被占用使用(lsof i:3307)# 周知端口(ftp:20/21, ssh:22, telnet:23, smtp:25, dns:53, http:80, pop3:110, https:443)lsof -i:53 查看某用户打开的文件 123# -u(user)为用户，后接用户名lsof -u inx 查看指定进程打开的文件 123# -p(process)为进程，后接进程PIDlsof -p 12345 查看指定目录下被进程打开的文件 123# 这里是"+d"，需要注意，使用"+D"递归目录lsof +d /test 内存使用量：free 内存使用量123# 可获得内存及交换区的总量，已使用量，空闲量等信息free 监控性能指标：sar 监控CPU 监控CPU负载 1234# 加上-q可以查看运行队列中进程数，系统上进程大小，平均负载等# 这里"1"表示采样时间间隔是1秒，这里"2"表示采样次数为2sar -q 1 2 监控CPU使用率 1234# 可以显示CPU使用情况# 参数意义同上sar -u 1 2 监控内存 查询内存 1234# 可以显示内存使用情况# 参数意义同上 sar -r 1 2 页面交换查询 1234 # 可以查看是否发生大量页面交换，吞吐率大幅下降时可用 # 参数意义同上sar -W 1 2 网络工具 网络工具部分只介绍基本功能，参数部分一笔带过。这部分重点不在于工具的使用而是对反馈的数据进行解读，并且这部分命令功能的重合度还是比较高的。 网卡配置（链路层）：ifconfig 显示设备信息 123# 可以显示已激活的网络设备信息ifconfig 启动关闭指定网卡 1234# 前一个参数为具体网卡，后一个为开关信息# up为打开，down为关闭ifconfig eth0 up 配置IP地址 123# 前一个参数为具体网卡，后一个为配置的IP地址ifconfig eth0 192.168.1.1 设置最大传输单元 1234前一个参数为具体网卡，后面为MTU的大小# 设置链路层MTU值，通常为1500ifconfig eth0 mtu 1500 启用和关闭ARP协议 123# 开启arp如下，若关闭则-arpifconfig eth0 arp 查看当前网络连接（链路层/网络层/传输层）：netstat 网络接口信息 123# 显示网卡信息，可结合ifconfig学习netstat -i 列出端口 1234# -a(all)表示所有端口，-t(tcp)表示所有使用中的TCP端口# -l(listening)表示正在监听的端口netstat -at 显示端口统计信息 1234# -s(status)显示各协议信息# -加上-t(tcp)显示tcp协议信息，加上-u(udp)显示udp协议信息netstat -s 显示使用某协议的应用名 123# -p(progress)表示程序，可以显示使用tcp/udp协议的应用的名称netstat -pt 查找指定进程、端口 12345# 互逆操作第一个显示某程序使用的端口号，第二个显示某端口号的使用进程# 第二个操作可以用lsof替代netstat -ap | grep sshnetstat -an | grep ':80' 查看路由表（网络层IP协议）：route 查看路由信息1234# 得到路由表信息，具体分析路由表工作需要网络知识# 可以通过netstat -r(route)得到同样的路由表route 检查网络连通性（网络层ICMP协议）：ping 检查是否连通1234# 主要功能是检测网络连通性# 可以额外得到网站的ip地址和连接最大/最小/平均耗时。ping baidu.com 转发路径（网络层ICMP协议）：traceroute 文件包途径的IP1234# # 可以打印从沿途经过的路由器IP地址traceroute baidu.com 网络Debug分析（网络层/传输层）：nc 端口扫描 1234567# 黑客很喜欢# 扫描某服务器端口使用情况# -v(view)显示指令执行过程，-w(wait)设置超时时长# -z使用输入输出模式（只在端口扫描时使用）# 数字为扫描的端口范围 nc -v -w 1 baidu.com -z 75-1000 其他详见 命令行抓包（网络层/传输层）：tcpdump 抓包利器，没有什么比数据更值得信赖。可以跟踪整个传输过程。 详见 域名解析工具（应用层DNS协议）：dig 12345# 应用层，DNS# 打印域名解析结果# 打印域名解析过程中涉及的各级DNS服务器地址dig baidu.com 网络请求（应用层）：curl 详见 其他 这里都是日常开发中高频命令。 终止进程：kill 杀死具体进程 123# 加具体进程PIDkill 12345 杀死某进程相关进程 123# 加上"-9"杀死某进程相关进程kill -9 12345 修改文件权限：chmod 更改文件权限1234567# 可以对三种使用者设置权限，u(user, owner)，g(group)，o(other)# 文件可以有三种权限，r(read)，w(write)，x(execute)# 这里u+r表示文件所有者在原有基础上增加文件读取权限# 这里777分别对应，u=7，g=7，o=7，具体数字含义自行googlechmod u+r filechmod 777 file 创建链接：ln 创建硬链接 123# 文件inode中链接数会增加，只有链接数减为0时文件才真正被删除ln file1 file2 创建软（符号链接）链接 12345# -s(symbol)为符号链接，仅仅是引用路径# 相比于硬链接最大特点是可以跨文件系统# 类似于Windows创建快捷方式，实际文件删除则链接失效ln -s file1 file2 显示文件尾：tail 查看文件尾部1234# -f参数可以不立即回传结束信号，当文件有新写入数据时会及时更新# 查看日志时常用tail -f test 版本控制：git 版本控制最好用的软件，没有之一。至少要知道”git init”，”git add”，”git commit”，”git pull”，”git push”几个命令。 详见 设置别名：alias 常用命令添加别名123# ".bashrc"文件中配置常用命令别名，生效后在命令行只需要使用别名即可代替原先很长的命令alias rm='rm -i' 实战假设已经通过vim编辑，gcc编译得到可执行文件server，这时就可以使用一些开发者常用的工具来进行后期调试。这里都是给出最简单的用法，意在快速掌握一些基本开发工具。 先clone这个项目，然后使用src_code下代码编译通过后通过下面命令调试。代码 单步调试：gdb 运行得不到正确结果可以通过gdb设置断点来查看每个中间变量值，以此来确定哪里出了问题。因为gdb调试内容较多，这里不详细说明。另外，gdb出了可以单步查看变量值，还可以分析coredump文件来排查错误。 动态库依赖：ldd 命令：ldd ./server 可以查看可执行文件server所需的所有动态库，动态库所在目录及其被映射到的虚拟地址空间。 性能分析：top top可以查看当前系统很多信息，比如1,5,15分钟内负载，运行、休眠、僵尸进程数，用户、内核程序占CPU百分比，存储信息等。top可以定位具体哪个进程CPU占用率高和内存使用率高。我们可以以此定位性能问题出在什么程序上（比如你后台执行TKeed server之后，可以看到CPU占用率为99%，这时候我们就需要从这个程序入手了）。 系统调用：strace 命令：strace ./server 上面已经提到TKeed server的CPU占用率为99%，那么问题通常一定是出在了死循环上。我们接下来在代码中找到死循环位置。因为程序中epoll_wait需要阻塞进程，我们怀疑是不是这里没有阻塞，这时就可以通过上面的方式运行server程序。此时可以打印出没次系统调用及其参数等，我们也可以加-o filename将系统调用信息保存下来。 打印进程：ps 命令：ps -ejH 我们在命令行下打开的程序的父进程是shell程序，之前用strace打开server程序，strace也是server的父进程。我们有时候需要知道进程间的层级关系就需要打印进程树，上面的ps命令可以做到。当出现僵尸进程时就可以通过进程树定位具体是哪个进程出了问题。另外当想要知道进程pid时，ps -el | grep XXX也是很常用的。 打开文件：lsof lsof -i:3000 比如在运行server时发现端口被占用了，可以通过lsof -i:port来查看对应端口号正在被哪个进程所占用。端口占用是非常常见的问题，比如3306被占用我遇到过好几次，要么是某个程序正好占用了要么是之前没能结束进程，这些都可以借助lsof帮助查看端口。 修改权限：chmod chmod 000 ./index.html 可以修改文件权限，这里设为000，这样任何人都无法访问，重新在浏览器请求127.0.0.1:3000/index.html就会因为文件权限不够而无法展示，服务器返回状态码为403，符合我们预期。修改权限后再请求一次可得到状态码200。 网卡信息：ifconfig ifconfig 如果想看一下整个传输过程，可以使用tcpdump来抓包，但是抓包时参数需要加上网卡信息，这时候可以通过ifconfig来获得网卡信息。 抓包分析：tcpdump tcpdump -i eth0 port 3000 可以用tcpdump来抓包分析三次握手及数据传输过程，-i之后加上上一步得到的网卡地址，port可以指定监听的端口号。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
