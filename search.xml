<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Object-Detection]]></title>
    <url>%2F2019%2F08%2F25%2FObject-Detection%2F</url>
    <content type="text"><![CDATA[Object-Detection[TOC] 记录关于object detection的经典论文，针对论文结合开源代码进行论文复现，最新CVPR论文请转CVPR(Latest paper learning). R-CNN Fast R-CNN Faster R-CNN Mask R-CNN Light-Head R-CNN Cascade R-CNN SPP-Net YOLO YOLOv2 YOLOv3 YOLT SSD DSSD FSSD ESSD MDSSD Pelee Fire SSD R-FCN FPN DSOD RetinaNet MegDet RefineNet DetNet SSOD CornerNet M2Det 3D Object Detection ZSD（Zero-Shot Object Detection） OSD（One-Shot object Detection） Weakly Supervised Object Detection Softer-NMS 2018 2019 Other SurveyA Survey of Deep Learning-based Object Detection intro：From Fast R-CNN to NAS-FPN arXiv：https://arxiv.org/abs/1907.09408 Object Detection in 20 Years: A Survey intro：This work has been submitted to the IEEE TPAMI for possible publication arXiv：https://arxiv.org/abs/1905.05055 《Recent Advances in Object Detection in the Age of Deep Convolutional Neural Networks》 intro: awesome arXiv: https://arxiv.org/abs/1809.03193 《Deep Learning for Generic Object Detection: A Survey》 intro: Submitted to IJCV 2018 arXiv: https://arxiv.org/abs/1809.02165 Papers&amp;CodesR-CNNRich feature hierarchies for accurate object detection and semantic segmentation intro: R-CNN arxiv: http://arxiv.org/abs/1311.2524 supp: http://people.eecs.berkeley.edu/~rbg/papers/r-cnn-cvpr-supp.pdf slides: http://www.image-net.org/challenges/LSVRC/2013/slides/r-cnn-ilsvrc2013-workshop.pdf slides: http://www.cs.berkeley.edu/~rbg/slides/rcnn-cvpr14-slides.pdf github: https://github.com/rbgirshick/rcnn notes: http://zhangliliang.com/2014/07/23/paper-note-rcnn/ caffe-pr(“Make R-CNN the Caffe detection example”): https://github.com/BVLC/caffe/pull/482 Fast R-CNNFast R-CNN arxiv: http://arxiv.org/abs/1504.08083 slides: http://tutorial.caffe.berkeleyvision.org/caffe-cvpr15-detection.pdf github: https://github.com/rbgirshick/fast-rcnn github(COCO-branch): https://github.com/rbgirshick/fast-rcnn/tree/coco webcam demo: https://github.com/rbgirshick/fast-rcnn/pull/29 notes: http://zhangliliang.com/2015/05/17/paper-note-fast-rcnn/ notes: http://blog.csdn.net/linj_m/article/details/48930179 github(“Fast R-CNN in MXNet”): https://github.com/precedenceguo/mx-rcnn github: https://github.com/mahyarnajibi/fast-rcnn-torch github: https://github.com/apple2373/chainer-simple-fast-rnn github: https://github.com/zplizzi/tensorflow-fast-rcnn A-Fast-RCNN: Hard Positive Generation via Adversary for Object Detection intro: CVPR 2017 arxiv: https://arxiv.org/abs/1704.03414 paper: http://abhinavsh.info/papers/pdfs/adversarial_object_detection.pdf github(Caffe): https://github.com/xiaolonw/adversarial-frcnn Faster R-CNNFaster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks intro: NIPS 2015 arxiv: http://arxiv.org/abs/1506.01497 gitxiv: http://www.gitxiv.com/posts/8pfpcvefDYn2gSgXk/faster-r-cnn-towards-real-time-object-detection-with-region slides: http://web.cs.hacettepe.edu.tr/~aykut/classes/spring2016/bil722/slides/w05-FasterR-CNN.pdf github(official, Matlab): https://github.com/ShaoqingRen/faster_rcnn github(Caffe): https://github.com/rbgirshick/py-faster-rcnn github(MXNet): https://github.com/msracver/Deformable-ConvNets/tree/master/faster_rcnn github(PyTorch–recommend): https://github.com//jwyang/faster-rcnn.pytorch github: https://github.com/mitmul/chainer-faster-rcnn github(Torch):: https://github.com/andreaskoepf/faster-rcnn.torch github(Torch):: https://github.com/ruotianluo/Faster-RCNN-Densecap-torch github(TensorFlow): https://github.com/smallcorgi/Faster-RCNN_TF github(TensorFlow): https://github.com/CharlesShang/TFFRCNN github(C++ demo): https://github.com/YihangLou/FasterRCNN-Encapsulation-Cplusplus github(Keras): https://github.com/yhenon/keras-frcnn github: https://github.com/Eniac-Xie/faster-rcnn-resnet github(C++): https://github.com/D-X-Y/caffe-faster-rcnn/tree/dev R-CNN minus R intro: BMVC 2015 arxiv: http://arxiv.org/abs/1506.06981 Faster R-CNN in MXNet with distributed implementation and data parallelization github: https://github.com/dmlc/mxnet/tree/master/example/rcnn Contextual Priming and Feedback for Faster R-CNN intro: ECCV 2016. Carnegie Mellon University paper: http://abhinavsh.info/context_priming_feedback.pdf poster: http://www.eccv2016.org/files/posters/P-1A-20.pdf An Implementation of Faster RCNN with Study for Region Sampling intro: Technical Report, 3 pages. CMU arxiv: https://arxiv.org/abs/1702.02138 github: https://github.com/endernewton/tf-faster-rcnn github: https://github.com/ruotianluo/pytorch-faster-rcnn Interpretable R-CNN intro: North Carolina State University &amp; Alibaba keywords: AND-OR Graph (AOG) arxiv: https://arxiv.org/abs/1711.05226 Domain Adaptive Faster R-CNN for Object Detection in the Wild intro: CVPR 2018. ETH Zurich &amp; ESAT/PSI arxiv: https://arxiv.org/abs/1803.03243 Mask R-CNN arxiv: http://arxiv.org/abs/1703.06870 github(Keras): https://github.com/matterport/Mask_RCNN github(Caffe2): https://github.com/facebookresearch/Detectron github(Pytorch): https://github.com/wannabeOG/Mask-RCNN github(MXNet): https://github.com/TuSimple/mx-maskrcnn github(Chainer): https://github.com/DeNA/Chainer_Mask_R-CNN Light-Head R-CNNLight-Head R-CNN: In Defense of Two-Stage Object Detector intro: Tsinghua University &amp; Megvii Inc arxiv: https://arxiv.org/abs/1711.07264 github(offical): https://github.com/zengarden/light_head_rcnn github: https://github.com/terrychenism/Deformable-ConvNets/blob/master/rfcn/symbols/resnet_v1_101_rfcn_light.py#L784 Cascade R-CNNCascade R-CNN: Delving into High Quality Object Detection arxiv: https://arxiv.org/abs/1712.00726 github: https://github.com/zhaoweicai/cascade-rcnn SPP-NetSpatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition intro: ECCV 2014 / TPAMI 2015 arxiv: http://arxiv.org/abs/1406.4729 github: https://github.com/ShaoqingRen/SPP_net notes: http://zhangliliang.com/2014/09/13/paper-note-sppnet/ DeepID-Net: Deformable Deep Convolutional Neural Networks for Object Detection intro: PAMI 2016 intro: an extension of R-CNN. box pre-training, cascade on region proposals, deformation layers and context representations project page: http://www.ee.cuhk.edu.hk/%CB%9Cwlouyang/projects/imagenetDeepId/index.html arxiv: http://arxiv.org/abs/1412.5661 Object Detectors Emerge in Deep Scene CNNs intro: ICLR 2015 arxiv: http://arxiv.org/abs/1412.6856 paper: https://www.robots.ox.ac.uk/~vgg/rg/papers/zhou_iclr15.pdf paper: https://people.csail.mit.edu/khosla/papers/iclr2015_zhou.pdf slides: http://places.csail.mit.edu/slide_iclr2015.pdf segDeepM: Exploiting Segmentation and Context in Deep Neural Networks for Object Detection intro: CVPR 2015 project(code+data): https://www.cs.toronto.edu/~yukun/segdeepm.html arxiv: https://arxiv.org/abs/1502.04275 github: https://github.com/YknZhu/segDeepM Object Detection Networks on Convolutional Feature Maps intro: TPAMI 2015 keywords: NoC arxiv: http://arxiv.org/abs/1504.06066 Improving Object Detection with Deep Convolutional Networks via Bayesian Optimization and Structured Prediction arxiv: http://arxiv.org/abs/1504.03293 slides: http://www.ytzhang.net/files/publications/2015-cvpr-det-slides.pdf github: https://github.com/YutingZhang/fgs-obj DeepBox: Learning Objectness with Convolutional Networks keywords: DeepBox arxiv: http://arxiv.org/abs/1505.02146 github: https://github.com/weichengkuo/DeepBox YOLOYou Only Look Once: Unified, Real-Time Object Detection arxiv: http://arxiv.org/abs/1506.02640 code: https://pjreddie.com/darknet/yolov1/ github: https://github.com/pjreddie/darknet blog: https://pjreddie.com/darknet/yolov1/ slides: https://docs.google.com/presentation/d/1aeRvtKG21KHdD5lg6Hgyhx5rPq_ZOsGjG5rJ1HP7BbA/pub?start=false&amp;loop=false&amp;delayms=3000&amp;slide=id.p reddit: https://www.reddit.com/r/MachineLearning/comments/3a3m0o/realtime_object_detection_with_yolo/ github: https://github.com/gliese581gg/YOLO_tensorflow github: https://github.com/xingwangsfu/caffe-yolo github: https://github.com/frankzhangrui/Darknet-Yolo github: https://github.com/BriSkyHekun/py-darknet-yolo github: https://github.com/tommy-qichang/yolo.torch github: https://github.com/frischzenger/yolo-windows github: https://github.com/AlexeyAB/yolo-windows github: https://github.com/nilboy/tensorflow-yolo darkflow - translate darknet to tensorflow. Load trained weights, retrain/fine-tune them using tensorflow, export constant graph def to C++ blog: https://thtrieu.github.io/notes/yolo-tensorflow-graph-buffer-cpp github: https://github.com/thtrieu/darkflow Start Training YOLO with Our Own Data intro: train with customized data and class numbers/labels. Linux / Windows version for darknet. blog: http://guanghan.info/blog/en/my-works/train-yolo/ github: https://github.com/Guanghan/darknet YOLO: Core ML versus MPSNNGraph intro: Tiny YOLO for iOS implemented using CoreML but also using the new MPS graph API. blog: http://machinethink.net/blog/yolo-coreml-versus-mps-graph/ github: https://github.com/hollance/YOLO-CoreML-MPSNNGraph TensorFlow YOLO object detection on Android intro: Real-time object detection on Android using the YOLO network with TensorFlow github: https://github.com/natanielruiz/android-yolo Computer Vision in iOS – Object Detection blog: https://sriraghu.com/2017/07/12/computer-vision-in-ios-object-detection/ github:https://github.com/r4ghu/iOS-CoreML-Yolo YOLOv2YOLO9000: Better, Faster, Stronger arxiv: https://arxiv.org/abs/1612.08242 code: http://pjreddie.com/yolo9000/ https://pjreddie.com/darknet/yolov2/ github(Chainer): https://github.com/leetenki/YOLOv2 github(Keras): https://github.com/allanzelener/YAD2K github(PyTorch): https://github.com/longcw/yolo2-pytorch github(Tensorflow): https://github.com/hizhangp/yolo_tensorflow github(Windows): https://github.com/AlexeyAB/darknet github: https://github.com/choasUp/caffe-yolo9000 github: https://github.com/philipperemy/yolo-9000 github(TensorFlow): https://github.com/KOD-Chen/YOLOv2-Tensorflow github(Keras): https://github.com/yhcc/yolo2 github(Keras): https://github.com/experiencor/keras-yolo2 github(TensorFlow): https://github.com/WojciechMormul/yolo2 darknet_scripts intro: Auxilary scripts to work with (YOLO) darknet deep learning famework. AKA -&gt; How to generate YOLO anchors? github: https://github.com/Jumabek/darknet_scripts Yolo_mark: GUI for marking bounded boxes of objects in images for training Yolo v2 github: https://github.com/AlexeyAB/Yolo_mark LightNet: Bringing pjreddie’s DarkNet out of the shadows https://github.com//explosion/lightnet YOLO v2 Bounding Box Tool intro: Bounding box labeler tool to generate the training data in the format YOLO v2 requires. github: https://github.com/Cartucho/yolo-boundingbox-labeler-GUI Loss Rank Mining: A General Hard Example Mining Method for Real-time Detectors intro: LRM is the first hard example mining strategy which could fit YOLOv2 perfectly and make it better applied in series of real scenarios where both real-time rates and accurate detection are strongly demanded. arxiv: https://arxiv.org/abs/1804.04606 Object detection at 200 Frames Per Second intro: faster than Tiny-Yolo-v2 arxiv: https://arxiv.org/abs/1805.06361 Event-based Convolutional Networks for Object Detection in Neuromorphic Cameras intro: YOLE–Object Detection in Neuromorphic Cameras arxiv:https://arxiv.org/abs/1805.07931 OmniDetector: With Neural Networks to Bounding Boxes intro: a person detector on n fish-eye images of indoor scenes（NIPS 2018） arxiv:https://arxiv.org/abs/1805.08503 datasets:https://gitlab.com/omnidetector/omnidetector YOLOv3YOLOv3: An Incremental Improvement arxiv:https://arxiv.org/abs/1804.02767 paper:https://pjreddie.com/media/files/papers/YOLOv3.pdf code: https://pjreddie.com/darknet/yolo/ github(Official):https://github.com/pjreddie/darknet github:https://github.com/mystic123/tensorflow-yolo-v3 github:https://github.com/experiencor/keras-yolo3 github:https://github.com/qqwweee/keras-yolo3 github:https://github.com/marvis/pytorch-yolo3 github:https://github.com/ayooshkathuria/pytorch-yolo-v3 github:https://github.com/ayooshkathuria/YOLO_v3_tutorial_from_scratch github:https://github.com/eriklindernoren/PyTorch-YOLOv3 github:https://github.com/ultralytics/yolov3 github:https://github.com/BobLiu20/YOLOv3_PyTorch github:https://github.com/andy-yun/pytorch-0.4-yolov3 github:https://github.com/DeNA/PyTorch_YOLOv3 YOLTYou Only Look Twice: Rapid Multi-Scale Object Detection In Satellite Imagery intro: Small Object Detection arxiv:https://arxiv.org/abs/1805.09512 github:https://github.com/avanetten/yolt SSDSSD: Single Shot MultiBox Detector intro: ECCV 2016 Oral arxiv: http://arxiv.org/abs/1512.02325 paper: http://www.cs.unc.edu/~wliu/papers/ssd.pdf slides: http://www.cs.unc.edu/%7Ewliu/papers/ssd_eccv2016_slide.pdf github(Official): https://github.com/weiliu89/caffe/tree/ssd video: http://weibo.com/p/2304447a2326da963254c963c97fb05dd3a973 github: https://github.com/zhreshold/mxnet-ssd github: https://github.com/zhreshold/mxnet-ssd.cpp github: https://github.com/rykov8/ssd_keras github: https://github.com/balancap/SSD-Tensorflow github: https://github.com/amdegroot/ssd.pytorch github(Caffe): https://github.com/chuanqi305/MobileNet-SSD What’s the diffience in performance between this new code you pushed and the previous code? #327 https://github.com/weiliu89/caffe/issues/327 DSSDDSSD : Deconvolutional Single Shot Detector intro: UNC Chapel Hill &amp; Amazon Inc arxiv: https://arxiv.org/abs/1701.06659 github: https://github.com/chengyangfu/caffe/tree/dssd github: https://github.com/MTCloudVision/mxnet-dssd demo: http://120.52.72.53/www.cs.unc.edu/c3pr90ntc0td/~cyfu/dssd_lalaland.mp4 Enhancement of SSD by concatenating feature maps for object detection intro: rainbow SSD (R-SSD) arxiv: https://arxiv.org/abs/1705.09587 Context-aware Single-Shot Detector keywords: CSSD, DiCSSD, DeCSSD, effective receptive fields (ERFs), theoretical receptive fields (TRFs) arxiv: https://arxiv.org/abs/1707.08682 Feature-Fused SSD: Fast Detection for Small Objects https://arxiv.org/abs/1709.05054 FSSDFSSD: Feature Fusion Single Shot Multibox Detector https://arxiv.org/abs/1712.00960 Weaving Multi-scale Context for Single Shot Detector intro: WeaveNet keywords: fuse multi-scale information arxiv: https://arxiv.org/abs/1712.03149 ESSDExtend the shallow part of Single Shot MultiBox Detector via Convolutional Neural Network https://arxiv.org/abs/1801.05918 Tiny SSD: A Tiny Single-shot Detection Deep Convolutional Neural Network for Real-time Embedded Object Detection https://arxiv.org/abs/1802.06488 MDSSDMDSSD: Multi-scale Deconvolutional Single Shot Detector for small objects arxiv: https://arxiv.org/abs/1805.07009 PeleePelee: A Real-Time Object Detection System on Mobile Devices https://github.com/Robert-JunWang/Pelee intro: (ICLR 2018 workshop track) arxiv: https://arxiv.org/abs/1804.06882 github: https://github.com/Robert-JunWang/Pelee Fire SSDFire SSD: Wide Fire Modules based Single Shot Detector on Edge Device intro:low cost, fast speed and high mAP on factor edge computing devices arxiv:https://arxiv.org/abs/1806.05363 R-FCNR-FCN: Object Detection via Region-based Fully Convolutional Networks arxiv: http://arxiv.org/abs/1605.06409 github: https://github.com/daijifeng001/R-FCN github(MXNet): https://github.com/msracver/Deformable-ConvNets/tree/master/rfcn github: https://github.com/Orpine/py-R-FCN github: https://github.com/PureDiors/pytorch_RFCN github: https://github.com/bharatsingh430/py-R-FCN-multiGPU github: https://github.com/xdever/RFCN-tensorflow R-FCN-3000 at 30fps: Decoupling Detection and Classification https://arxiv.org/abs/1712.01802 Recycle deep features for better object detection arxiv: http://arxiv.org/abs/1607.05066 FPNFeature Pyramid Networks for Object Detection intro: Facebook AI Research arxiv: https://arxiv.org/abs/1612.03144 Action-Driven Object Detection with Top-Down Visual Attentions arxiv: https://arxiv.org/abs/1612.06704 Beyond Skip Connections: Top-Down Modulation for Object Detection intro: CMU &amp; UC Berkeley &amp; Google Research arxiv: https://arxiv.org/abs/1612.06851 Wide-Residual-Inception Networks for Real-time Object Detection intro: Inha University arxiv: https://arxiv.org/abs/1702.01243 Attentional Network for Visual Object Detection intro: University of Maryland &amp; Mitsubishi Electric Research Laboratories arxiv: https://arxiv.org/abs/1702.01478 Learning Chained Deep Features and Classifiers for Cascade in Object Detection keykwords: CC-Net intro: chained cascade network (CC-Net). 81.1% mAP on PASCAL VOC 2007 arxiv: https://arxiv.org/abs/1702.07054 DeNet: Scalable Real-time Object Detection with Directed Sparse Sampling intro: ICCV 2017 (poster) arxiv: https://arxiv.org/abs/1703.10295 Discriminative Bimodal Networks for Visual Localization and Detection with Natural Language Queries intro: CVPR 2017 arxiv: https://arxiv.org/abs/1704.03944 Spatial Memory for Context Reasoning in Object Detection arxiv: https://arxiv.org/abs/1704.04224 Accurate Single Stage Detector Using Recurrent Rolling Convolution intro: CVPR 2017. SenseTime keywords: Recurrent Rolling Convolution (RRC) arxiv: https://arxiv.org/abs/1704.05776 github: https://github.com/xiaohaoChen/rrc_detection Deep Occlusion Reasoning for Multi-Camera Multi-Target Detection https://arxiv.org/abs/1704.05775 LCDet: Low-Complexity Fully-Convolutional Neural Networks for Object Detection in Embedded Systems intro: Embedded Vision Workshop in CVPR. UC San Diego &amp; Qualcomm Inc arxiv: https://arxiv.org/abs/1705.05922 Point Linking Network for Object Detection intro: Point Linking Network (PLN) arxiv: https://arxiv.org/abs/1706.03646 Perceptual Generative Adversarial Networks for Small Object Detection https://arxiv.org/abs/1706.05274 Few-shot Object Detection https://arxiv.org/abs/1706.08249 Yes-Net: An effective Detector Based on Global Information https://arxiv.org/abs/1706.09180 SMC Faster R-CNN: Toward a scene-specialized multi-object detector https://arxiv.org/abs/1706.10217 Towards lightweight convolutional neural networks for object detection https://arxiv.org/abs/1707.01395 RON: Reverse Connection with Objectness Prior Networks for Object Detection intro: CVPR 2017 arxiv: https://arxiv.org/abs/1707.01691 github: https://github.com/taokong/RON Mimicking Very Efficient Network for Object Detection intro: CVPR 2017. SenseTime &amp; Beihang University paper: http://openaccess.thecvf.com/content_cvpr_2017/papers/Li_Mimicking_Very_Efficient_CVPR_2017_paper.pdf Residual Features and Unified Prediction Network for Single Stage Detection https://arxiv.org/abs/1707.05031 Deformable Part-based Fully Convolutional Network for Object Detection intro: BMVC 2017 (oral). Sorbonne Universités &amp; CEDRIC arxiv: https://arxiv.org/abs/1707.06175 Adaptive Feeding: Achieving Fast and Accurate Detections by Adaptively Combining Object Detectors intro: ICCV 2017 arxiv: https://arxiv.org/abs/1707.06399 Recurrent Scale Approximation for Object Detection in CNN intro: ICCV 2017 keywords: Recurrent Scale Approximation (RSA) arxiv: https://arxiv.org/abs/1707.09531 github: https://github.com/sciencefans/RSA-for-object-detection DSODDSOD: Learning Deeply Supervised Object Detectors from Scratch intro: ICCV 2017. Fudan University &amp; Tsinghua University &amp; Intel Labs China arxiv: https://arxiv.org/abs/1708.01241 github: https://github.com/szq0214/DSOD github:https://github.com/Windaway/DSOD-Tensorflow github:https://github.com/chenyuntc/dsod.pytorch Learning Object Detectors from Scratch with Gated Recurrent Feature Pyramids arxiv:https://arxiv.org/abs/1712.00886 github:https://github.com/szq0214/GRP-DSOD Tiny-DSOD: Lightweight Object Detection for Resource-Restricted Usages intro: BMVC 2018 arXiv: https://arxiv.org/abs/1807.11013 Object Detection from Scratch with Deep Supervision intro: This is an extended version of DSOD arXiv: https://arxiv.org/abs/1809.09294 RetinaNetFocal Loss for Dense Object Detection intro: ICCV 2017 Best student paper award. Facebook AI Research keywords: RetinaNet arxiv: https://arxiv.org/abs/1708.02002 CoupleNet: Coupling Global Structure with Local Parts for Object Detection intro: ICCV 2017 arxiv: https://arxiv.org/abs/1708.02863 Incremental Learning of Object Detectors without Catastrophic Forgetting intro: ICCV 2017. Inria arxiv: https://arxiv.org/abs/1708.06977 Zoom Out-and-In Network with Map Attention Decision for Region Proposal and Object Detection https://arxiv.org/abs/1709.04347 StairNet: Top-Down Semantic Aggregation for Accurate One Shot Detection https://arxiv.org/abs/1709.05788 Dynamic Zoom-in Network for Fast Object Detection in Large Images https://arxiv.org/abs/1711.05187 Zero-Annotation Object Detection with Web Knowledge Transfer intro: NTU, Singapore &amp; Amazon keywords: multi-instance multi-label domain adaption learning framework arxiv: https://arxiv.org/abs/1711.05954 MegDetMegDet: A Large Mini-Batch Object Detector intro: Peking University &amp; Tsinghua University &amp; Megvii Inc arxiv: https://arxiv.org/abs/1711.07240 Receptive Field Block Net for Accurate and Fast Object Detection intro: RFBNet arxiv: https://arxiv.org/abs/1711.07767 github: https://github.com//ruinmessi/RFBNet An Analysis of Scale Invariance in Object Detection - SNIP arxiv: https://arxiv.org/abs/1711.08189 github: https://github.com/bharatsingh430/snip Feature Selective Networks for Object Detection https://arxiv.org/abs/1711.08879 Learning a Rotation Invariant Detector with Rotatable Bounding Box arxiv: https://arxiv.org/abs/1711.09405 github: https://github.com/liulei01/DRBox Scalable Object Detection for Stylized Objects intro: Microsoft AI &amp; Research Munich arxiv: https://arxiv.org/abs/1711.09822 Learning Object Detectors from Scratch with Gated Recurrent Feature Pyramids arxiv: https://arxiv.org/abs/1712.00886 github: https://github.com/szq0214/GRP-DSOD Deep Regionlets for Object Detection keywords: region selection network, gating network arxiv: https://arxiv.org/abs/1712.02408 Training and Testing Object Detectors with Virtual Images intro: IEEE/CAA Journal of Automatica Sinica arxiv: https://arxiv.org/abs/1712.08470 Large-Scale Object Discovery and Detector Adaptation from Unlabeled Video keywords: object mining, object tracking, unsupervised object discovery by appearance-based clustering, self-supervised detector adaptation arxiv: https://arxiv.org/abs/1712.08832 Spot the Difference by Object Detection intro: Tsinghua University &amp; JD Group arxiv: https://arxiv.org/abs/1801.01051 Localization-Aware Active Learning for Object Detection arxiv: https://arxiv.org/abs/1801.05124 Object Detection with Mask-based Feature Encoding arxiv: https://arxiv.org/abs/1802.03934 LSTD: A Low-Shot Transfer Detector for Object Detection intro: AAAI 2018 arxiv: https://arxiv.org/abs/1803.01529 Pseudo Mask Augmented Object Detection https://arxiv.org/abs/1803.05858 Revisiting RCNN: On Awakening the Classification Power of Faster RCNN https://arxiv.org/abs/1803.06799 Learning Region Features for Object Detection intro: Peking University &amp; MSRA arxiv: https://arxiv.org/abs/1803.07066 Single-Shot Bidirectional Pyramid Networks for High-Quality Object Detection intro: Singapore Management University &amp; Zhejiang University arxiv: https://arxiv.org/abs/1803.08208 Object Detection for Comics using Manga109 Annotations intro: University of Tokyo &amp; National Institute of Informatics, Japan arxiv: https://arxiv.org/abs/1803.08670 Task-Driven Super Resolution: Object Detection in Low-resolution Images arxiv: https://arxiv.org/abs/1803.11316 Transferring Common-Sense Knowledge for Object Detection arxiv: https://arxiv.org/abs/1804.01077 Multi-scale Location-aware Kernel Representation for Object Detection intro: CVPR 2018 arxiv: https://arxiv.org/abs/1804.00428 github: https://github.com/Hwang64/MLKP Loss Rank Mining: A General Hard Example Mining Method for Real-time Detectors intro: National University of Defense Technology arxiv: https://arxiv.org/abs/1804.04606 Robust Physical Adversarial Attack on Faster R-CNN Object Detector arxiv: https://arxiv.org/abs/1804.05810 RefineNetSingle-Shot Refinement Neural Network for Object Detection intro: CVPR 2018 arxiv: https://arxiv.org/abs/1711.06897 github: https://github.com/sfzhang15/RefineDet github: https://github.com/lzx1413/PytorchSSD github: https://github.com/ddlee96/RefineDet_mxnet github: https://github.com/MTCloudVision/RefineDet-Mxnet DetNetDetNet: A Backbone network for Object Detection intro: Tsinghua University &amp; Face++ arxiv: https://arxiv.org/abs/1804.06215 SSODSelf-supervisory Signals for Object Discovery and Detection Google Brain arxiv:https://arxiv.org/abs/1806.03370 CornerNetCornerNet: Detecting Objects as Paired Keypoints intro: ECCV 2018 arXiv: https://arxiv.org/abs/1808.01244 github: https://github.com/umich-vl/CornerNet M2DetM2Det: A Single-Shot Object Detector based on Multi-Level Feature Pyramid Network intro: AAAI 2019 arXiv: https://arxiv.org/abs/1811.04533 github: https://github.com/qijiezhao/M2Det 3D Object Detection3D Backbone Network for 3D Object Detection arXiv: https://arxiv.org/abs/1901.08373 LMNet: Real-time Multiclass Object Detection on CPU using 3D LiDARs arxiv: https://arxiv.org/abs/1805.04902 github: https://github.com/CPFL/Autoware/tree/feature/cnn_lidar_detection ZSD（Zero-Shot Object Detection）Zero-Shot Detection intro: Australian National University keywords: YOLO arxiv: https://arxiv.org/abs/1803.07113 Zero-Shot Object Detection arxiv: https://arxiv.org/abs/1804.04340 Zero-Shot Object Detection: Learning to Simultaneously Recognize and Localize Novel Concepts arxiv: https://arxiv.org/abs/1803.06049 Zero-Shot Object Detection by Hybrid Region Embedding arxiv: https://arxiv.org/abs/1805.06157 OSD（One-Shot Object Detection）Comparison Network for One-Shot Conditional Object Detection arXiv: https://arxiv.org/abs/1904.02317 One-Shot Object Detection RepMet: Representative-based metric learning for classification and one-shot object detection intro: IBM Research AI arxiv:https://arxiv.org/abs/1806.04728 github: TODO Weakly Supervised Object DetectionWeakly Supervised Object Detection in Artworks intro: ECCV 2018 Workshop Computer Vision for Art Analysis arXiv: https://arxiv.org/abs/1810.02569 Datasets: https://wsoda.telecom-paristech.fr/downloads/dataset/IconArt_v1.zip Cross-Domain Weakly-Supervised Object Detection through Progressive Domain Adaptation intro: CVPR 2018 arXiv: https://arxiv.org/abs/1803.11365 homepage: https://naoto0804.github.io/cross_domain_detection/ paper: http://openaccess.thecvf.com/content_cvpr_2018/html/Inoue_Cross-Domain_Weakly-Supervised_Object_CVPR_2018_paper.html github: https://github.com/naoto0804/cross-domain-detection Softer-NMS《Softer-NMS: Rethinking Bounding Box Regression for Accurate Object Detection》 intro: CMU &amp; Face++ arXiv: https://arxiv.org/abs/1809.08545 github: https://github.com/yihui-he/softer-NMS 2019Feature Selective Anchor-Free Module for Single-Shot Object Detection intro: CVPR 2019 arXiv: https://arxiv.org/abs/1903.00621 Object Detection based on Region Decomposition and Assembly intro: AAAI 2019 arXiv: https://arxiv.org/abs/1901.08225 Bottom-up Object Detection by Grouping Extreme and Center Points intro: one stage 43.2% on COCO test-dev arXiv: https://arxiv.org/abs/1901.08043 github: https://github.com/xingyizhou/ExtremeNet ORSIm Detector: A Novel Object Detection Framework in Optical Remote Sensing Imagery Using Spatial-Frequency Channel Features intro: IEEE TRANSACTIONS ON GEOSCIENCE AND REMOTE SENSING arXiv: https://arxiv.org/abs/1901.07925 Consistent Optimization for Single-Shot Object Detection intro: improves RetinaNet from 39.1 AP to 40.1 AP on COCO datase arXiv: https://arxiv.org/abs/1901.06563 Learning Pairwise Relationship for Multi-object Detection in Crowded Scenes arXiv: https://arxiv.org/abs/1901.03796 RetinaMask: Learning to predict masks improves state-of-the-art single-shot detection for free arXiv: https://arxiv.org/abs/1901.03353 github: https://github.com/chengyangfu/retinamask Region Proposal by Guided Anchoring intro: CUHK - SenseTime Joint Lab arXiv: https://arxiv.org/abs/1901.03278 Scale-Aware Trident Networks for Object Detection intro: mAP of 48.4 on the COCO dataset arXiv: https://arxiv.org/abs/1901.01892 2018Large-Scale Object Detection of Images from Network Cameras in Variable Ambient Lighting Conditions arXiv: https://arxiv.org/abs/1812.11901 Strong-Weak Distribution Alignment for Adaptive Object Detection arXiv: https://arxiv.org/abs/1812.04798 AutoFocus: Efficient Multi-Scale Inference intro: AutoFocus obtains an mAP of 47.9% (68.3% at 50% overlap) on the COCO test-dev set while processing 6.4 images per second on a Titan X (Pascal) GPU arXiv: https://arxiv.org/abs/1812.01600 NOTE-RCNN: NOise Tolerant Ensemble RCNN for Semi-Supervised Object Detection intro: Google Could arXiv: https://arxiv.org/abs/1812.00124 SPLAT: Semantic Pixel-Level Adaptation Transforms for Detection intro: UC Berkeley arXiv: https://arxiv.org/abs/1812.00929 Grid R-CNN intro: SenseTime arXiv: https://arxiv.org/abs/1811.12030 Deformable ConvNets v2: More Deformable, Better Results intro: Microsoft Research Asia arXiv: https://arxiv.org/abs/1811.11168 Anchor Box Optimization for Object Detection intro: Microsoft Research arXiv: https://arxiv.org/abs/1812.00469 Efficient Coarse-to-Fine Non-Local Module for the Detection of Small Objects intro: https://arxiv.org/abs/1811.12152 NOTE-RCNN: NOise Tolerant Ensemble RCNN for Semi-Supervised Object Detection arXiv: https://arxiv.org/abs/1812.00124 Learning RoI Transformer for Detecting Oriented Objects in Aerial Images arXiv: https://arxiv.org/abs/1812.00155 Integrated Object Detection and Tracking with Tracklet-Conditioned Detection intro: Microsoft Research Asia arXiv: https://arxiv.org/abs/1811.11167 Deep Regionlets: Blended Representation and Deep Learning for Generic Object Detection arXiv: https://arxiv.org/abs/1811.11318 Gradient Harmonized Single-stage Detector intro: AAAI 2019 arXiv: https://arxiv.org/abs/1811.05181 CFENet: Object Detection with Comprehensive Feature Enhancement Module intro: ACCV 2018 github: https://github.com/qijiezhao/CFENet DeRPN: Taking a further step toward more general object detection intro: AAAI 2019 arXiv: https://arxiv.org/abs/1811.06700 github: https://github.com/HCIILAB/DeRPN Hybrid Knowledge Routed Modules for Large-scale Object Detection intro: Sun Yat-Sen University &amp; Huawei Noah’s Ark Lab arXiv: https://arxiv.org/abs/1810.12681 github: https://github.com/chanyn/HKRM 《Receptive Field Block Net for Accurate and Fast Object Detection》 intro: ECCV 2018 arXiv: https://arxiv.org/abs/1711.07767 github: https://github.com/ruinmessi/RFBNet Deep Feature Pyramid Reconfiguration for Object Detection intro: ECCV 2018 arXiv: https://arxiv.org/abs/1808.07993 Unsupervised Hard Example Mining from Videos for Improved Object Detection intro: ECCV 2018 arXiv: https://arxiv.org/abs/1808.04285 Acquisition of Localization Confidence for Accurate Object Detection intro: ECCV 2018 arXiv: https://arxiv.org/abs/1807.11590 github: https://github.com/vacancy/PreciseRoIPooling Toward Scale-Invariance and Position-Sensitive Region Proposal Networks intro: ECCV 2018 arXiv: https://arxiv.org/abs/1807.09528 MetaAnchor: Learning to Detect Objects with Customized Anchors arxiv: https://arxiv.org/abs/1807.00980 Relation Network for Object Detection intro: CVPR 2018 arxiv: https://arxiv.org/abs/1711.11575 github:https://github.com/msracver/Relation-Networks-for-Object-Detection Quantization Mimic: Towards Very Tiny CNN for Object Detection Tsinghua University1 &amp; The Chinese University of Hong Kong2 &amp;SenseTime3 arxiv: https://arxiv.org/abs/1805.02152 Learning Rich Features for Image Manipulation Detection intro: CVPR 2018 Camera Ready arxiv: https://arxiv.org/abs/1805.04953 SNIPER: Efficient Multi-Scale Training arxiv:https://arxiv.org/abs/1805.09300 github:https://github.com/mahyarnajibi/SNIPER Soft Sampling for Robust Object Detection intro: the robustness of object detection under the presence of missing annotations arxiv:https://arxiv.org/abs/1806.06986 Cost-effective Object Detection: Active Sample Mining with Switchable Selection Criteria intro: TNNLS 2018 arxiv:https://arxiv.org/abs/1807.00147 code: http://kezewang.com/codes/ASM_ver1.zip OtherR3-Net: A Deep Network for Multi-oriented Vehicle Detection in Aerial Images and Videos arxiv: https://arxiv.org/abs/1808.05560 youtube: https://youtu.be/xCYD-tYudN0 Detection Toolbox Detectron(FAIR): Detectron is Facebook AI Research’s software system that implements state-of-the-art object detection algorithms, including Mask R-CNN. It is written in Python and powered by the Caffe2 deep learning framework. maskrcnn-benchmark(FAIR): Fast, modular reference implementation of Instance Segmentation and Object Detection algorithms in PyTorch. mmdetection(SenseTime&amp;CUHK): mmdetection is an open source object detection toolbox based on PyTorch. It is a part of the open-mmlab project developed by Multimedia Laboratory, CUHK.]]></content>
      <categories>
        <category>Computer-Vision</category>
      </categories>
      <tags>
        <tag>Object-Detection</tag>
        <tag>Computer-Vision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构及算法]]></title>
    <url>%2F2019%2F06%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数据结构及算法 Coding！！！！！！！ 目录 Chapter 1 Chapter 2 Chapter 3 纸上代码 动态规划专项 海量数据专项]]></content>
      <categories>
        <category>Data structures and algorithms</category>
      </categories>
      <tags>
        <tag>Data structures and algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中STL总结]]></title>
    <url>%2F2019%2F06%2F17%2FSTL%2F</url>
    <content type="text"><![CDATA[STL组成 容器（containers） 算法（algorithms） 迭代器（iterators） 仿函数（functors） 配接器（adapters） 空间配置器（allocator） 容器（containers） 序列式容器（sequence containers）：元素都是可序（ordered），但未必是有序（sorted） 关联式容器（associattive containers） array array是固定大小的顺序容器，它们保存了一个以严格的线性顺序排列的特定数量的元素。 在内部，一个数组除了它所包含的元素（甚至不是它的大小，它是一个模板参数，在编译时是固定的）以外不保存任何数据。存储大小与用语言括号语法（[]）声明的普通数组一样高效。这个类只是增加了一层成员函数和全局函数，所以数组可以作为标准容器使用。 与其他标准容器不同，数组具有固定的大小，并且不通过分配器管理其元素的分配：它们是封装固定大小数组元素的聚合类型。因此，他们不能动态地扩大或缩小。 零大小的数组是有效的，但是它们不应该被解除引用（成员的前面，后面和数据）。 与标准库中的其他容器不同，交换两个数组容器是一种线性操作，它涉及单独交换范围内的所有元素，这通常是相当低效的操作。另一方面，这允许迭代器在两个容器中的元素保持其原始容器关联。 数组容器的另一个独特特性是它们可以被当作元组对象来处理：array头部重载get函数来访问数组元素，就像它是一个元组，以及专门的tuple_size和tuple_element类型。 1template &lt; class T, size_t N &gt; class array; array::begin返回指向数组容器中第一个元素的迭代器。 12 iterator begin() noexcept;const_iterator begin() const noexcept; Example 12345678910111213#include &lt;iostream&gt;#include &lt;array&gt;int main()&#123; std::array&lt;int, 5&gt; myarray = &#123;2, 16, 77,34, 50&#125;; std::cout &lt;&lt; "myarray contains:"; for(auto it = myarray.begin(); it != myarray.end(); ++i) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 2 16 77 34 50 array::end返回指向数组容器中最后一个元素之后的理论元素的迭代器。 12 iterator end() noexcept;const_iterator end() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123; 5, 19, 77, 34, 99 &#125;; std::cout &lt;&lt; "myarray contains:"; for ( auto it = myarray.begin(); it != myarray.end(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 5 19 77 34 99 array::rbegin返回指向数组容器中最后一个元素的反向迭代器。 12 reverse_iterator rbegin（）noexcept;const_reverse_iterator rbegin（）const noexcept; Example 12345678910111213#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,4&gt; myarray = &#123;4, 26, 80, 14&#125; ; for(auto rit = myarray.rbegin(); rit &lt; myarray.rend(); ++rit) std::cout &lt;&lt; ' ' &lt;&lt; *rit; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 14 80 26 4 array::rend返回一个反向迭代器，指向数组中第一个元素之前的理论元素（这被认为是它的反向结束）。 12 reverse_iterator rend() noexcept;const_reverse_iterator rend() const noexcept; Example 1234567891011121314#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,4&gt; myarray = &#123;4, 26, 80, 14&#125;; std::cout &lt;&lt; "myarray contains"; for(auto rit = myarray.rbegin(); rit &lt; myarray.rend(); ++rit) std::cout &lt;&lt; ' ' &lt;&lt; *rit; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 14 80 26 4 array::cbegin返回指向数组容器中第一个元素的常量迭代器（const_iterator）；这个迭代器可以增加和减少，但是不能用来修改它指向的内容。 1const_iterator cbegin（）const noexcept; Example 12345678910111213141516#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123;2, 16, 77, 34, 50&#125;; std::cout &lt;&lt; "myarray contains:"; for ( auto it = myarray.cbegin(); it != myarray.cend(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; // cannot modify *it std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 2 16 77 34 50 array::cend返回指向数组容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）。这个迭代器可以增加和减少，但是不能用来修改它指向的内容。 1const_iterator cend() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123; 15, 720, 801, 1002, 3502 &#125;; std::cout &lt;&lt; "myarray contains:"; for ( auto it = myarray.cbegin(); it != myarray.cend(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; // cannot modify *it std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 2 16 77 34 50 array::crbegin返回指向数组容器中最后一个元素的常量反向迭代器（const_reverse_iterator） 1const_reverse_iterator crbegin（）const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,6&gt; myarray = &#123;10, 20, 30, 40, 50, 60&#125; ; std::cout &lt;&lt; "myarray backwards:"; for ( auto rit=myarray.crbegin() ; rit &lt; myarray.crend(); ++rit ) std::cout &lt;&lt; ' ' &lt;&lt; *rit; // cannot modify *rit std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray backwards: 60 50 40 30 20 10 array::crend返回指向数组中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator），它被认为是其反向结束。 1const_reverse_iterator crend() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,6&gt; myarray = &#123;10, 20, 30, 40, 50, 60&#125; ; std::cout &lt;&lt; "myarray backwards:"; for ( auto rit=myarray.crbegin() ; rit &lt; myarray.crend(); ++rit ) std::cout &lt;&lt; ' ' &lt;&lt; *rit; // cannot modify *rit std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray backwards: 60 50 40 30 20 10 array::size返回数组容器中元素的数量。 1constexpr size_type size（）noexcept; Example 1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myints; std::cout &lt;&lt; "size of myints:" &lt;&lt; myints.size() &lt;&lt; std::endl; std::cout &lt;&lt; "sizeof(myints):" &lt;&lt; sizeof(myints) &lt;&lt; std::endl; return 0;&#125; Possible Output 12size of myints: 5sizeof(myints): 20 array::max_size返回数组容器可容纳的最大元素数。数组对象的max_size与其size一样，始终等于用于实例化数组模板类的第二个模板参数。 1constexpr size_type max_size() noexcept; Example 1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,10&gt; myints; std::cout &lt;&lt; "size of myints: " &lt;&lt; myints.size() &lt;&lt; '\n'; std::cout &lt;&lt; "max_size of myints: " &lt;&lt; myints.max_size() &lt;&lt; '\n'; return 0;&#125; Output 12size of myints: 10max_size of myints: 10 array::empty返回一个布尔值，指示数组容器是否为空，即它的size()是否为0。 1constexpr bool empty() noexcept; Example 1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,0&gt; first; std::array&lt;int,5&gt; second; std::cout &lt;&lt; "first " &lt;&lt; (first.empty() ? "is empty" : "is not empty") &lt;&lt; '\n'; std::cout &lt;&lt; "second " &lt;&lt; (second.empty() ? "is empty" : "is not empty") &lt;&lt; '\n'; return 0;&#125; Output: 12first is emptysecond is not empt array::operator[]返回数组中第n个位置的元素的引用。与array::at相似，但array::at会检查数组边界并通过抛出一个out_of_range异常来判断n是否超出范围，而array::operator[]不检查边界。 12 reference operator[] (size_type n);const_reference operator[] (size_type n) const; Example 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,10&gt; myarray; unsigned int i; // assign some values: for(i=0; i&lt;10; i++) myarray[i] = i; // print content std::cout &lt;&lt; "myarray contains:"; for(i=0; i&lt;10; i++) std::cout &lt;&lt; ' ' &lt;&lt; myarray[i]; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 0 1 2 3 4 5 6 7 8 9 array::at返回数组中第n个位置的元素的引用。与array::operator[]相似，但array::at会检查数组边界并通过抛出一个out_of_range异常来判断n是否超出范围，而array::operator[]不检查边界。 12 reference at ( size_type n );const_reference at ( size_type n ) const; Example 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main()&#123; std::array&lt;int, 10&gt; myarray; unsigned int i; // assign some values: for (i = 0; i&lt;10; i++) myarray[i] = i; // print content std::cout &lt;&lt; "myarray contains:"; for (i = 0; i&lt;10; i++) std::cout &lt;&lt; ' ' &lt;&lt; myarray.at(i); std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 0 1 2 3 4 5 6 7 8 9 array::front返回对数组容器中第一个元素的引用。array::begin返回的是迭代器，array::front返回的是直接引用。在空容器上调用此函数会导致未定义的行为。 12 reference front();const_reference front() const; Example 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;2, 16, 77&#125;; std::cout &lt;&lt; "front is: " &lt;&lt; myarray.front() &lt;&lt; std::endl; // 2 std::cout &lt;&lt; "back is: " &lt;&lt; myarray.back() &lt;&lt; std::endl; // 77 myarray.front() = 100; std::cout &lt;&lt; "myarray now contains:"; for ( int&amp; x : myarray ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 123front is: 2back is: 77myarray now contains: 100 16 77 array::back返回对数组容器中最后一个元素的引用。array::end返回的是迭代器，array::back返回的是直接引用。在空容器上调用此函数会导致未定义的行为。 12 reference back();const_reference back() const; Example 123456789101112131415161718#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;5, 19, 77&#125;; std::cout &lt;&lt; "front is: " &lt;&lt; myarray.front() &lt;&lt; std::endl; // 5 std::cout &lt;&lt; "back is: " &lt;&lt; myarray.back() &lt;&lt; std::endl; // 77 myarray.back() = 50; std::cout &lt;&lt; "myarray now contains:"; for ( int&amp; x : myarray ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 123front is: 5back is: 77myarray now contains: 5 19 50 array::data返回指向数组对象中第一个元素的指针。 由于数组中的元素存储在连续的存储位置，所以检索到的指针可以偏移以访问数组中的任何元素。 12 value_type* data() noexcept;const value_type* data() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;array&gt;int main ()&#123; const char* cstr = "Test string"; std::array&lt;char,12&gt; charray; std::memcpy (charray.data(),cstr,12); std::cout &lt;&lt; charray.data() &lt;&lt; '\n'; return 0;&#125; Output 1Test string array::fill用val填充数组所有元素，将val设置为数组对象中所有元素的值。 1void fill (const value_type&amp; val); Example 123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main () &#123; std::array&lt;int,6&gt; myarray; myarray.fill(5); std::cout &lt;&lt; "myarray contains:"; for ( int&amp; x : myarray) &#123; std::cout &lt;&lt; ' ' &lt;&lt; x; &#125; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myarray contains: 5 5 5 5 5 5 array::swap通过x的内容交换数组的内容，这是另一个相同类型的数组对象（包括相同的大小）。 与其他容器的交换成员函数不同，此成员函数通过在各个元素之间执行与其大小相同的单独交换操作，以线性时间运行。 1void swap (array&amp; x) noexcept(noexcept(swap(declval&lt;value_type&amp;&gt;(),declval&lt;value_type&amp;&gt;()))); Example 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; first = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; second = &#123;11, 22, 33, 44, 55&#125;; first.swap (second); std::cout &lt;&lt; "first:"; for (int&amp; x : first) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "second:"; for (int&amp; x : second) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 12first: 11 22 33 44 55second: 10 20 30 40 50 get（array）形如：std::get&lt;0&gt;(myarray)；传入一个数组容器，返回指定位置元素的引用。 123template &lt;size_t I，class T，size_t N&gt; T＆get（array &lt;T，N&gt;＆arr）noexcept; template &lt;size_t I，class T，size_t N&gt; T &amp;&amp; get（array &lt;T，N&gt; &amp;&amp; arr）noexcept; template &lt;size_t I，class T，size_t N&gt; const T＆get（const array &lt;T，N&gt;＆arr）noexcept; Example 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;#include &lt;tuple&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;10, 20, 30&#125;; std::tuple&lt;int,int,int&gt; mytuple (10, 20, 30); std::tuple_element&lt;0,decltype(myarray)&gt;::type myelement; // int myelement myelement = std::get&lt;2&gt;(myarray); std::get&lt;2&gt;(myarray) = std::get&lt;0&gt;(myarray); std::get&lt;0&gt;(myarray) = myelement; std::cout &lt;&lt; "first element in myarray: " &lt;&lt; std::get&lt;0&gt;(myarray) &lt;&lt; "\n"; std::cout &lt;&lt; "first element in mytuple: " &lt;&lt; std::get&lt;0&gt;(mytuple) &lt;&lt; "\n"; return 0;&#125; Output 12first element in myarray: 30first element in mytuple: 10 relational operators (array)形如：arrayA != arrayB、arrayA &gt; arrayB；依此比较数组每个元素的大小关系。 123456789101112131415161718（1） template &lt;class T，size_T N&gt; bool operator ==（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（2） template &lt;class T，size_T N&gt; bool operator！=（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（3） template &lt;class T，size_T N&gt; bool operator &lt;（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（4） template &lt;class T，size_T N&gt; bool operator &lt;=（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（5） template &lt;class T，size_T N&gt; bool operator&gt;（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（6） template &lt;class T，size_T N&gt; bool operator&gt; =（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）; Example 123456789101112131415161718#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; a = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; b = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; c = &#123;50, 40, 30, 20, 10&#125;; if (a==b) std::cout &lt;&lt; "a and b are equal\n"; if (b!=c) std::cout &lt;&lt; "b and c are not equal\n"; if (b&lt;c) std::cout &lt;&lt; "b is less than c\n"; if (c&gt;b) std::cout &lt;&lt; "c is greater than b\n"; if (a&lt;=b) std::cout &lt;&lt; "a is less than or equal to b\n"; if (a&gt;=b) std::cout &lt;&lt; "a is greater than or equal to b\n"; return 0;&#125; Output 123456a and b are equalb and c are not equalb is less than cc is greater than ba is less than or equal to ba is greater than or equal to b vectorvector是表示可以改变大小的数组的序列容器。 就像数组一样，vector为它们的元素使用连续的存储位置，这意味着它们的元素也可以使用到其元素的常规指针上的偏移来访问，而且和数组一样高效。但是与数组不同的是，它们的大小可以动态地改变，它们的存储由容器自动处理。 在内部，vector使用一个动态分配的数组来存储它们的元素。这个数组可能需要重新分配，以便在插入新元素时增加大小，这意味着分配一个新数组并将所有元素移动到其中。就处理时间而言，这是一个相对昂贵的任务，因此每次将元素添加到容器时矢量都不会重新分配。 相反，vector容器可以分配一些额外的存储以适应可能的增长，并且因此容器可以具有比严格需要包含其元素（即，其大小）的存储更大的实际容量。库可以实现不同的策略的增长到内存使用和重新分配之间的平衡，但在任何情况下，再分配应仅在对数生长的间隔发生尺寸，使得在所述载体的末端各个元件的插入可以与提供分期常量时间复杂性。 因此，与数组相比，载体消耗更多的内存来交换管理存储和以有效方式动态增长的能力。 与其他动态序列容器（deques，lists和 forward_lists ）相比，vector非常有效地访问其元素（就像数组一样），并相对有效地从元素末尾添加或移除元素。对于涉及插入或移除除了结尾之外的位置的元素的操作，它们执行比其他位置更差的操作，并且具有比列表和 forward_lists 更不一致的迭代器和引用。 针对 vector 的各种常见操作的复杂度（效率）如下： 随机访问 - 常数 O(1) 在尾部增删元素 - 平摊（amortized）常数 O(1)}} 增删元素 - 至 vector 尾部的线性距离 O(n)}} 1template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class vector; vector::vector（1）empty容器构造函数（默认构造函数）构造一个空的容器，没有元素。（2）fill构造函数用n个元素构造一个容器。每个元素都是val的副本（如果提供）。（3）范围（range）构造器使用与[ range，first，last]范围内的元素相同的顺序构造一个容器，其中的每个元素都是emplace -从该范围内相应的元素构造而成。（4）复制（copy）构造函数（并用分配器复制）按照相同的顺序构造一个包含x中每个元素的副本的容器。（5）移动（move）构造函数（和分配器移动）构造一个获取x元素的容器。如果指定了alloc并且与x的分配器不同，那么元素将被移动。否则，没有构建元素（他们的所有权直接转移）。x保持未指定但有效的状态。（6）初始化列表构造函数构造一个容器中的每个元件中的一个拷贝的IL，以相同的顺序。 12345678910111213141516171819default (1) explicit vector (const allocator_type&amp; alloc = allocator_type());fill (2) explicit vector (size_type n); vector (size_type n, const value_type&amp; val, const allocator_type&amp; alloc = allocator_type());range (3) template &lt;class InputIterator&gt; vector (InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type());copy (4) vector (const vector&amp; x);vector (const vector&amp; x, const allocator_type&amp; alloc);move (5) vector (vector&amp;&amp; x);vector (vector&amp;&amp; x, const allocator_type&amp; alloc);initializer list (6) vector (initializer_list&lt;value_type&gt; il, const allocator_type&amp; alloc = allocator_type()); Example 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; // constructors used in the same order as described above: std::vector&lt;int&gt; first; // empty vector of ints std::vector&lt;int&gt; second(4, 100); // four ints with value 100 std::vector&lt;int&gt; third(second.begin(), second.end());// iterating through second std::vector&lt;int&gt; fourth(third); // a copy of third // the iterator constructor can also be used to construct from arrays: int myints[] = &#123;16,2,77,29&#125;; std::vector&lt;int&gt; fifth(myints, myints + sizeof(myints) / sizeof(int)); std::cout &lt;&lt; "The contents of fifth are:"; for(std::vector&lt;int&gt;::iterator it = fifth.begin(); it != fifth.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1The contents of fifth are: 16 2 77 29 vector::~vector销毁容器对象。这将在每个包含的元素上调用allocator_traits::destroy，并使用其分配器释放由矢量分配的所有存储容量。 1~vector(); vector::operator=将新内容分配给容器，替换其当前内容，并相应地修改其大小。 123456copy (1) vector&amp; operator= (const vector&amp; x);move (2) vector&amp; operator= (vector&amp;&amp; x);initializer list (3) vector&amp; operator= (initializer_list&lt;value_type&gt; il); Example 123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; foo (3,0); std::vector&lt;int&gt; bar (5,0); bar = foo; foo = std::vector&lt;int&gt;(); std::cout &lt;&lt; &quot;Size of foo: &quot; &lt;&lt; int(foo.size()) &lt;&lt; &apos;\n&apos;; std::cout &lt;&lt; &quot;Size of bar: &quot; &lt;&lt; int(bar.size()) &lt;&lt; &apos;\n&apos;; return 0;&#125; Output 12Size of foo: 0Size of bar: 3 vector::beginvector::endvector::rbeginvector::rendvector::cbeginvector::cendvector::rcbeginvector::rcendvector::size返回vector中元素的数量。 这是vector中保存的实际对象的数量，不一定等于其存储容量。 1size_type size() const noexcept; Example 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myints; std::cout &lt;&lt; "0. size: " &lt;&lt; myints.size() &lt;&lt; '\n'; for (int i=0; i&lt;10; i++) myints.push_back(i); std::cout &lt;&lt; "1. size: " &lt;&lt; myints.size() &lt;&lt; '\n'; myints.insert (myints.end(),10,100); std::cout &lt;&lt; "2. size: " &lt;&lt; myints.size() &lt;&lt; '\n'; myints.pop_back(); std::cout &lt;&lt; "3. size: " &lt;&lt; myints.size() &lt;&lt; '\n'; return 0;&#125; Output 12340. size: 01. size: 102. size: 203. size: 19 vector::max_size返回该vector可容纳的元素的最大数量。由于已知的系统或库实现限制， 这是容器可以达到的最大潜在大小，但容器无法保证能够达到该大小：在达到该大小之前的任何时间，仍然无法分配存储。 1size_type max_size() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some content in the vector: for (int i=0; i&lt;100; i++) myvector.push_back(i); std::cout &lt;&lt; "size: " &lt;&lt; myvector.size() &lt;&lt; "\n"; std::cout &lt;&lt; "capacity: " &lt;&lt; myvector.capacity() &lt;&lt; "\n"; std::cout &lt;&lt; "max_size: " &lt;&lt; myvector.max_size() &lt;&lt; "\n"; return 0;&#125; A possible output for this program could be: 123size: 100capacity: 128max_size: 1073741823 vector::resize调整容器的大小，使其包含n个元素。 如果n小于当前的容器size，内容将被缩小到前n个元素，将其删除（并销毁它们）。 如果n大于当前容器size，则通过在末尾插入尽可能多的元素以达到大小n来扩展内容。如果指定了val，则新元素将初始化为val的副本，否则将进行值初始化。 如果n也大于当前的容器的capacity（容量），分配的存储空间将自动重新分配。 注意这个函数通过插入或者删除元素的内容来改变容器的实际内容。 12void resize (size_type n);void resize (size_type n, const value_type&amp; val); Example 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some initial content: for (int i=1;i&lt;10;i++) myvector.push_back(i); myvector.resize(5); myvector.resize(8,100); myvector.resize(12); std::cout &lt;&lt; "myvector contains:"; for (int i=0;i&lt;myvector.size();i++) std::cout &lt;&lt; ' ' &lt;&lt; myvector[i]; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myvector contains: 1 2 3 4 5 100 100 100 0 0 0 0 vector::capacity返回当前为vector分配的存储空间的大小，用元素表示。这个capacity(容量)不一定等于vector的size。它可以相等或更大，额外的空间允许适应增长，而不需要重新分配每个插入。 1size_type capacity() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some content in the vector: for (int i=0; i&lt;100; i++) myvector.push_back(i); std::cout &lt;&lt; "size: " &lt;&lt; (int) myvector.size() &lt;&lt; '\n'; std::cout &lt;&lt; "capacity: " &lt;&lt; (int) myvector.capacity() &lt;&lt; '\n'; std::cout &lt;&lt; "max_size: " &lt;&lt; (int) myvector.max_size() &lt;&lt; '\n'; return 0;&#125; A possible output for this program could be: 123size: 100capacity: 128max_size: 1073741823 vector::empty返回vector是否为空（即，它的size是否为0） 1bool empty() const noexcept; Example 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int sum (0); for (int i=1;i&lt;=10;i++) myvector.push_back(i); while (!myvector.empty()) &#123; sum += myvector.back(); myvector.pop_back(); &#125; std::cout &lt;&lt; "total: " &lt;&lt; sum &lt;&lt; '\n'; return 0;&#125; Output 1total: 55 vector::reserve请求vector容量至少足以包含n个元素。 如果n大于当前vector容量，则该函数使容器重新分配其存储容量，从而将其容量增加到n（或更大）。 在所有其他情况下，函数调用不会导致重新分配，并且vector容量不受影响。 这个函数对vector大小没有影响，也不能改变它的元素。 1void reserve (size_type n); Example 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt;::size_type sz; std::vector&lt;int&gt; foo; sz = foo.capacity(); std::cout &lt;&lt; "making foo grow:\n"; for (int i=0; i&lt;100; ++i) &#123; foo.push_back(i); if (sz!=foo.capacity()) &#123; sz = foo.capacity(); std::cout &lt;&lt; "capacity changed: " &lt;&lt; sz &lt;&lt; '\n'; &#125; &#125; std::vector&lt;int&gt; bar; sz = bar.capacity(); bar.reserve(100); // this is the only difference with foo above std::cout &lt;&lt; "making bar grow:\n"; for (int i=0; i&lt;100; ++i) &#123; bar.push_back(i); if (sz!=bar.capacity()) &#123; sz = bar.capacity(); std::cout &lt;&lt; "capacity changed: " &lt;&lt; sz &lt;&lt; '\n'; &#125; &#125; return 0;&#125; Possible output 1234567891011making foo grow:capacity changed: 1capacity changed: 2capacity changed: 4capacity changed: 8capacity changed: 16capacity changed: 32capacity changed: 64capacity changed: 128making bar grow:capacity changed: 100 vector::shrink_to_fit要求容器减小其capacity(容量)以适应其尺寸。 该请求是非绑定的，并且容器实现可以自由地进行优化，并且保持capacity大于其size的vector。 这可能导致重新分配，但对矢量大小没有影响，并且不能改变其元素。 1void shrink_to_fit(); Example 12345678910111213141516#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector (100); std::cout &lt;&lt; "1. capacity of myvector: " &lt;&lt; myvector.capacity() &lt;&lt; '\n'; myvector.resize(10); std::cout &lt;&lt; "2. capacity of myvector: " &lt;&lt; myvector.capacity() &lt;&lt; '\n'; myvector.shrink_to_fit(); std::cout &lt;&lt; "3. capacity of myvector: " &lt;&lt; myvector.capacity() &lt;&lt; '\n'; return 0;&#125; Possible output 1231. capacity of myvector: 1002. capacity of myvector: 1003. capacity of myvector: 10 vector::operator[]vector::atvector::frontvector::backvector::datavector::assign将新内容分配给vector，替换其当前内容，并相应地修改其大小。 在范围版本（1）中，新内容是从第一个和最后一个范围内的每个元素按相同顺序构造的元素。 在填充版本（2）中，新内容是n个元素，每个元素都被初始化为一个val的副本。 在初始化列表版本（3）中，新内容是以相同顺序作为初始化列表传递的值的副本。 所述内部分配器被用于（通过其性状），以分配和解除分配存储器如果重新分配发生。它也习惯于摧毁所有现有的元素，并构建新的元素。 1234567range (1) template &lt;class InputIterator&gt; void assign (InputIterator first, InputIterator last);fill (2) void assign (size_type n, const value_type&amp; val);initializer list (3) void assign (initializer_list&lt;value_type&gt; il); Example 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; first; std::vector&lt;int&gt; second; std::vector&lt;int&gt; third; first.assign (7,100); // 7 ints with a value of 100 std::vector&lt;int&gt;::iterator it; it=first.begin()+1; second.assign (it,first.end()-1); // the 5 central values of first int myints[] = &#123;1776,7,4&#125;; third.assign (myints,myints+3); // assigning from array. std::cout &lt;&lt; "Size of first: " &lt;&lt; int (first.size()) &lt;&lt; '\n'; std::cout &lt;&lt; "Size of second: " &lt;&lt; int (second.size()) &lt;&lt; '\n'; std::cout &lt;&lt; "Size of third: " &lt;&lt; int (third.size()) &lt;&lt; '\n'; return 0;&#125; Output 123Size of first: 7Size of second: 5Size of third: 3 补充：vector::assign 与 vector::operator= 的区别： vector::assign 实现源码 12345678910111213141516void assign(size_type __n, const _Tp&amp; __val) &#123; _M_fill_assign(__n, __val); &#125;template &lt;class _Tp, class _Alloc&gt;void vector&lt;_Tp, _Alloc&gt;::_M_fill_assign(size_t __n, const value_type&amp; __val) &#123; if (__n &gt; capacity()) &#123; vector&lt;_Tp, _Alloc&gt; __tmp(__n, __val, get_allocator()); __tmp.swap(*this); &#125; else if (__n &gt; size()) &#123; fill(begin(), end(), __val); _M_finish = uninitialized_fill_n(_M_finish, __n - size(), __val); &#125; else erase(fill_n(begin(), __n, __val), end());&#125; vector::operator= 实现源码 12345678910111213141516171819202122232425template &lt;class _Tp, class _Alloc&gt;vector&lt;_Tp,_Alloc&gt;&amp; vector&lt;_Tp,_Alloc&gt;::operator=(const vector&lt;_Tp, _Alloc&gt;&amp; __x)&#123; if (&amp;__x != this) &#123; const size_type __xlen = __x.size(); if (__xlen &gt; capacity()) &#123; iterator __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end()); destroy(_M_start, _M_finish); _M_deallocate(_M_start, _M_end_of_storage - _M_start); _M_start = __tmp; _M_end_of_storage = _M_start + __xlen; &#125; else if (size() &gt;= __xlen) &#123; iterator __i = copy(__x.begin(), __x.end(), begin()); destroy(__i, _M_finish); &#125; else &#123; copy(__x.begin(), __x.begin() + size(), _M_start); uninitialized_copy(__x.begin() + size(), __x.end(), _M_finish); &#125; _M_finish = _M_start + __xlen; &#125; return *this;&#125; vector::push_back在vector的最后一个元素之后添加一个新元素。val的内容被复制（或移动）到新的元素。 这有效地将容器size增加了一个，如果新的矢量size超过了当前vector的capacity，则导致所分配的存储空间自动重新分配。 12void push_back (const value_type&amp; val);void push_back (value_type&amp;&amp; val); Example 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int myint; std::cout &lt;&lt; "Please enter some integers (enter 0 to end):\n"; do &#123; std::cin &gt;&gt; myint; myvector.push_back (myint); &#125; while (myint); std::cout &lt;&lt; "myvector stores " &lt;&lt; int(myvector.size()) &lt;&lt; " numbers.\n"; return 0;&#125; vector::pop_back删除vector中的最后一个元素，有效地将容器size减少一个。 这破坏了被删除的元素。 1void pop_back(); Example 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int sum (0); myvector.push_back (100); myvector.push_back (200); myvector.push_back (300); while (!myvector.empty()) &#123; sum+=myvector.back(); myvector.pop_back(); &#125; std::cout &lt;&lt; "The elements of myvector add up to " &lt;&lt; sum &lt;&lt; '\n'; return 0;&#125; Output 1The elements of myvector add up to 600 vector::insert通过在指定位置的元素之前插入新元素来扩展该vector，通过插入元素的数量有效地增加容器大小。 这会导致分配的存储空间自动重新分配，只有在新的vector的size超过当前的vector的capacity的情况下。 由于vector使用数组作为其基础存储，因此除了将元素插入到vector末尾之后，或vector的begin之前，其他位置会导致容器重新定位位置之后的所有元素到他们的新位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。 1234567891011single element (1) iterator insert (const_iterator position, const value_type&amp; val);fill (2) iterator insert (const_iterator position, size_type n, const value_type&amp; val);range (3) template &lt;class InputIterator&gt;iterator insert (const_iterator position, InputIterator first, InputIterator last);move (4) iterator insert (const_iterator position, value_type&amp;&amp; val);initializer list (5) iterator insert (const_iterator position, initializer_list&lt;value_type&gt; il); Example 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector (3,100); std::vector&lt;int&gt;::iterator it; it = myvector.begin(); it = myvector.insert ( it , 200 ); myvector.insert (it,2,300); // "it" no longer valid, get a new one: it = myvector.begin(); std::vector&lt;int&gt; anothervector (2,400); myvector.insert (it+2,anothervector.begin(),anothervector.end()); int myarray [] = &#123; 501,502,503 &#125;; myvector.insert (myvector.begin(), myarray, myarray+3); std::cout &lt;&lt; "myvector contains:"; for (it=myvector.begin(); it&lt;myvector.end(); it++) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myvector contains: 501 502 503 300 300 400 400 200 100 100 100 补充：insert 迭代器野指针错误： 123456789101112131415int main()&#123; std::vector&lt;int&gt; v(5, 0); std::vector&lt;int&gt;::iterator vi; // 获取vector第一个元素的迭代器 vi = v.begin(); // push_back 插入元素之后可能会因为 push_back 的骚操作（创建一个新vector把旧vector的值复制到新vector），导致vector迭代器iterator的指针变成野指针，而导致insert出错 v.push_back(10); v.insert(vi, 2, 300); return 0;&#125; 改正：应该把vi = v.begin();放到v.push_back(10);后面 vector::erase从vector中删除单个元素（position）或一系列元素（[first，last））。 这有效地减少了被去除的元素的数量，从而破坏了容器的大小。 由于vector使用一个数组作为其底层存储，所以删除除vector结束位置之后，或vector的begin之前的元素外，将导致容器将段被擦除后的所有元素重新定位到新的位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。 12iterator erase (const_iterator position);iterator erase (const_iterator first, const_iterator last); Example 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some values (from 1 to 10) for (int i=1; i&lt;=10; i++) myvector.push_back(i); // erase the 6th element myvector.erase (myvector.begin()+5); // erase the first 3 elements: myvector.erase (myvector.begin(),myvector.begin()+3); std::cout &lt;&lt; "myvector contains:"; for (unsigned i=0; i&lt;myvector.size(); ++i) std::cout &lt;&lt; ' ' &lt;&lt; myvector[i]; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myvector contains: 4 5 7 8 9 10 vector::swap通过x的内容交换容器的内容，x是另一个相同类型的vector对象。尺寸可能不同。 在调用这个成员函数之后，这个容器中的元素是那些在调用之前在x中的元素，而x的元素是在这个元素中的元素。所有迭代器，引用和指针对交换对象保持有效。 请注意，非成员函数存在具有相同名称的交换，并使用与此成员函数相似的优化来重载该算法。 1void swap (vector&amp; x); Example 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; foo (3,100); // three ints with a value of 100 std::vector&lt;int&gt; bar (5,200); // five ints with a value of 200 foo.swap(bar); std::cout &lt;&lt; "foo contains:"; for (unsigned i=0; i&lt;foo.size(); i++) std::cout &lt;&lt; ' ' &lt;&lt; foo[i]; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "bar contains:"; for (unsigned i=0; i&lt;bar.size(); i++) std::cout &lt;&lt; ' ' &lt;&lt; bar[i]; std::cout &lt;&lt; '\n'; return 0;&#125; Output 12foo contains: 200 200 200 200 200 bar contains: 100 100 100 vector::clear从vector中删除所有的元素（被销毁），留下size为0的容器。 不保证重新分配，并且由于调用此函数， vector的capacity不保证发生变化。强制重新分配的典型替代方法是使用swap：vector&lt;T&gt;().swap(x); // clear x reallocating 1void clear() noexcept; Example 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;void printVector(const std::vector&lt;int&gt; &amp;v)&#123; for (auto it = v.begin(); it != v.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; ' '; &#125; std::cout &lt;&lt; std::endl;&#125;int main()&#123; std::vector&lt;int&gt; v1(5, 50); printVector(v1); std::cout &lt;&lt; "v1 size = " &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; "v1 capacity = " &lt;&lt; v1.capacity() &lt;&lt; std::endl; v1.clear(); printVector(v1); std::cout &lt;&lt; "v1 size = " &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; "v1 capacity = " &lt;&lt; v1.capacity() &lt;&lt; std::endl; v1.push_back(11); v1.push_back(22); printVector(v1); std::cout &lt;&lt; "v1 size = " &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; "v1 capacity = " &lt;&lt; v1.capacity() &lt;&lt; std::endl; return 0;&#125; Output 12345678950 50 50 50 50v1 size = 5v1 capacity = 5v1 size = 0v1 capacity = 511 22v1 size = 2v1 capacity = 5 vector::emplace通过在position位置处插入新元素args来扩展容器。这个新元素是用args作为构建的参数来构建的。 这有效地增加了一个容器的大小。 分配存储空间的自动重新分配发生在新的vector的size超过当前向量容量的情况下。 由于vector使用数组作为其基础存储，因此除了将元素插入到vector末尾之后，或vector的begin之前，其他位置会导致容器重新定位位置之后的所有元素到他们的新位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。 该元素是通过调用allocator_traits::construct来转换args来创建的。插入一个类似的成员函数，将现有对象复制或移动到容器中。 12template &lt;class... Args&gt;iterator emplace (const_iterator position, Args&amp;&amp;... args); Example 123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector = &#123;10,20,30&#125;; auto it = myvector.emplace ( myvector.begin()+1, 100 ); myvector.emplace ( it, 200 ); myvector.emplace ( myvector.end(), 300 ); std::cout &lt;&lt; "myvector contains:"; for (auto&amp; x: myvector) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1myvector contains: 10 200 100 20 30 300 vector::emplace_back在vector的末尾插入一个新的元素，紧跟在当前的最后一个元素之后。这个新元素是用args作为构造函数的参数来构造的。 这有效地将容器大小增加了一个，如果新的矢量大小超过了当前的vector容量，则导致所分配的存储空间自动重新分配。 该元素是通过调用allocator_traits :: construct来转换args来创建的。 与push_back相比，emplace_back可以避免额外的复制和移动操作。 12template &lt;class... Args&gt; void emplace_back (Args&amp;&amp;... args); Example 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt; struct President&#123; std::string name; std::string country; int year; President(std::string p_name, std::string p_country, int p_year) : name(std::move(p_name)), country(std::move(p_country)), year(p_year) &#123; std::cout &lt;&lt; "I am being constructed.\n"; &#125; President(President&amp;&amp; other) : name(std::move(other.name)), country(std::move(other.country)), year(other.year) &#123; std::cout &lt;&lt; "I am being moved.\n"; &#125; President&amp; operator=(const President&amp; other) = default;&#125;; int main()&#123; std::vector&lt;President&gt; elections; std::cout &lt;&lt; "emplace_back:\n"; elections.emplace_back("Nelson Mandela", "South Africa", 1994); std::vector&lt;President&gt; reElections; std::cout &lt;&lt; "\npush_back:\n"; reElections.push_back(President("Franklin Delano Roosevelt", "the USA", 1936)); std::cout &lt;&lt; "\nContents:\n"; for (President const&amp; president: elections) &#123; std::cout &lt;&lt; president.name &lt;&lt; " was elected president of " &lt;&lt; president.country &lt;&lt; " in " &lt;&lt; president.year &lt;&lt; ".\n"; &#125; for (President const&amp; president: reElections) &#123; std::cout &lt;&lt; president.name &lt;&lt; " was re-elected president of " &lt;&lt; president.country &lt;&lt; " in " &lt;&lt; president.year &lt;&lt; ".\n"; &#125;&#125; Output 12345678910emplace_back:I am being constructed. push_back:I am being constructed.I am being moved. Contents:Nelson Mandela was elected president of South Africa in 1994.Franklin Delano Roosevelt was re-elected president of the USA in 1936. vector::get_allocator返回与vector关联的构造器对象的副本。 1allocator_type get_allocator() const noexcept; Example 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int * p; unsigned int i; // allocate an array with space for 5 elements using vector's allocator: p = myvector.get_allocator().allocate(5); // construct values in-place on the array: for (i=0; i&lt;5; i++) myvector.get_allocator().construct(&amp;p[i],i); std::cout &lt;&lt; "The allocated array contains:"; for (i=0; i&lt;5; i++) std::cout &lt;&lt; ' ' &lt;&lt; p[i]; std::cout &lt;&lt; '\n'; // destroy and deallocate: for (i=0; i&lt;5; i++) myvector.get_allocator().destroy(&amp;p[i]); myvector.get_allocator().deallocate(p,5); return 0;&#125; Output 1The allocated array contains: 0 1 2 3 4 注意：deallocate和destory的关系： deallocate实现的源码： template &lt;class T&gt; inline void _deallocate(T* buffer) { ::operator delete(buffer); //为什么不用 delete [] ? ,operator delete 区别于 delete //operator delete 是一个底层操作符 }destory： template &lt;class T&gt; inline void _destory(T *ptr) { ptr-&gt;~T(); }destory负责调用类型的析构函数，销毁相应内存上的内容（但销毁后内存地址仍保留） deallocate负责释放内存（此时相应内存中的值在此之前应调用destory销毁，将内存地址返回给系统，代表这部分地址使用引用-1） relational operators (vector)swap (vector)vector dequedeque（[‘dek]）（双端队列）是double-ended queue 的一个不规则缩写。deque是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩。 特定的库可以以不同的方式实现deques，通常作为某种形式的动态数组。但是在任何情况下，它们都允许通过随机访问迭代器直接访问各个元素，通过根据需要扩展和收缩容器来自动处理存储。 因此，它们提供了类似于vector的功能，但是在序列的开始部分也可以高效地插入和删除元素，而不仅仅是在结尾。但是，与vector不同，deques并不保证将其所有元素存储在连续的存储位置：deque通过偏移指向另一个元素的指针访问元素会导致未定义的行为。 两个vector和deques提供了一个非常相似的接口，可以用于类似的目的，但内部工作方式完全不同：虽然vector使用单个数组需要偶尔重新分配以增长，但是deque的元素可以分散在不同的块的容器，容器在内部保存必要的信息以提供对其任何元素的持续时间和统一的顺序接口（通过迭代器）的直接访问。因此，deques在内部比vector更复杂一点，但是这使得他们在某些情况下更有效地增长，尤其是在重新分配变得更加昂贵的很长序列的情况下。 对于频繁插入或删除开始或结束位置以外的元素的操作，deques表现得更差，并且与列表和转发列表相比，迭代器和引用的一致性更低。 deque上常见操作的复杂性（效率）如下： 随机访问 - 常数O(1) 在结尾或开头插入或移除元素 - 摊销不变O(1) 插入或移除元素 - 线性O(n)1template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class deque; deque::deque构造一个deque容器对象，根据所使用的构造函数版本初始化它的内容： Example 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; unsigned int i; // constructors used in the same order as described above: std::deque&lt;int&gt; first; // empty deque of ints std::deque&lt;int&gt; second (4,100); // four ints with value 100 std::deque&lt;int&gt; third (second.begin(),second.end()); // iterating through second std::deque&lt;int&gt; fourth (third); // a copy of third // the iterator constructor can be used to copy arrays: int myints[] = &#123;16,2,77,29&#125;; std::deque&lt;int&gt; fifth (myints, myints + sizeof(myints) / sizeof(int) ); std::cout &lt;&lt; "The contents of fifth are:"; for (std::deque&lt;int&gt;::iterator it = fifth.begin(); it!=fifth.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1The contents of fifth are: 16 2 77 29 deque::push_back在当前的最后一个元素之后 ，在deque容器的末尾添加一个新元素。val的内容被复制（或移动）到新的元素。 这有效地增加了一个容器的大小。 12void push_back (const value_type&amp; val);void push_back (value_type&amp;&amp; val); Example 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; int myint; std::cout &lt;&lt; "Please enter some integers (enter 0 to end):\n"; do &#123; std::cin &gt;&gt; myint; mydeque.push_back (myint); &#125; while (myint); std::cout &lt;&lt; "mydeque stores " &lt;&lt; (int) mydeque.size() &lt;&lt; " numbers.\n"; return 0;&#125; deque::push_front在deque容器的开始位置插入一个新的元素，位于当前的第一个元素之前。val的内容被复制（或移动）到插入的元素。 这有效地增加了一个容器的大小。 12void push_front (const value_type&amp; val);void push_front (value_type&amp;&amp; val); Example 12345678910111213141516#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque (2,100); // two ints with a value of 100 mydeque.push_front (200); mydeque.push_front (300); std::cout &lt;&lt; "mydeque contains:"; for (std::deque&lt;int&gt;::iterator it = mydeque.begin(); it != mydeque.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1300 200 100 100 deque::pop_back删除deque容器中的最后一个元素，有效地将容器大小减少一个。 这破坏了被删除的元素。 1void pop_back(); Example 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; int sum (0); mydeque.push_back (10); mydeque.push_back (20); mydeque.push_back (30); while (!mydeque.empty()) &#123; sum+=mydeque.back(); mydeque.pop_back(); &#125; std::cout &lt;&lt; "The elements of mydeque add up to " &lt;&lt; sum &lt;&lt; '\n'; return 0;&#125; Output 1The elements of mydeque add up to 60 deque::pop_front删除deque容器中的第一个元素，有效地减小其大小。 这破坏了被删除的元素。 1void pop_front(); Example 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; mydeque.push_back (100); mydeque.push_back (200); mydeque.push_back (300); std::cout &lt;&lt; "Popping out the elements in mydeque:"; while (!mydeque.empty()) &#123; std::cout &lt;&lt; ' ' &lt;&lt; mydeque.front(); mydeque.pop_front(); &#125; std::cout &lt;&lt; "\nThe final size of mydeque is " &lt;&lt; int(mydeque.size()) &lt;&lt; '\n'; return 0;&#125; Output 12Popping out the elements in mydeque: 100 200 300The final size of mydeque is 0 deque::emplace_front在deque的开头插入一个新的元素，就在其当前的第一个元素之前。这个新的元素是用args作为构建的参数来构建的。 这有效地增加了一个容器的大小。 该元素是通过调用allocator_traits::construct来转换args来创建的。 存在一个类似的成员函数push_front，它可以将现有对象复制或移动到容器中。 12template &lt;class... Args&gt; void emplace_front (Args&amp;&amp;... args); Example 1234567891011121314151617#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque = &#123;10,20,30&#125;; mydeque.emplace_front (111); mydeque.emplace_front (222); std::cout &lt;&lt; "mydeque contains:"; for (auto&amp; x: mydeque) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1mydeque contains: 222 111 10 20 30 deque::emplace_back在deque的末尾插入一个新的元素，紧跟在当前的最后一个元素之后。这个新的元素是用args作为构建的参数来构建的。 这有效地增加了一个容器的大小。 该元素是通过调用allocator_traits::construct来转换args来创建的。 存在一个类似的成员函数push_back，它可以将现有对象复制或移动到容器中 12template &lt;class... Args&gt; void emplace_back (Args&amp;&amp;... args); Example 1234567891011121314151617#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque = &#123;10,20,30&#125;; mydeque.emplace_back (100); mydeque.emplace_back (200); std::cout &lt;&lt; "mydeque contains:"; for (auto&amp; x: mydeque) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1mydeque contains: 10 20 30 100 200 forward_listforward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。 forward_list（单向链表）被实现为单链表; 单链表可以将它们包含的每个元素存储在不同和不相关的存储位置中。通过关联到序列中下一个元素的链接的每个元素来保留排序。forward_list容器和列表 之间的主要设计区别容器是第一个内部只保留一个到下一个元素的链接，而后者每个元素保留两个链接：一个指向下一个元素，一个指向前一个元素，允许在两个方向上有效的迭代，但是每个元素消耗额外的存储空间并且插入和移除元件的时间开销略高。因此，forward_list对象比列表对象更有效率，尽管它们只能向前迭代。 与其他基本的标准序列容器（array，vector和deque），forward_list通常在插入，提取和移动容器内任何位置的元素方面效果更好，因此也适用于密集使用这些元素的算法，如排序算法。 的主要缺点修饰符Modifiers S和列表相比这些其它序列容器s是说，他们缺乏可以通过位置的元素的直接访问; 例如，要访问forward_list中的第六个元素，必须从开始位置迭代到该位置，这需要在这些位置之间的线性时间。它们还消耗一些额外的内存来保持与每个元素相关联的链接信息（这可能是大型小元素列表的重要因素）。 该修饰符Modifiersclass模板的设计考虑到效率：按照设计，它与简单的手写C型单链表一样高效，实际上是唯一的标准容器，为了效率的考虑故意缺少尺寸成员函数：由于其性质作为一个链表，具有一个需要一定时间的大小的成员将需要它保持一个内部计数器的大小（如列表所示）。这会消耗一些额外的存储空间，并使插入和删除操作效率稍低。要获取forward_list对象的大小，可以使用距离算法的开始和结束，这是一个需要线性时间的操作。 forward_list::forward_list12345678910111213141516171819default (1) explicit forward_list (const allocator_type&amp; alloc = allocator_type());fill (2) explicit forward_list (size_type n);explicit forward_list (size_type n, const value_type&amp; val, const allocator_type&amp; alloc = allocator_type());range (3) template &lt;class InputIterator&gt; forward_list (InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type());copy (4) forward_list (const forward_list&amp; fwdlst);forward_list (const forward_list&amp; fwdlst, const allocator_type&amp; alloc);move (5) forward_list (forward_list&amp;&amp; fwdlst);forward_list (forward_list&amp;&amp; fwdlst, const allocator_type&amp; alloc);initializer list (6) forward_list (initializer_list&lt;value_type&gt; il, const allocator_type&amp; alloc = allocator_type()); Example 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; // constructors used in the same order as described above: std::forward_list&lt;int&gt; first; // default: empty std::forward_list&lt;int&gt; second (3,77); // fill: 3 seventy-sevens std::forward_list&lt;int&gt; third (second.begin(), second.end()); // range initialization std::forward_list&lt;int&gt; fourth (third); // copy constructor std::forward_list&lt;int&gt; fifth (std::move(fourth)); // move ctor. (fourth wasted) std::forward_list&lt;int&gt; sixth = &#123;3, 52, 25, 90&#125;; // initializer_list constructor std::cout &lt;&lt; "first:" ; for (int&amp; x: first) std::cout &lt;&lt; " " &lt;&lt; x; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "second:"; for (int&amp; x: second) std::cout &lt;&lt; " " &lt;&lt; x; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "third:"; for (int&amp; x: third) std::cout &lt;&lt; " " &lt;&lt; x; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "fourth:"; for (int&amp; x: fourth) std::cout &lt;&lt; " " &lt;&lt; x; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "fifth:"; for (int&amp; x: fifth) std::cout &lt;&lt; " " &lt;&lt; x; std::cout &lt;&lt; '\n'; std::cout &lt;&lt; "sixth:"; for (int&amp; x: sixth) std::cout &lt;&lt; " " &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Possible output 1234567forward_list constructor examples:first:second: 77 77 77third: 77 77 77fourth:fifth: 77 77 77sixth: 3 52 25 90 forward_list::~forward_listforward_list::before_begin返回指向容器中第一个元素之前的位置的迭代器。 返回的迭代器不应被解除引用：它是为了用作成员函数的参数emplace_after，insert_after，erase_after或splice_after，指定序列，其中执行该动作的位置的开始位置。 12 iterator before_begin() noexcept;const_iterator before_begin() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; std::forward_list&lt;int&gt; mylist = &#123;20, 30, 40, 50&#125;; mylist.insert_after ( mylist.before_begin(), 11 ); std::cout &lt;&lt; "mylist contains:"; for ( int&amp; x: mylist ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1mylist contains: 11 20 30 40 50 forward_list::cbefore_begin返回指向容器中第一个元素之前的位置的const_iterator。 一个常量性是指向常量内容的迭代器。这个迭代器可以增加和减少（除非它本身也是const），就像forward_list::before_begin返回的迭代器一样，但不能用来修改它指向的内容。 返回的价值不得解除引用。 1const_iterator cbefore_begin() const noexcept; Example 123456789101112131415#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; std::forward_list&lt;int&gt; mylist = &#123;77, 2, 16&#125;; mylist.insert_after ( mylist.cbefore_begin(), 19 ); std::cout &lt;&lt; "mylist contains:"; for ( int&amp; x: mylist ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\n'; return 0;&#125; Output 1mylist contains: 19 77 2 16 liststackqueuepriority_queuesetmultisetmapmap 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。 在映射中，键值通常用于对元素进行排序和唯一标识，而映射的值存储与此键关联的内容。该类型的键和映射的值可能不同，并且在部件类型被分组在一起VALUE_TYPE，这是一种对类型结合两种： 1typedef pair&lt;const Key, T&gt; value_type; 在内部，映射中的元素总是按照由其内部比较对象（比较类型）指示的特定的严格弱排序标准按键排序。映射容器通常比unordered_map容器慢，以通过它们的键来访问各个元素，但是它们允许基于它们的顺序对子集进行直接迭代。 在该映射值地图可以直接通过使用其相应的键来访问括号运算符（（操作符[] ）。 映射通常如实施 12345template &lt; class Key, // map::key_type class T, // map::mapped_type class Compare = less&lt;Key&gt;, // map::key_compare class Alloc = allocator&lt;pair&lt;const Key,T&gt; &gt; // map::allocator_type &gt; class map; map::map构造一个映射容器对象，根据所使用的构造器版本初始化其内容： （1）空容器构造函数（默认构造函数） 构造一个空的容器，没有元素。 （2）范围构造函数 构造具有一样多的元素的范围内的容器[第一，最后一个），其中每个元件布设构造的从在该范围内它的相应的元件。 （3）复制构造函数（并用分配器复制） 使用x中的每个元素的副本构造一个容器。 （4）移动构造函数（并与分配器一起移动） 构造一个获取x元素的容器。如果指定了alloc并且与x的分配器不同，那么元素将被移动。否则，没有构建元素（他们的所有权直接转移）。x保持未指定但有效的状态。 （5）初始化列表构造函数 用il中的每个元素的副本构造一个容器。 12345678910111213141516171819empty (1) explicit map (const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type());explicit map (const allocator_type&amp; alloc);range (2) template &lt;class InputIterator&gt; map (InputIterator first, InputIterator last, const key_compare&amp; comp = key_compare(), const allocator_type&amp; = allocator_type());copy (3) map (const map&amp; x);map (const map&amp; x, const allocator_type&amp; alloc);move (4) map (map&amp;&amp; x);map (map&amp;&amp; x, const allocator_type&amp; alloc);initializer list (5) map (initializer_list&lt;value_type&gt; il, const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type()); Example 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;map&gt;bool fncomp (char lhs, char rhs) &#123;return lhs&lt;rhs;&#125;struct classcomp &#123; bool operator() (const char&amp; lhs, const char&amp; rhs) const &#123;return lhs&lt;rhs;&#125;&#125;;int main ()&#123; std::map&lt;char,int&gt; first; first['a']=10; first['b']=30; first['c']=50; first['d']=70; std::map&lt;char,int&gt; second (first.begin(),first.end()); std::map&lt;char,int&gt; third (second); std::map&lt;char,int,classcomp&gt; fourth; // class as Compare bool(*fn_pt)(char,char) = fncomp; std::map&lt;char,int,bool(*)(char,char)&gt; fifth (fn_pt); // function pointer as Compare return 0;&#125; map::begin返回引用map容器中第一个元素的迭代器。 由于map容器始终保持其元素的顺序，所以开始指向遵循容器排序标准的元素。 如果容器是空的，则返回的迭代器值不应被解除引用。 12 iterator begin() noexcept;const_iterator begin() const noexcept; Example 1234567891011121314151617#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['b'] = 100; mymap['a'] = 200; mymap['c'] = 300; // show content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; " =&gt; " &lt;&lt; it-&gt;second &lt;&lt; '\n'; return 0;&#125; Output 123a =&gt; 200b =&gt; 100c =&gt; 300 map::key_comp返回容器用于比较键的比较对象的副本。 1key_compare key_comp() const; Example 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::key_compare mycomp = mymap.key_comp(); mymap['a']=100; mymap['b']=200; mymap['c']=300; std::cout &lt;&lt; "mymap contains:\n"; char highest = mymap.rbegin()-&gt;first; // key value of last element std::map&lt;char,int&gt;::iterator it = mymap.begin(); do &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; " =&gt; " &lt;&lt; it-&gt;second &lt;&lt; '\n'; &#125; while ( mycomp((*it++).first, highest) ); std::cout &lt;&lt; '\n'; return 0;&#125; Output 1234mymap contains:a =&gt; 100b =&gt; 200c =&gt; 300 map::value_comp返回可用于比较两个元素的比较对象，以获取第一个元素的键是否在第二个元素之前。 1value_compare value_comp() const; Example 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['x']=1001; mymap['y']=2002; mymap['z']=3003; std::cout &lt;&lt; "mymap contains:\n"; std::pair&lt;char,int&gt; highest = *mymap.rbegin(); // last element std::map&lt;char,int&gt;::iterator it = mymap.begin(); do &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; " =&gt; " &lt;&lt; it-&gt;second &lt;&lt; '\n'; &#125; while ( mymap.value_comp()(*it++, highest) ); return 0;&#125; Output 1234mymap contains:x =&gt; 1001y =&gt; 2002z =&gt; 3003 map::find在容器中搜索具有等于k的键的元素，如果找到则返回一个迭代器，否则返回map::end的迭代器。 如果容器的比较对象自反地返回假（即，不管元素作为参数传递的顺序），则两个key被认为是等同的。 另一个成员函数map::count可以用来检查一个特定的键是否存在。 12 iterator find (const key_type&amp; k);const_iterator find (const key_type&amp; k) const; Example 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator it; mymap['a']=50; mymap['b']=100; mymap['c']=150; mymap['d']=200; it = mymap.find('b'); if (it != mymap.end()) mymap.erase (it); // print content: std::cout &lt;&lt; "elements in mymap:" &lt;&lt; '\n'; std::cout &lt;&lt; "a =&gt; " &lt;&lt; mymap.find('a')-&gt;second &lt;&lt; '\n'; std::cout &lt;&lt; "c =&gt; " &lt;&lt; mymap.find('c')-&gt;second &lt;&lt; '\n'; std::cout &lt;&lt; "d =&gt; " &lt;&lt; mymap.find('d')-&gt;second &lt;&lt; '\n'; return 0;&#125; Output 1234elements in mymap:a =&gt; 50c =&gt; 150d =&gt; 200 map::count在容器中搜索具有等于k的键的元素，并返回匹配的数量。 由于地图容器中的所有元素都是唯一的，因此该函数只能返回1（如果找到该元素）或返回零（否则）。 如果容器的比较对象自反地返回错误（即，不管按键作为参数传递的顺序），则两个键被认为是等同的。 1size_type count (const key_type&amp; k) const; Example 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; char c; mymap ['a']=101; mymap ['c']=202; mymap ['f']=303; for (c='a'; c&lt;'h'; c++) &#123; std::cout &lt;&lt; c; if (mymap.count(c)&gt;0) std::cout &lt;&lt; " is an element of mymap.\n"; else std::cout &lt;&lt; " is not an element of mymap.\n"; &#125; return 0;&#125; Output 1234567a is an element of mymap.b is not an element of mymap.c is an element of mymap.d is not an element of mymap.e is not an element of mymap.f is an element of mymap.g is not an element of mymap. map::lower_bound将迭代器返回到下限 返回指向容器中第一个元素的迭代器，该元素的键不会在k之前出现（即，它是等价的或者在其后）。 该函数使用其内部比较对象（key_comp）来确定这一点，将迭代器返回到key_comp（element_key，k）将返回false的第一个元素。 如果map类用默认的比较类型（less）实例化，则函数返回一个迭代器到第一个元素，其键不小于k。 一个类似的成员函数upper_bound具有相同的行为lower_bound，除非映射包含一个key值等于k的元素：在这种情况下，lower_bound返回指向该元素的迭代器，而upper_bound返回指向下一个元素的迭代器。 12 iterator lower_bound (const key_type&amp; k);const_iterator lower_bound (const key_type&amp; k) const; Example 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator itlow,itup; mymap['a']=20; mymap['b']=40; mymap['c']=60; mymap['d']=80; mymap['e']=100; itlow=mymap.lower_bound ('b'); // itlow points to b itup=mymap.upper_bound ('d'); // itup points to e (not d!) mymap.erase(itlow,itup); // erases [itlow,itup) // print content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; " =&gt; " &lt;&lt; it-&gt;second &lt;&lt; '\n'; return 0;&#125; Output 12a =&gt; 20e =&gt; 100 map::upper_bound将迭代器返回到上限 返回一个指向容器中第一个元素的迭代器，它的关键字被认为是在k之后。 该函数使用其内部比较对象（key_comp）来确定这一点，将迭代器返回到key_comp（k，element_key）将返回true的第一个元素。 如果map类用默认的比较类型（less）实例化，则函数返回一个迭代器到第一个元素，其键大于k。 类似的成员函数lower_bound具有与upper_bound相同的行为，除了map包含一个元素，其键值等于k：在这种情况下，lower_bound返回指向该元素的迭代器，而upper_bound返回指向下一个元素的迭代器。 12 iterator upper_bound (const key_type&amp; k);const_iterator upper_bound (const key_type&amp; k) const; Example 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator itlow,itup; mymap['a']=20; mymap['b']=40; mymap['c']=60; mymap['d']=80; mymap['e']=100; itlow=mymap.lower_bound ('b'); // itlow points to b itup=mymap.upper_bound ('d'); // itup points to e (not d!) mymap.erase(itlow,itup); // erases [itlow,itup) // print content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; " =&gt; " &lt;&lt; it-&gt;second &lt;&lt; '\n'; return 0;&#125; Output 12a =&gt; 20e =&gt; 100 map::equal_range获取相同元素的范围 返回包含容器中所有具有与k等价的键的元素的范围边界。 由于地图容器中的元素具有唯一键，所以返回的范围最多只包含一个元素。 如果没有找到匹配，则返回的范围具有零的长度，与两个迭代器指向具有考虑去后一个密钥对所述第一元件ķ根据容器的内部比较对象（key_comp）。如果容器的比较对象返回false，则两个键被认为是等价的。 12pair&lt;const_iterator,const_iterator&gt; equal_range (const key_type&amp; k) const;pair&lt;iterator,iterator&gt; equal_range (const key_type&amp; k); Example 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['a']=10; mymap['b']=20; mymap['c']=30; std::pair&lt;std::map&lt;char,int&gt;::iterator,std::map&lt;char,int&gt;::iterator&gt; ret; ret = mymap.equal_range('b'); std::cout &lt;&lt; "lower bound points to: "; std::cout &lt;&lt; ret.first-&gt;first &lt;&lt; " =&gt; " &lt;&lt; ret.first-&gt;second &lt;&lt; '\n'; std::cout &lt;&lt; "upper bound points to: "; std::cout &lt;&lt; ret.second-&gt;first &lt;&lt; " =&gt; " &lt;&lt; ret.second-&gt;second &lt;&lt; '\n'; return 0;&#125; Output 12lower bound points to: &apos;b&apos; =&gt; 20upper bound points to: &apos;c&apos; =&gt; 30 multimap无序容器（Unordered Container）：unordered_set、unordered_multiset、unordered_map、unordered_multimap包括： unordered_set unordered_multiset unordered_map unordered_multimap 都是以哈希表实现的。 unordered_set、unodered_multiset结构： unordered_map、unodered_multimap结构： unordered_setunordered_multisetunordered_mapunordered_multimaptuple元组是一个能够容纳元素集合的对象。每个元素可以是不同的类型。 1template &lt;class... Types&gt; class tuple; Example 1234567891011121314151617181920212223242526#include &lt;iostream&gt; // std::cout#include &lt;tuple&gt; // std::tuple, std::get, std::tie, std::ignoreint main ()&#123; std::tuple&lt;int,char&gt; foo (10,'x'); auto bar = std::make_tuple ("test", 3.1, 14, 'y'); std::get&lt;2&gt;(bar) = 100; // access element int myint; char mychar; std::tie (myint, mychar) = foo; // unpack elements std::tie (std::ignore, std::ignore, myint, mychar) = bar; // unpack (with ignore) mychar = std::get&lt;3&gt;(bar); std::get&lt;0&gt;(foo) = std::get&lt;2&gt;(bar); std::get&lt;1&gt;(foo) = mychar; std::cout &lt;&lt; "foo contains: "; std::cout &lt;&lt; std::get&lt;0&gt;(foo) &lt;&lt; ' '; std::cout &lt;&lt; std::get&lt;1&gt;(foo) &lt;&lt; '\n'; return 0;&#125; Output 1foo contains: 100 y tuple::tuple构建一个 tuple（元组）对象。 这涉及单独构建其元素，初始化取决于调用的构造函数形式： （1）默认的构造函数 构建一个 元组对象的元素值初始化。 （2）复制/移动构造函数 该对象使用tpl的内容进行初始化 元组目的。tpl的相应元素被传递给每个元素的构造函数。 （3）隐式转换构造函数 同上。tpl中的所有类型都可以隐含地转换为构造中它们各自元素的类型元组 目的。 （4）初始化构造函数用elems中的相应元素初始化每个元素。elems的相应元素被传递给每个元素的构造函数。 （5）对转换构造函数 该对象有两个对应于pr.first和的元素pr.second。PR中的所有类型都应该隐含地转换为其中各自元素的类型元组 目的。 （6）分配器版本 和上面的版本一样，除了每个元素都是使用allocator alloc构造的。 1234567891011121314151617181920212223242526272829303132333435363738default (1) constexpr tuple();copy / move (2) tuple (const tuple&amp; tpl) = default;tuple (tuple&amp;&amp; tpl) = default;implicit conversion (3) template &lt;class... UTypes&gt; tuple (const tuple&lt;UTypes...&gt;&amp; tpl);template &lt;class... UTypes&gt; tuple (tuple&lt;UTypes...&gt;&amp;&amp; tpl);initialization (4) explicit tuple (const Types&amp;... elems);template &lt;class... UTypes&gt; explicit tuple (UTypes&amp;&amp;... elems);conversion from pair (5) template &lt;class U1, class U2&gt; tuple (const pair&lt;U1,U2&gt;&amp; pr);template &lt;class U1, class U2&gt; tuple (pair&lt;U1,U2&gt;&amp;&amp; pr);allocator (6) template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const tuple&amp; tpl);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, tuple&amp;&amp; tpl);template&lt;class Alloc,class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const tuple&lt;UTypes...&gt;&amp; tpl);template&lt;class Alloc, class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, tuple&lt;UTypes...&gt;&amp;&amp; tpl);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const Types&amp;... elems);template&lt;class Alloc, class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, UTypes&amp;&amp;... elems);template&lt;class Alloc, class U1, class U2&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const pair&lt;U1,U2&gt;&amp; pr);template&lt;class Alloc, class U1, class U2&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, pair&lt;U1,U2&gt;&amp;&amp; pr); Example 123456789101112131415161718#include &lt;iostream&gt; // std::cout#include &lt;utility&gt; // std::make_pair#include &lt;tuple&gt; // std::tuple, std::make_tuple, std::getint main ()&#123; std::tuple&lt;int,char&gt; first; // default std::tuple&lt;int,char&gt; second (first); // copy std::tuple&lt;int,char&gt; third (std::make_tuple(20,'b')); // move std::tuple&lt;long,char&gt; fourth (third); // implicit conversion std::tuple&lt;int,char&gt; fifth (10,'a'); // initialization std::tuple&lt;int,char&gt; sixth (std::make_pair(30,'c')); // from pair / move std::cout &lt;&lt; "sixth contains: " &lt;&lt; std::get&lt;0&gt;(sixth); std::cout &lt;&lt; " and " &lt;&lt; std::get&lt;1&gt;(sixth) &lt;&lt; '\n'; return 0;&#125; Output 1sixth contains: 30 and c pair这个类把一对值（values）结合在一起，这些值可能是不同的类型（T1 和 T2）。每个值可以被公有的成员变量first、second访问。 pair是tuple（元组）的一个特例。 pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。 应用： 可以将两个类型数据组合成一个如map&lt;key, value&gt; 当某个函数需要两个返回值时 1template &lt;class T1, class T2&gt; struct pair; pair::pair构建一个pair对象。 这涉及到单独构建它的两个组件对象，初始化依赖于调用的构造器形式： （1）默认的构造函数 构建一个 对对象的元素值初始化。 （2）复制/移动构造函数（和隐式转换） 该对象被初始化为pr的内容 对目的。pr的相应成员被传递给每个成员的构造函数。 （3）初始化构造函数 会员 第一是由一个和成员构建的第二与b。 （4）分段构造 构造成员 first 和 second 到位，传递元素first_args 作为参数的构造函数 first，和元素 second_args 到的构造函数 second 。 1234567891011121314default (1) constexpr pair();copy / move (2) template&lt;class U, class V&gt; pair (const pair&lt;U,V&gt;&amp; pr);template&lt;class U, class V&gt; pair (pair&lt;U,V&gt;&amp;&amp; pr);pair (const pair&amp; pr) = default;pair (pair&amp;&amp; pr) = default;initialization (3) pair (const first_type&amp; a, const second_type&amp; b);template&lt;class U, class V&gt; pair (U&amp;&amp; a, V&amp;&amp; b);piecewise (4) template &lt;class... Args1, class... Args2&gt; pair (piecewise_construct_t pwc, tuple&lt;Args1...&gt; first_args, tuple&lt;Args2...&gt; second_args); Example 12345678910111213141516171819#include &lt;utility&gt; // std::pair, std::make_pair#include &lt;string&gt; // std::string#include &lt;iostream&gt; // std::coutint main () &#123; std::pair &lt;std::string,double&gt; product1; // default constructor std::pair &lt;std::string,double&gt; product2 ("tomatoes",2.30); // value init std::pair &lt;std::string,double&gt; product3 (product2); // copy constructor product1 = std::make_pair(std::string("lightbulbs"),0.99); // using make_pair (move) product2.first = "shoes"; // the type of first is string product2.second = 39.90; // the type of second is double std::cout &lt;&lt; "The price of " &lt;&lt; product1.first &lt;&lt; " is $" &lt;&lt; product1.second &lt;&lt; '\n'; std::cout &lt;&lt; "The price of " &lt;&lt; product2.first &lt;&lt; " is $" &lt;&lt; product2.second &lt;&lt; '\n'; std::cout &lt;&lt; "The price of " &lt;&lt; product3.first &lt;&lt; " is $" &lt;&lt; product3.second &lt;&lt; '\n'; return 0;&#125; Output 123The price of lightbulbs is $0.99The price of shoes is $39.9The price of tomatoes is $2.3]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++容器及算法]]></title>
    <url>%2F2019%2F06%2F15%2FC%2B%2B%2F</url>
    <content type="text"><![CDATA[容器（containers）arrayarray 是固定大小的顺序容器，它们保存了一个以严格的线性顺序排列的特定数量的元素。 方法 含义 begin 返回指向数组容器中第一个元素的迭代器 end 返回指向数组容器中最后一个元素之后的理论元素的迭代器 rbegin 返回指向数组容器中最后一个元素的反向迭代器 rend 返回一个反向迭代器，指向数组中第一个元素之前的理论元素 cbegin 返回指向数组容器中第一个元素的常量迭代器（const_iterator） cend 返回指向数组容器中最后一个元素之后的理论元素的常量迭代器（const_iterator） crbegin 返回指向数组容器中最后一个元素的常量反向迭代器（const_reverse_iterator） crend 返回指向数组中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator） size 返回数组容器中元素的数量 max_size 返回数组容器可容纳的最大元素数 empty 返回一个布尔值，指示数组容器是否为空 operator[] 返回容器中第 n（参数）个位置的元素的引用 at 返回容器中第 n（参数）个位置的元素的引用 front 返回对容器中第一个元素的引用 back 返回对容器中最后一个元素的引用 data 返回指向容器中第一个元素的指针 fill 用 val（参数）填充数组所有元素 swap 通过 x（参数）的内容交换数组的内容 get（array） 形如 std::get&lt;0&gt;(myarray)；传入一个数组容器，返回指定位置元素的引用 relational operators (array) 形如 arrayA &gt; arrayB；依此比较数组每个元素的大小关系 ## vector vector 是表示可以改变大小的数组的序列容器。 方法 含义 vector 构造函数 ~vector 析构函数，销毁容器对象 operator= 将新内容分配给容器，替换其当前内容，并相应地修改其大小 begin 返回指向容器中第一个元素的迭代器 end 返回指向容器中最后一个元素之后的理论元素的迭代器 rbegin 返回指向容器中最后一个元素的反向迭代器 rend 返回一个反向迭代器，指向中第一个元素之前的理论元素 cbegin 返回指向容器中第一个元素的常量迭代器（const_iterator） cend 返回指向容器中最后一个元素之后的理论元素的常量迭代器（const_iterator） crbegin 返回指向容器中最后一个元素的常量反向迭代器（const_reverse_iterator） crend 返回指向容器中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator） size 返回容器中元素的数量 max_size 返回容器可容纳的最大元素数 resize 调整容器的大小，使其包含 n（参数）个元素 capacity 返回当前为 vector 分配的存储空间（容量）的大小 empty 返回 vector 是否为空 reserve 请求 vector 容量至少足以包含 n（参数）个元素 shrink_to_fit 要求容器减小其 capacity（容量）以适应其 size（元素数量） operator[] 返回容器中第 n（参数）个位置的元素的引用 at 返回容器中第 n（参数）个位置的元素的引用 front 返回对容器中第一个元素的引用 back 返回对容器中最后一个元素的引用 data 返回指向容器中第一个元素的指针 assign 将新内容分配给 vector，替换其当前内容，并相应地修改其 size push_back 在容器的最后一个元素之后添加一个新元素 pop_back 删除容器中的最后一个元素，有效地将容器 size 减少一个 insert 通过在指定位置的元素之前插入新元素来扩展该容器，通过插入元素的数量有效地增加容器大小 erase 从 vector 中删除单个元素（position）或一系列元素（[first，last)），这有效地减少了被去除的元素的数量，从而破坏了容器的大小 swap 通过 x（参数）的内容交换容器的内容，x 是另一个类型相同、size 可能不同的 vector 对象 clear 从 vector 中删除所有的元素（被销毁），留下 size 为 0 的容器 emplace 通过在 position（参数）位置处插入新元素 args（参数）来扩展容器 emplace_back 在 vector 的末尾插入一个新的元素，紧跟在当前的最后一个元素之后 get_allocator 返回与vector关联的构造器对象的副本 swap(vector) 容器 x（参数）的内容与容器 y（参数）的内容交换。两个容器对象都必须是相同的类型（相同的模板参数），尽管大小可能不同 relational operators (vector) 形如 vectorA &gt; vectorB；依此比较每个元素的大小关系 dequedeque（[‘dek]）（双端队列）是double-ended queue 的一个不规则缩写。deque是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩。 方法 含义 deque 构造函数 push_back 在当前的最后一个元素之后 ，在 deque 容器的末尾添加一个新元素 push_front 在 deque 容器的开始位置插入一个新的元素，位于当前的第一个元素之前 pop_back 删除 deque 容器中的最后一个元素，有效地将容器大小减少一个 pop_front 删除 deque 容器中的第一个元素，有效地减小其大小 emplace_front 在 deque 的开头插入一个新的元素，就在其当前的第一个元素之前 emplace_back 在 deque 的末尾插入一个新的元素，紧跟在当前的最后一个元素之后 forward_listforward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。 方法 含义 forward_list 返回指向容器中第一个元素之前的位置的迭代器 cbefore_begin 返回指向容器中第一个元素之前的位置的 const_iterator listlist，双向链表，是序列容器，允许在序列中的任何地方进行常数时间插入和擦除操作，并在两个方向上进行迭代。 stackstack 是一种容器适配器，用于在LIFO（后进先出）的操作，其中元素仅从容器的一端插入和提取。 queuequeue 是一种容器适配器，用于在FIFO（先入先出）的操作，其中元素插入到容器的一端并从另一端提取。 priority_queuesetset 是按照特定顺序存储唯一元素的容器。 multisetmapmap 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。 方法 含义 map 构造函数 begin 返回引用容器中第一个元素的迭代器 key_comp 返回容器用于比较键的比较对象的副本 value_comp 返回可用于比较两个元素的比较对象，以获取第一个元素的键是否在第二个元素之前 find 在容器中搜索具有等于 k（参数）的键的元素，如果找到则返回一个迭代器，否则返回 map::end 的迭代器 count 在容器中搜索具有等于 k（参数）的键的元素，并返回匹配的数量 lower_bound 返回一个非递减序列 [first, last)（参数）中的第一个大于等于值 val（参数）的位置的迭代器 upper_bound 返回一个非递减序列 [first, last)（参数）中第一个大于 val（参数）的位置的迭代器 equal_range 获取相同元素的范围，返回包含容器中所有具有与 k（参数）等价的键的元素的范围边界（pair&lt; map&lt;char,int&gt;::iterator, map&lt;char,int&gt;::iterator &gt;） multimapunordered_setunordered_multisetunordered_mapunordered_multimaptuple元组是一个能够容纳元素集合的对象。每个元素可以是不同的类型。 pair这个类把一对值（values）结合在一起，这些值可能是不同的类型（T1 和 T2）。每个值可以被公有的成员变量first、second访问。 算法（algorithms）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136// 简单查找算法，要求输入迭代器（input iterator）find(beg, end, val); // 返回一个迭代器，指向输入序列中第一个等于 val 的元素，未找到返回 endfind_if(beg, end, unaryPred); // 返回一个迭代器，指向第一个满足 unaryPred 的元素，未找到返回 endfind_if_not(beg, end, unaryPred); // 返回一个迭代器，指向第一个令 unaryPred 为 false 的元素，未找到返回 endcount(beg, end, val); // 返回一个计数器，指出 val 出现了多少次count_if(beg, end, unaryPred); // 统计有多少个元素满足 unaryPredall_of(beg, end, unaryPred); // 返回一个 bool 值，判断是否所有元素都满足 unaryPredany_of(beg, end, unaryPred); // 返回一个 bool 值，判断是否任意（存在）一个元素满足 unaryPrednone_of(beg, end, unaryPred); // 返回一个 bool 值，判断是否所有元素都不满足 unaryPred// 查找重复值的算法，传入向前迭代器（forward iterator）adjacent_find(beg, end); // 返回指向第一对相邻重复元素的迭代器，无相邻元素则返回 endadjacent_find(beg, end, binaryPred); // 返回指向第一对相邻重复元素的迭代器，无相邻元素则返回 endsearch_n(beg, end, count, val); // 返回一个迭代器，从此位置开始有 count 个相等元素，不存在则返回 endsearch_n(beg, end, count, val, binaryPred); // 返回一个迭代器，从此位置开始有 count 个相等元素，不存在则返回 end// 查找子序列算法，除 find_first_of（前两个输入迭代器，后两个前向迭代器） 外，都要求两个前向迭代器search(beg1, end1, beg2, end2); // 返回第二个输入范围（子序列）在爹一个输入范围中第一次出现的位置，未找到则返回 end1search(beg1, end1, beg2, end2, binaryPred); // 返回第二个输入范围（子序列）在爹一个输入范围中第一次出现的位置，未找到则返回 end1find_first_of(beg1, end1, beg2, end2); // 返回一个迭代器，指向第二个输入范围中任意元素在第一个范围中首次出现的位置，未找到则返回end1find_first_of(beg1, end1, beg2, end2, binaryPred); // 返回一个迭代器，指向第二个输入范围中任意元素在第一个范围中首次出现的位置，未找到则返回end1find_end(beg1, end1, beg2, end2); // 类似 search，但返回的最后一次出现的位置。如果第二个输入范围为空，或者在第一个输入范围为空，或者在第一个输入范围中未找到它，则返回 end1find_end(beg1, end1, beg2, end2, binaryPred); // 类似 search，但返回的最后一次出现的位置。如果第二个输入范围为空，或者在第一个输入范围为空，或者在第一个输入范围中未找到它，则返回 end1// 其他只读算法，传入输入迭代器for_each(beg, end, unaryOp); // 对输入序列中的每个元素应用可调用对象 unaryOp，unaryOp 的返回值被忽略mismatch(beg1, end1, beg2); // 比较两个序列中的元素。返回一个迭代器的 pair，表示两个序列中第一个不匹配的元素mismatch(beg1, end1, beg2, binaryPred); // 比较两个序列中的元素。返回一个迭代器的 pair，表示两个序列中第一个不匹配的元素equal(beg1, end1, beg2); // 比较每个元素，确定两个序列是否相等。equal(beg1, end1, beg2, binaryPred); // 比较每个元素，确定两个序列是否相等。// 二分搜索算法，传入前向迭代器或随机访问迭代器（random-access iterator），要求序列中的元素已经是有序的。通过小于运算符（&lt;）或 comp 比较操作实现比较。lower_bound(beg, end, val); // 返回一个非递减序列 [beg, end) 中的第一个大于等于值 val 的位置的迭代器，不存在则返回 endlower_bound(beg, end, val, comp); // 返回一个非递减序列 [beg, end) 中的第一个大于等于值 val 的位置的迭代器，不存在则返回 endupper_bound(beg, end, val); // 返回一个非递减序列 [beg, end) 中第一个大于 val 的位置的迭代器，不存在则返回 endupper_bound(beg, end, val, comp); // 返回一个非递减序列 [beg, end) 中第一个大于 val 的位置的迭代器，不存在则返回 endequal_range(beg, end, val); // 返回一个 pair，其 first 成员是 lower_bound 返回的迭代器，其 second 成员是 upper_bound 返回的迭代器binary_search(beg, end, val); // 返回一个 bool 值，指出序列中是否包含等于 val 的元素。对于两个值 x 和 y，当 x 不小于 y 且 y 也不小于 x 时，认为它们相等。// 只写不读算法，要求输出迭代器（output iterator）fill(beg, end, val); // 将 val 赋予每个元素，返回 voidfill_n(beg, cnt, val); // 将 val 赋予 cnt 个元素，返回指向写入到输出序列最有一个元素之后位置的迭代器genetate(beg, end, Gen); // 每次调用 Gen() 生成不同的值赋予每个序列，返回 voidgenetate_n(beg, cnt, Gen); // 每次调用 Gen() 生成不同的值赋予 cnt 个序列，返回指向写入到输出序列最有一个元素之后位置的迭代器// 使用输入迭代器的写算法，读取一个输入序列，将值写入到一个输出序列（dest）中copy(beg, end, dest); // 从输入范围将元素拷贝所有元素到 dest 指定定的目的序列copy_if(beg, end, dest, unaryPred); // 从输入范围将元素拷贝满足 unaryPred 的元素到 dest 指定定的目的序列copy_n(beg, n, dest); // 从输入范围将元素拷贝前 n 个元素到 dest 指定定的目的序列move(beg, end, dest); // 对输入序列中的每个元素调用 std::move，将其移动到迭代器 dest 开始始的序列中transform(beg, end, dest, unaryOp); // 调用给定操作（一元操作），并将结果写到dest中transform(beg, end, beg2, dest, binaryOp); // 调用给定操作（二元操作），并将结果写到dest中replace_copy(beg, end, dest, old_val, new_val); // 将每个元素拷贝到 dest，将等于 old_val 的的元素替换为 new_valreplace_copy_if(beg, end, dest, unaryPred, new_val); // 将每个元素拷贝到 dest，将满足 unaryPred 的的元素替换为 new_valmerge(beg1, end1, beg2, end2, dest); // 两个输入序列必须都是有序的，用 &lt; 运算符将合并后的序列写入到 dest 中merge(beg1, end1, beg2, end2, dest, comp); // 两个输入序列必须都是有序的，使用给定的比较操作（comp）将合并后的序列写入到 dest 中// 使用前向迭代器的写算法，要求前向迭代器iter_swap(iter1, iter2); // 交换 iter1 和 iter2 所表示的元素，返回 voidswap_ranges(beg1, end1, beg2); // 将输入范围中所有元素与 beg2 开始的第二个序列中所有元素进行交换。返回递增后的的 beg2，指向最后一个交换元素之后的位置。replace(beg, end, old_val, new_val); // 用 new_val 替换等于 old_val 的每个匹配元素replace_if(beg, end, unaryPred, new_val); // 用 new_val 替换满足 unaryPred 的每个匹配元素// 使用双向迭代器的写算法，要求双向选代器（bidirectional iterator）copy_backward(beg, end, dest); // 从输入范围中拷贝元素到指定目的位置。如果范围为空,则返回值为 dest；否则，返回值表示从 *beg 中拷贝或移动的元素。move_backward(beg, end, dest); // 从输入范围中移动元素到指定目的位置。如果范围为空,则返回值为 dest；否则,返回值表示从 *beg 中拷贝或移动的元素。inplace_merge(beg, mid, end); // 将同一个序列中的两个有序子序列合并为单一的有序序列。beg 到 mid 间的子序列和 mid 到 end 间的子序列被合并，并被写入到原序列中。使用 &lt; 比较元素。inplace_merge(beg, mid, end, comp); // 将同一个序列中的两个有序子序列合并为单一的有序序列。beg 到 mid 间的子序列和 mid 到 end 间的子序列被合并，并被写入到原序列中。使用给定的 comp 操作。// 划分算法，要求双向选代器（bidirectional iterator）is_partitioned(beg, end, unaryPred); // 如果所有满足谓词 unaryPred 的元素都在不满足 unarypred 的元素之前，则返回 true。若序列为空，也返回 truepartition_copy(beg, end, dest1, dest2, unaryPred); // 将满足 unaryPred 的元素拷贝到到 dest1，并将不满足 unaryPred 的元素拷贝到到 dest2。返回一个迭代器 pair，其 first 成员表示拷贝到 dest1 的的元素的末尾，second 表示拷贝到 dest2 的元素的末尾。partitioned_point(beg, end, unaryPred); // 输入序列必须是已经用 unaryPred 划分过的。返回满足 unaryPred 的范围的尾后迭代器。如果返回的迭代器不是 end，则它指向的元素及其后的元素必须都不满足 unaryPredstable_partition(beg, end, unaryPred); // 使用 unaryPred 划分输入序列。满足 unaryPred 的元素放置在序列开始，不满足的元素放在序列尾部。返回一个迭代器，指向最后一个满足 unaryPred 的元素之后的位置如果所有元素都不满足 unaryPred，则返回 begpartition(beg, end, unaryPred); // 使用 unaryPred 划分输入序列。满足 unaryPred 的元素放置在序列开始，不满足的元素放在序列尾部。返回一个迭代器，指向最后一个满足 unaryPred 的元素之后的位置如果所有元素都不满足 unaryPred，则返回 beg// 排序算法，要求随机访问迭代器（random-access iterator）sort(beg, end); // 排序整个范围stable_sort(beg, end); // 排序整个范围（稳定排序）sort(beg, end, comp); // 排序整个范围stable_sort(beg, end, comp); // 排序整个范围（稳定排序）is_sorted(beg, end); // 返回一个 bool 值，指出整个输入序列是否有序is_sorted(beg, end, comp); // 返回一个 bool 值，指出整个输入序列是否有序is_sorted_until(beg, end); // 在输入序列中査找最长初始有序子序列，并返回子序列的尾后迭代器is_sorted_until(beg, end, comp); // 在输入序列中査找最长初始有序子序列，并返回子序列的尾后迭代器partial_sort(beg, mid, end); // 排序 mid-beg 个元素。即，如果 mid-beg 等于 42，则此函数将值最小的 42 个元素有序放在序列前 42 个位置partial_sort(beg, mid, end, comp); // 排序 mid-beg 个元素。即，如果 mid-beg 等于 42，则此函数将值最小的 42 个元素有序放在序列前 42 个位置partial_sort_copy(beg, end, destBeg, destEnd); // 排序输入范围中的元素，并将足够多的已排序元素放到 destBeg 和 destEnd 所指示的序列中partial_sort_copy(beg, end, destBeg, destEnd, comp); // 排序输入范围中的元素，并将足够多的已排序元素放到 destBeg 和 destEnd 所指示的序列中nth_element(beg, nth, end); // nth 是一个迭代器，指向输入序列中第 n 大的元素。nth 之前的元素都小于等于它，而之后的元素都大于等于它nth_element(beg, nth, end, comp); // nth 是一个迭代器，指向输入序列中第 n 大的元素。nth 之前的元素都小于等于它，而之后的元素都大于等于它// 使用前向迭代器的重排算法。普通版本在输入序列自身内部重拍元素，_copy 版本完成重拍后写入到指定目的序列中，而不改变输入序列remove(beg, end, val); // 通过用保留的元素覆盖要删除的元素实现删除 ==val 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器remove_if(beg, end, unaryPred); // 通过用保留的元素覆盖要删除的元素实现删除满足 unaryPred 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器remove_copy(beg, end, dest, val); // 通过用保留的元素覆盖要删除的元素实现删除 ==val 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器remove_copy_if(beg, end, dest, unaryPred); // 通过用保留的元素覆盖要删除的元素实现删除满足 unaryPred 的元素，返回一个指向最后一个删除元素的尾后位置的迭代器unique(beg, end); // 通过对覆盖相邻的重复元素（用 == 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置unique (beg, end, binaryPred); // 通过对覆盖相邻的重复元素（用 binaryPred 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置unique_copy(beg, end, dest); // 通过对覆盖相邻的重复元素（用 == 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置unique_copy_if(beg, end, dest, binaryPred); // 通过对覆盖相邻的重复元素（用 binaryPred 确定是否相同）实现重排序列。返回一个迭代器，指向不重复元素的尾后位置rotate(beg, mid, end); // 围绕 mid 指向的元素进行元素转动。元素 mid 成为为首元素，随后是 mid+1 到到 end 之前的元素，再接着是 beg 到 mid 之前的元素。返回一个迭代器，指向原来在 beg 位置的元素rotate_copy(beg, mid, end, dest); // 围绕 mid 指向的元素进行元素转动。元素 mid 成为为首元素，随后是 mid+1 到到 end 之前的元素，再接着是 beg 到 mid 之前的元素。返回一个迭代器，指向原来在 beg 位置的元素// 使用双向迭代器的重排算法reverse(beg, end); // 翻转序列中的元素，返回 voidreverse_copy(beg, end, dest);; // 翻转序列中的元素，返回一个迭代器，指向拷贝到目的序列的元素的尾后位置// 使用随机访问迭代器的重排算法random_shuffle(beg, end); // 混洗输入序列中的元素，返回 voidrandom_shuffle(beg, end, rand); // 混洗输入序列中的元素，rand 接受一个正整数的随机对象，返回 voidshuffle(beg, end, Uniform_rand); // 混洗输入序列中的元素，Uniform_rand 必须满足均匀分布随机数生成器的要求，返回 void// 最小值和最大值，使用 &lt; 运算符或给定的比较操作 comp 进行比较min(val1, va12); // 返回 val1 和 val2 中的最小值，两个实参的类型必须完全一致。参数和返回类型都是 const的引引用，意味着对象不会被拷贝。下略min(val1, val2, comp);min(init_list);min(init_list, comp);max(val1, val2);max(val1, val2, comp);max(init_list);max(init_list, comp);minmax(val1, val2); // 返回一个 pair，其 first 成员为提供的值中的较小者，second 成员为较大者。下略minmax(vall, val2, comp);minmax(init_list);minmax(init_list, comp);min_element(beg, end); // 返回指向输入序列中最小元素的迭代器min_element(beg, end, comp); // 返回指向输入序列中最小元素的迭代器max_element(beg, end); // 返回指向输入序列中最大元素的迭代器max_element(beg, end, comp); // 返回指向输入序列中最大元素的迭代器minmax_element(beg, end); // 返回一个 pair，其中 first 成员为最小元素，second 成员为最大元素minmax_element(beg, end, comp); // 返回一个 pair，其中 first 成员为最小元素，second 成员为最大元素// 字典序比较，根据第一对不相等的元素的相对大小来返回结果。如果第一个序列在字典序中小于第二个序列，则返回 true。否则，返回 fa1se。如果个序列比另一个短，且所有元素都与较长序列的对应元素相等，则较短序列在字典序中更小。如果序列长度相等，且对应元素都相等，则在字典序中任何一个都不大于另外一个。lexicographical_compare(beg1, end1, beg2, end2);lexicographical_compare(beg1, end1, beg2, end2, comp);]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVPR(Latest paper learning)]]></title>
    <url>%2F2019%2F06%2F15%2FCVPR(Latest%20paper%20learning)%2F</url>
    <content type="text"><![CDATA[CVPR关于目标检测最新论文(2D目标检测、3D目标检测、视频目标检测).2019-07-24 Update 1 paper A Survey of Deep Learning-based Object Detection intro：From Fast R-CNN to NAS-FPN arXiv：https://arxiv.org/abs/1907.09408 2019-05-17 Update 1 paper Object Detection in 20 Years: A Survey intro：This work has been submitted to the IEEE TPAMI for possible publication arXiv：https://arxiv.org/abs/1905.05055 2019-04-05 Update 1 paper Comparison Network for One-Shot Conditional Object Detection arXiv: https://arxiv.org/abs/1904.02317 2019-03-05 Update 1 paper Feature Selective Anchor-Free Module for Single-Shot Object Detection intro: CVPR 2019 arXiv: https://arxiv.org/abs/1903.00621 2019-02-15 Update 3 detection toolbox Detectron(FAIR): Detectron is Facebook AI Research’s software system that implements state-of-the-art object detection algorithms, including Mask R-CNN. It is written in Python and powered by the Caffe2 deep learning framework. maskrcnn-benchmark(FAIR): Fast, modular reference implementation of Instance Segmentation and Object Detection algorithms in PyTorch. mmdetection(SenseTime&amp;CUHK): mmdetection is an open source object detection toolbox based on PyTorch. It is a part of the open-mmlab project developed by Multimedia Laboratory, CUHK. 2019-01-25 Update 5 papers 3D Backbone Network for 3D Object Detection arXiv: https://arxiv.org/abs/1901.08373 Object Detection based on Region Decomposition and Assembly intro: AAAI 2019 arXiv: https://arxiv.org/abs/1901.08225 Bottom-up Object Detection by Grouping Extreme and Center Points intro: one stage 43.2% on COCO test-dev arXiv: https://arxiv.org/abs/1901.08043 github: https://github.com/xingyizhou/ExtremeNet ORSIm Detector: A Novel Object Detection Framework in Optical Remote Sensing Imagery Using Spatial-Frequency Channel Features intro: IEEE TRANSACTIONS ON GEOSCIENCE AND REMOTE SENSING arXiv: https://arxiv.org/abs/1901.07925 Consistent Optimization for Single-Shot Object Detection intro: improves RetinaNet from 39.1 AP to 40.1 AP on COCO datase arXiv: https://arxiv.org/abs/1901.06563 2019-01-15 Update 1 paper Learning Pairwise Relationship for Multi-object Detection in Crowded Scenes arXiv: https://arxiv.org/abs/1901.03796 2019-01-14 Update 1 paper RetinaMask: Learning to predict masks improves state-of-the-art single-shot detection for free arXiv: https://arxiv.org/abs/1901.03353 github: https://github.com/chengyangfu/retinamask 2019-01-12 Update 1 paper Region Proposal by Guided Anchoring intro: CUHK - SenseTime Joint Lab arXiv: https://arxiv.org/abs/1901.03278 2019-01-08 Update 1 paper Scale-Aware Trident Networks for Object Detection intro: mAP of 48.4 on the COCO dataset arXiv: https://arxiv.org/abs/1901.01892 2019-01-04 Update 1 paper Large-Scale Object Detection of Images from Network Cameras in Variable Ambient Lighting Conditions arXiv: https://arxiv.org/abs/1812.11901 2018-12-13 Update 1 paper Strong-Weak Distribution Alignment for Adaptive Object Detection arXiv: https://arxiv.org/abs/1812.04798 2018-12-05 Update 3 papers AutoFocus: Efficient Multi-Scale Inference intro: AutoFocus obtains an mAP of 47.9% (68.3% at 50% overlap) on the COCO test-dev set while processing 6.4 images per second on a Titan X (Pascal) GPU arXiv: https://arxiv.org/abs/1812.01600 NOTE-RCNN: NOise Tolerant Ensemble RCNN for Semi-Supervised Object Detection intro: Google Could arXiv: https://arxiv.org/abs/1812.00124 SPLAT: Semantic Pixel-Level Adaptation Transforms for Detection intro: UC Berkeley arXiv: https://arxiv.org/abs/1812.00929 2018-12-04 Update 10 papers Grid R-CNN intro: SenseTime arXiv: https://arxiv.org/abs/1811.12030 Deformable ConvNets v2: More Deformable, Better Results intro: Microsoft Research Asia arXiv: https://arxiv.org/abs/1811.11168 Anchor Box Optimization for Object Detection intro: Microsoft Research arXiv: https://arxiv.org/abs/1812.00469 Efficient Coarse-to-Fine Non-Local Module for the Detection of Small Objects intro: https://arxiv.org/abs/1811.12152 NOTE-RCNN: NOise Tolerant Ensemble RCNN for Semi-Supervised Object Detection arXiv: https://arxiv.org/abs/1812.00124 Learning RoI Transformer for Detecting Oriented Objects in Aerial Images arXiv: https://arxiv.org/abs/1812.00155 Integrated Object Detection and Tracking with Tracklet-Conditioned Detection intro: Microsoft Research Asia arXiv: https://arxiv.org/abs/1811.11167 Deep Regionlets: Blended Representation and Deep Learning for Generic Object Detection arXiv: https://arxiv.org/abs/1811.11318 Gradient Harmonized Single-stage Detector intro: AAAI 2019 arXiv: https://arxiv.org/abs/1811.05181 CFENet: Object Detection with Comprehensive Feature Enhancement Module intro: ACCV 2018 github: https://github.com/qijiezhao/CFENet 2018-11-19 DeRPN: Taking a further step toward more general object detection intro: AAAI 2019 arXiv: https://arxiv.org/abs/1811.06700 github: https://github.com/HCIILAB/DeRPN 2018-11-14 M2Det: A Single-Shot Object Detector based on Multi-Level Feature Pyramid Network intro: AAAI 2019 arXiv: https://arxiv.org/abs/1811.04533 github: https://github.com/qijiezhao/M2Det 2018-10-31 Hybrid Knowledge Routed Modules for Large-scale Object Detection intro: Sun Yat-Sen University &amp; Huawei Noah’s Ark Lab arXiv: https://arxiv.org/abs/1810.12681 github: https://github.com/chanyn/HKRM 2018-10-08 Weakly Supervised Object Detection in Artworks intro: ECCV 2018 Workshop Computer Vision for Art Analysis arXiv: https://arxiv.org/abs/1810.02569 Datasets: https://wsoda.telecom-paristech.fr/downloads/dataset/IconArt_v1.zip Cross-Domain Weakly-Supervised Object Detection through Progressive Domain Adaptation intro: CVPR 2018 arXiv: https://arxiv.org/abs/1803.11365 homepage: https://naoto0804.github.io/cross_domain_detection/ paper: http://openaccess.thecvf.com/content_cvpr_2018/html/Inoue_Cross-Domain_Weakly-Supervised_Object_CVPR_2018_paper.html github: https://github.com/naoto0804/cross-domain-detection 2018-09-26 Object Detection from Scratch with Deep Supervision intro: This is an extended version of DSOD arXiv: https://arxiv.org/abs/1809.09294 2018-09-25 《Softer-NMS: Rethinking Bounding Box Regression for Accurate Object Detection》 intro: CMU &amp; Face++ arXiv: https://arxiv.org/abs/1809.08545 github: https://github.com/yihui-he/softer-NMS 2018-09-21 《Receptive Field Block Net for Accurate and Fast Object Detection》 intro: ECCV 2018 arXiv: https://arxiv.org/abs/1711.07767 github: https://github.com/ruinmessi/RFBNet 2018-09-11 《Recent Advances in Object Detection in the Age of Deep Convolutional Neural Networks》 intro: awesome arXiv: https://arxiv.org/abs/1809.03193 2018-09-10 《Deep Learning for Generic Object Detection: A Survey》 intro: Submitted to IJCV 2018 arXiv: https://arxiv.org/abs/1809.02165 2018-08-27 Deep Feature Pyramid Reconfiguration for Object Detection intro: ECCV 2018 arXiv: https://arxiv.org/abs/1808.07993 2018-08-17 R3-Net: A Deep Network for Multi-oriented Vehicle Detection in Aerial Images and Videos arxiv: https://arxiv.org/abs/1808.05560 youtube: https://youtu.be/xCYD-tYudN0 2018-08-14 《Unsupervised Hard Example Mining from Videos for Improved Object Detection》 intro: ECCV 2018 arXiv: https://arxiv.org/abs/1808.04285 2018-08-10 CornerNet: Detecting Objects as Paired Keypoints intro: ECCV 2018 arXiv: https://arxiv.org/abs/1808.01244 2018-07-30 Acquisition of Localization Confidence for Accurate Object Detection intro: ECCV 2018 arXiv: https://arxiv.org/abs/1807.11590 github: https://github.com/vacancy/PreciseRoIPooling]]></content>
      <categories>
        <category>Computer-Vision</category>
      </categories>
      <tags>
        <tag>CV</tag>
        <tag>Object-Detection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试]]></title>
    <url>%2F2019%2F06%2F15%2F%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[知识点积累KDXF 1.PCA原理，LDA的区别 2.梯度爆炸，梯度消失，参数初始化。 Project Question 一 Faster RCNN中的anchor box(YOLO/SSD)、anchor怎么理解 二 剪枝原理 三 数据是否归一化操作、距离度量后。]]></content>
      <categories>
        <category>Kaaier</category>
      </categories>
      <tags>
        <tag>Data Structures and Algorithms</tag>
        <tag>Kaaier</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Non-Maximum-Suppression]]></title>
    <url>%2F2019%2F05%2F25%2FNMS%2F</url>
    <content type="text"><![CDATA[Non-Maximum-Suppression非极大值抑制（Non-Maximum-Suppression，NMS）是抑制非极大值的元素，可以理解为局部最大搜索。NMS算法在计算机视觉中有广泛应用，特别是目标检测领域。本文将以目标检测举例，讨论NMS算法的实现过程。 TODO: 记录关于NMS的相关实现以及SoftNMS等目标检测后处理方法 参考 《Efficient Non-Maximum Suppression》 非极大值抑制（Non-Maximum Suppression，NMS） NMS——非极大值抑制 非极大抑制（Non-Maximum Suppression） 吴恩达（Non-max Suppression）视频 Non-Maximum Suppression for Object Detection in Python 非极大值抑制(Non-Maximum Suppression) nonMaximumSuppression：非极大值抑制，包含了matlab，c,，c++，3种实现的代码 Non-Maximum-Suppression：C++实现 deep-learning-tools：Python实现]]></content>
      <categories>
        <category>Computer-Vision</category>
      </categories>
      <tags>
        <tag>Object-Detection</tag>
        <tag>Computer-Vision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识点积累]]></title>
    <url>%2F2019%2F04%2F16%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[操作系统 面向进程和线程学习操作系统。 目录 Chapter 1 Chapter 2 Chapter 3 Chapter 4 Chapter 5 进程线程模型 进程间通信 同步互斥机制 存储管理 网络I/O模型 &lt;!-- more --&gt;内容进程线程模型线程和进程的概念已经在操作系统书中被翻来覆去讲了很多遍。很多概念虽然都是套话，但没能理解透其中深意会导致很多内容理解不清晰。对于进程和线程的理解和把握可以说基本奠定了对系统的认知和把控能力。其核心意义绝不仅仅是“线程是调度的基本单位，进程是资源分配的基本单位”这么简单。 多线程 我们这里讨论的是用户态的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被虽有的线程共享，比如有全局变量int i = 10，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全。我们必须知道，做一次简单的i = i + 1在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节，而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。 但是，虽然线程在安全性方面会引入许多新挑战，但是线程带来的好处也是有目共睹的。首先，原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。比如QQ可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。 对于线程，我认为弄清以下两点非常重要： 线程之间有无先后访问顺序（线程依赖关系） 多个线程共享访问同一变量（同步互斥问题） 另外，我们通常只会去说同一进程的多个线程共享进程的资源，但是每个线程特有的部分却很少提及，除了标识线程的tid，每个线程还有自己独立的栈空间，线程彼此之间是无法访问其他线程栈上内容的。而作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。 线程相关接口不少，主要需要了解各个参数意义和返回值意义。 线程创建和结束 背景知识： 在一个文件内的多个函数通常都是按照main函数中出现的顺序来执行，但是在分时系统下，我们可以让每个函数都作为一个逻辑流并发执行，最简单的方式就是采用多线程策略。在main函数中调用多线程接口创建线程，每个线程对应特定的函数（操作），这样就可以不按照main函数中各个函数出现的顺序来执行，避免了忙等的情况。线程基本操作的接口如下。 相关接口： 创建线程：int pthread_create(pthread_t pthread, const pthread_attr_t *attr, void *(start_routine)(void *), void *agr); 创建一个新线程，pthread和start_routine不可或缺，分别用于标识线程和执行体入口，其他可以填NULL。 pthread：用来返回线程的tid，*pthread值即为tid，类型pthread_t == unsigned long int。 attr：指向线程属性结构体的指针，用于改变所创线程的属性，填NULL使用默认值。 start_routine：线程执行函数的首地址，传入函数指针。 arg：通过地址传递来传递函数参数，这里是无符号类型指针，可以传任意类型变量的地址，在被传入函数中先强制类型转换成所需类型即可。 获得线程ID：pthread_t pthread_self(); 调用时，会打印线程ID。 等待线程结束：int pthread_join(pthread_t tid, void** retval); 主线程调用，等待子线程退出并回收其资源，类似于进程中wait/waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。 tid：创建线程时通过指针得到tid值。 retval：指向返回值的指针。 结束线程：pthread_exit(void *retval); 子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。 retval：同上。 分离线程：int pthread_detach(pthread_t tid); 主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。 tid：同上。 线程属性值修改 背景知识： 线程属性对象类型为pthread_attr_t，结构体定义如下： 123456789101112typedef struct&#123; int etachstate; // 线程分离的状态 int schedpolicy; // 线程调度策略 struct sched_param schedparam; // 线程的调度参数 int inheritsched; // 线程的继承性 int scope; // 线程的作用域 // 以下为线程栈的设置 size_t guardsize; // 线程栈末尾警戒缓冲大小 int stackaddr_set; // 线程的栈设置 void * stackaddr; // 线程栈的位置 size_t stacksize; // 线程栈大小&#125;pthread_arrt_t; 相关接口： 对上述结构体中各参数大多有：pthread_attr_get()和pthread_attr_set()系统调用函数来设置和获取。这里不一一罗列。 线程同步 详见同步互斥专题 多进程 每一个进程是资源分配的基本单位。进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。实际上在父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎一样，子进程创建时拷贝父进程PCB中大部分内容，而PCB的内容实际上是各种数据、代码的地址或索引表地址，所以复制了PCB中这些指针实际就等于获取了全部父进程可访问数据。所以简单来说，创建新进程需要复制整个PCB，之后操作系统将PCB添加到进程核心堆栈底部，这样就可以被操作系统感知和调度了。 父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过写时复制机制将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。我们在shell中执行程序就是通过shell进程先fork()一个子进程再通过execv()重新加载新的代码段的过程。 进程创建与结束 背景知识： 进程有两种创建方式，一种是操作系统创建的一种是父进程创建的。从计算机启动到终端执行程序的过程为：0号进程 -&gt; 1号内核进程 -&gt; 1号用户进程(init进程) -&gt; getty进程 -&gt; shell进程 -&gt; 命令行执行进程。所以我们在命令行中通过 ./program执行可执行文件时，所有创建的进程都是shell进程的子进程，这也就是为什么shell一关闭，在shell中执行的进程都自动被关闭的原因。从shell进程到创建其他子进程需要通过以下接口。 相关接口： 创建进程：pid_t fork(void); 返回值：出错返回-1；父进程中返回pid &gt; 0；子进程中pid == 0 结束进程：void exit(int status); status是退出状态，保存在全局变量中S?，通常0表示正常退出。 获得PID：pid_t getpid(void); 返回调用者pid。 获得父进程PID：pid_t getppid(void); 返回父进程pid。 其他补充： 正常退出方式：exit()、_exit()、return（在main中）。 exit()和_exit()区别：exit()是对_exit()的封装，都会终止进程并做相关收尾工作，最主要的区别是_exit()函数关闭全部描述符和清理函数后不会刷新流，但是exit()会在调用_exit()函数前刷新数据流。 return和exit()区别：exit()是函数，但有参数，执行完之后控制权交给系统。return若是在调用函数中，执行完之后控制权交给调用进程，若是在main函数中，控制权交给系统。 异常退出方式：abort()、终止信号。 僵尸进程、孤儿进程 背景知识： 父进程在调用fork接口之后和子进程已经可以独立开，之后父进程和子进程就以未知的顺序向下执行（异步过程）。所以父进程和子进程都有可能先执行完。当父进程先结束，子进程此时就会变成孤儿进程，不过这种情况问题不大，孤儿进程会自动向上被init进程收养，init进程完成对状态收集工作。而且这种过继的方式也是守护进程能够实现的因素。如果子进程先结束，父进程并未调用wait或者waitpid获取进程状态信息，那么子进程描述符就会一直保存在系统中，这种进程称为僵尸进程。 相关接口： 回收进程（1）：pid_t wait(int *status); 一旦调用wait()，就会立即阻塞自己，wait()自动分析某个子进程是否已经退出，如果找到僵尸进程就会负责收集和销毁，如果没有找到就一直阻塞在这里。 status：指向子进程结束状态值。 回收进程（2）：pid_t waitpid(pid_t pid, int *status, int options); 返回值：返回pid：返回收集的子进程id。返回-1：出错。返回0：没有被手机的子进程。 pid：子进程识别码，控制等待哪些子进程。 pid &lt; -1，等待进程组识别码为pid绝对值的任何进程。 pid = -1，等待任何子进程。 pid = 0，等待进程组识别码与目前进程相同的任何子进程。 pid &gt; 0，等待任何子进程识别码为pid的子进程。 status：指向返回码的指针。 options：选项决定父进程调用waitpid后的状态。 options = WNOHANG，即使没有子进程退出也会立即返回。 options = WUNYRACED，子进程进入暂停马上返回，但结束状态不予理会。 守护进程 背景知识： 守护进程是脱离终端并在后台运行的进程，执行过程中信息不会显示在终端上并且也不会被终端发出的信号打断。 操作步骤： 创建子进程，父进程退出：fork() + if(pid &gt; 0){exit(0);}，使子进程称为孤儿进程被init进程收养。 在子进程中创建新会话：setsid()。 改变当前目录结构为根：chdir(“/“)。 重设文件掩码：umask(0)。 关闭文件描述符：for(int i = 0; i &lt; 65535; ++i){close(i);}。 Linux进程控制 进程地址空间（地址空间） 虚拟存储器为每个进程提供了独占系统地址空间的假象。尽管每个进程地址空间内容不尽相同，但是他们的都有相似的结构。X86 Linux进程的地址空间底部是保留给用户程序的，包括文本、数据、堆、栈等，其中文本区和数据区是通过存储器映射方式将磁盘中可执行文件的相应段映射至虚拟存储器地址空间中。有一些”敏感”的地址需要注意下，对于32位进程来说，代码段从0x08048000开始。从0xC0000000开始到0xFFFFFFFF是内核地址空间，通常情况下代码运行在用户态（使用0x00000000 ~ 0xC00000000的用户地址空间），当发生系统调用、进程切换等操作时CPU控制寄存器设置模式位，进入内和模式，在该状态（超级用户模式）下进程可以访问全部存储器位置和执行全部指令。也就说32位进程的地址空间都是4G，但用户态下只能访问低3G的地址空间，若要访问3G ~ 4G的地址空间则只有进入内核态才行。 进程控制块（处理机） 进程的调度实际就是内核选择相应的进程控制块，被选择的进程控制块中包含了一个进程基本的信息。 上下文切换 内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程B。 线程、进程比较 关于进程和线程的区别这里就不一一罗列了，主要对比下线程和进程操作中主要的接口。 fork()和pthread_create() 负责创建。调用fork()后返回两次，一次标识主进程一次标识子进程；调用pthread_create()后得到一个可以独立执行的线程。 wait()和pthread_join() 负责回收。调用wait()后父进程阻塞；调用pthread_join()后主线程阻塞。 exit()和pthread_exit() 负责退出。调用exit()后调用进程退出，控制权交给系统；调用pthread_exit()后线程退出，控制权交给主线程。 进程间通信Linux几乎支持全部UNIX进程间通信方法，包括管道（有名管道和无名管道）、消息队列、共享内存、信号量和套接字。其中前四个属于同一台机器下进程间的通信，套接字则是用于网络通信。 管道 无名管道 无名管道特点： 无名管道是一种特殊的文件，这种文件只存在于内存中。 无名管道只能用于父子进程或兄弟进程之间，必须用于具有亲缘关系的进程间的通信。 无名管道只能由一端向另一端发送数据，是半双工方式，如果双方需要同时收发数据需要两个管道。 相关接口： int pipe(int fd[2]); fd[2]：管道两端用fd[0]和fd[1]来描述，读的一端用fd[0]表示，写的一端用fd[1]表示。通信双方的进程中写数据的一方需要把fd[0]先close掉，读的一方需要先把fd[1]给close掉。 有名管道： 有名管道特点： 有名管道是FIFO文件，存在于文件系统中，可以通过文件路径名来指出。 无名管道可以在不具有亲缘关系的进程间进行通信。 相关接口： int mkfifo(const char *pathname, mode_t mode); pathname：即将创建的FIFO文件路径，如果文件存在需要先删除。 mode：和open()中的参数相同。 消息队列 共享内存 进程可以将同一段共享内存连接到它们自己的地址空间，所有进程都可以访问共享内存中的地址，如果某个进程向共享内存内写入数据，所做的改动将立即影响到可以访问该共享内存的其他所有进程。 相关接口 创建共享内存：int shmget(key_t key, int size, int flag); 成功时返回一个和key相关的共享内存标识符，失败范湖范围-1。 key：为共享内存段命名，多个共享同一片内存的进程使用同一个key。 size：共享内存容量。 flag：权限标志位，和open的mode参数一样。 连接到共享内存地址空间：void *shmat(int shmid, void *addr, int flag); 返回值即共享内存实际地址。 shmid：shmget()返回的标识。 addr：决定以什么方式连接地址。 flag：访问模式。 从共享内存分离：int shmdt(const void *shmaddr); 调用成功返回0，失败返回-1。 shmaddr：是shmat()返回的地址指针。 其他补充 共享内存的方式像极了多线程中线程对全局变量的访问，大家都对等地有权去修改这块内存的值，这就导致在多进程并发下，最终结果是不可预期的。所以对这块临界区的访问需要通过信号量来进行进程同步。 但共享内存的优势也很明显，首先可以通过共享内存进行通信的进程不需要像无名管道一样需要通信的进程间有亲缘关系。其次内存共享的速度也比较快，不存在读取文件、消息传递等过程，只需要到相应映射到的内存地址直接读写数据即可。 信号量 在提到共享内存方式时也提到，进程共享内存和多线程共享全局变量非常相似。所以在使用内存共享的方式是也需要通过信号量来完成进程间同步。多线程同步的信号量是POSIX信号量，而在进程里使用SYSTEM V信号量。 相关接口 创建信号量：int semget(key_t key, int nsems, int semflag); 创建成功返回信号量标识符，失败返回-1。 key：进程pid。 nsems：创建信号量的个数。 semflag：指定信号量读写权限。 改变信号量值：int semop(int semid, struct sembuf *sops, unsigned nsops); 我们所需要做的主要工作就是串讲sembuf变量并设置其值，然后调用semop，把设置好的sembuf变量传递进去。 struct sembuf结构体定义如下： 12345struct sembuf&#123; short sem_num; short sem_op; short sem_flg;&#125;; 成功返回信号量标识符，失败返回-1。 semid：信号量集标识符，由semget()函数返回。 sops：指向struct sembuf结构的指针，先设置好sembuf值再通过指针传递。 nsops：进行操作信号量的个数，即sops结构变量的个数，需大于或等于1。最常见设置此值等于1，只完成对一个信号量的操作。 直接控制信号量信息：int semctl(int semid, int semnum, int cmd, union semun arg); semid：信号量集标识符。 semnum：信号量集数组上的下标，表示某一个信号量。 arg：union semun类型。 辅助命令 ipcs命令用于报告共享内存、信号量和消息队列信息。 ipcs -a：列出共享内存、信号量和消息队列信息。 ipcs -l：列出系统限额。 ipcs -u：列出当前使用情况。 套接字 详见socket交互流程 详见网络I/O模型 同步互斥机制 待补充 网络I/O模型在描述这块内容的诸多书籍中，很多都只说笼统的概念，我们将问题具体化，暂时只考虑服务器端的网络I/O情形。我们假定目前的情形是服务器已经在监听用户请求，建立连接后服务器调用read()函数等待读取用户发送过来的数据流，之后将接收到的数据打印出来。 所以服务器端简单是这样的流程：建立连接 -&gt; 监听请求 -&gt; 等待用户数据 -&gt; 打印数据。我们总结网络通信中的等待： 建立连接时等待对方的ACK包（TCP）。 等待客户端请求（HTTP）。 输入等待：服务器用户数据到达内核缓冲区（read函数等待）。 输出等待：用户端等待缓冲区有足够空间可以输入（write函数等待）。 另外为了能够解释清楚网络I/O模型，还需要了解一些基础。对服务器而言，打印出用户输入的字符串（printf函数）和从网络中获取数据（read函数）需要单独来看。服务器首先accept用户连接请求后首先调用read函数等待数据，这里的read函数是系统调用，运行于内核态，使用的也是内核地址空间，并且从网络中取得的数据需要先写入到内核缓冲区。当read系统调用获取到数据后将这些数据再复制到用户地址空间的用户缓冲区中，之后返回到用户态执行printf函数打印字符串。我们需要明确两点： read执行在内核态且数据流先读入内核缓冲区；printf运行于用户态，打印的数据会先从内核缓冲区复制到进程的用户缓冲区，之后打印出来。 printf函数一定是在read函数已经准备好数据之后才能执行，但read函数作为I/O操作通常需要等待而触发阻塞。调用read函数的是服务器进程，一旦被read调用阻塞，整个服务器在获取到用户数据前都不能接受任何其他用户的请求（单进程/线程）。 有了上面的基础，我们就可以介绍下面四种网路I/O模型。 阻塞式 阻塞表示一旦调用I/O函数必须等整个I/O完成才返回。正如上面提到的那种情形，当服务器调用了read函数之后，如果不是立即接收到数据，服务器进程会被阻塞，之后一直在等待用户数据到达，用户数据到达后首先会写进内核缓冲区，之后内核缓冲区数据复制到用户进程（服务器进程）缓冲区。完成了上述所有的工作后，才会把执行权限返回给用户（从内核态 -&gt; 用户态）。 很显然，阻塞式I/O的效率实在太低，如果用户输入数据迟迟不到的话，整个服务器就会一直被阻塞（单进程/线程）。为了不影响服务器接收其他进程的连接，我们可以考虑多进程模型，这样当服务器建立连接后为连接的用户创建新线程，新线程即使是使用阻塞式I/O也仅仅是这一个线程被阻塞，不会影响服务器等待接收新的连接。 多线程模型下，主线程等待用户请求，用户有请求到达时创建新线程。新线程负责具体的工作，即使是因为调用了read函数被阻塞也不会影响服务器。我们还可以进一步优化创建连接池和线程池以减小频繁调用I/O接口的开销。但新问题随之产生，每个新线程或者进程（加入使用对进程模型）都会占用大量系统资源，除此之外过多的线程和进程在调度方面开销也会大很对，所以这种模型并不适合大并发量。 非阻塞I/O 阻塞和非阻塞最大的区别在于调用I/O系统调用后，是等整个I/O过程完成再把操作权限返回给用户还是会立即返回。 可以使用以下语句将句柄fd设置为非阻塞I/O：fcntl(fd, F_SETFL, O_NONBLOCK); 非阻塞I/O在调用后会立即返回，用户进程对返回的返回值判断以区分是否完成了I/O。如果返回大于0表示完成了数据读取，返回值即读取的字节数；返回0表示连接已经正常断开；返回-1表示错误，接下来用户进程会不停地询问kernel是否准备完毕。 非阻塞I/O虽然不再会完全阻塞用户进程，但实际上由于用户进程需要不停地询问kernel是否准备完数据，所以整体效率依旧非常低，不适合做并发。 I/O多路复用（事件驱动模型） 前面已经论述了多进程、多进程模型会因为开销巨大和调度困难而导致并不能承受高并发量。但不适用这种模型的话，无论是阻塞还是非阻塞方式都会导致整个服务器停滞。 所以对于大并发量，我们需要一种代理模型可以帮助我们集中去管理所有的socket连接，一旦某个socket数据到达了就执行其对应的用户进程，I/O多路复用就是这么一种模型。Linux下I/O多路复用的系统调用有select，poll和epoll，但从本质上来讲他们都是同步I/O范畴。 select 相关接口： int select (int maxfd, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout); FD_ZERO(int fd, fd_set* fds) //清空集合 FD_SET(int fd, fd_set* fds) //将给定的描述符加入集合 FD_ISSET(int fd, fd_set* fds) //将给定的描述符从文件中删除 FD_CLR(int fd, fd_set* fds) //判断指定描述符是否在集合中 参数： maxfd：当前最大文件描述符的值+1（≠ MAX_CONN）。 readfds：指向读文件队列集合（fd_set）的指针。 writefds：同上，指向读集合的指针。 writefds：同上，指向错误集合的指针。 timeout：指向timeval结构指针，用于设置超时。 其他： 判断和操作对象为set_fd集合，集合大小为单个进程可打开的最大文件数1024或2048（可重新编译内核修改但不建议）。 poll 相关接口： int poll(struct pollfd *fds, unsigned int nfds, int timeout); 结构体定义： struct pollfd{ int fd; // 文件描述符 short events; // 等到的事件 short revents; // 实际发生的事件 } 参数： fds：指向pollfd结构体数组的指针。 nfds：pollfd数组当前已被使用的最大下标。 timeout：等待毫秒数。 其他： 判断和操作对象是元素为pollfd类型的数组，数组大小自己设定，即为最大连接数。 epoll 相关接口： int epoll_create(int size); // 创建epoll句柄 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); // 事件注册函数 int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 结构体定义： struct epoll_event{ __uint32_t events; epoll_data_t data; }; typedef union epoll_data{ void *ptr; int fd; __uint32_t u32; __uint64_t u64; }epoll_data_t; 参数： size：用来告诉内核要监听的数目。 epfd：epoll函数的返回值。 op：表示动作（EPOLL_CTL_ADD/EPOLL_CTL_FD/EPOLL_CTL_DEL）。 fd：需要监听的fd。 events：指向epoll_event的指针，该结构记录监听的事件。 maxevents：告诉内核events的大小。 timeout：超时时间（ms为单位，0表示立即返回，-1将不确定）。 select、poll和epoll区别 操作方式及效率： select是遍历，需要遍历fd_set每一个比特位（= MAX_CONN），O(n)；poll是遍历，但只遍历到pollfd数组当前已使用的最大下标（≠ MAX_CONN），O(n)；epoll是回调，O(1)。 最大连接数： select为1024/2048（一个进程打开的文件数是有限制的）；poll无上限；epoll无上限。 fd拷贝： select每次都需要把fd集合从用户态拷贝到内核态；poll每次都需要把fd集合从用户态拷贝到内核态；epoll调用epoll_ctl时拷贝进内核并放到事件表中，但用户进程和内核通过mmap映射共享同一块存储，避免了fd从内核赋值到用户空间。 其他： select每次内核仅仅是通知有消息到了需要处理，具体是哪一个需要遍历所有的描述符才能找到。epoll不仅通知有I/O到来还可通过callback函数具体定位到活跃的socket，实现伪AIO。 异步I/O模型 上面三种I/O方式均属于同步I/O。 从阻塞式I/O到非阻塞I/O，我们已经做到了调用I/O请求后立即返回，但不停轮询的操作效率又很低，如果能够既像非阻塞I/O能够立即返回又能不一直轮询的话会更符合我们的预期。 之所以用户进程会不停轮询就是因为在数据准备完毕后内核不会回调用户进程，只能通过用户进程一次又一次轮询来查询I/O结果。如果内核能够在完成I/O后通过消息告知用户进程来处理已经得到的数据自然是最好的，异步I/O就是这么回事。 异步I/O就是当用户进程发起I/O请求后立即返回，直到内核发送一个信号，告知进程I/O已完成，在整个过程中，都没有进程被阻塞。看上去异步I/O和非阻塞I/O的区别在于：判断数据是否准备完毕的任务从用户进程本身被委托给内核来完成。这里所谓的异步只是操作系统提供的一直机制罢了。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海量数据处理]]></title>
    <url>%2F2019%2F04%2F15%2F%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[海量数据处理TOP N问题 如何在海量数据中找出重复最多一个。 通过hash映射为小文件 通过hash_map统计各个小文件重读最多的并记录次数 对每个小文件重复最多的进行建立大根堆 上亿有重数据，统计最多前N个。 内存存不下 通过hash映射为小文件 通过hash_map统计各个小文件重读最多的并记录次数 对每个小文件重复最多的进行建立大根堆并重复N次取走堆顶并重建堆操作 内存存得下 直接内存通过hash_map统计并建大根堆 重复N次取走堆顶并重建堆操作 海量日志数据，提取出某日访问百度次数最多的那个IP（同1）。 将IP % 1000映射到1000个小文件中 相同IP会被映射到同一个文件 不会出现累加和更大情况 分1000次在内存处理小文件，得到频率最大IP（使用map统计） 对这1000个IP建立大根堆 1000w查询串统计最热门10个（同2）。 同上 1G的文件，里面1行1个不超过16字节的词。内存限制1M，返回频数最高前100（同2）。 将单词 % 5000存入5000小文件 平均各文件约200K 对超过1M的文件继续分割直到小于200K 使用map统计各个词出现的频率 对5000词使用堆排序或归并排序 分布式TOP N问题 分布在100台电脑的海量数据，统计前十。 各数据只出现在一台机器中 先在独立机器得到前十 若可以放入内存直接堆排序 若不可全放入内存：哈希分块 -&gt; map统计 -&gt; 归总堆排 再将100台计算机的TOP10组合起来堆排序 同一元素可同时出现在不同机器中 遍历所有数据，重新hash取模，使同一个元素只出现在单独的一台电脑中，然后采用上面方法先统计每台电脑TOP10再汇总起来 快速外排序问题 有10个1G文件，每行都是一个可重复用户query，按query频度排序。 顺序读取十个文件并采取哈希，将query写入10个文件中 通过hash_map(query, count)统计每个query出现次数，至少2G内存 通过得到的hash_map中query和query_count，对query_count排序并将重新输出到文件中，得到已排序好的文件 对十个文件进行归并排序（外排序） 公共数据问题 A,B两个文件各存放50亿url，每个为64Byte，限制内存4G找出公共url。 对A和B两个大文件，先通过url % 1000将数据映射到1000个文件中，单个文件大小约320M（我们只需要检查对应小文件A1 V B1……，不对应小文件不会有相同url） 通过hash_set统计，把A1的url存储到hash_set中，再遍历对应的B1小文件，检查是否在hash_set中，若存在则写入外存。重复循环处理对应的1000个对。 1000w有重字符串，对字符串去重。 先hash分为多个文件 逐个文件检查并插入set中 多个set取交集 内存内TOP N问题 100w个数字找出最大100个。 堆排序法 建大根堆，取走堆顶并重建堆，重复100次 快排法 使用快速排序划分，若某次枢纽元在后10000时（具体情况具体分析），对后10000数据排序后取前100 位图法 在2.5亿数字中找出不重复的整数。 使用2-Bit位图法，00表示不存在，01表示出现一次，10表示出现多次，11无意义。这样只需要1G内存。 或者hash划分小文件，小文件使用hash_set检查各个元素，得到的。 如何在40亿数字中快速判断是否有某个数？ 位图法标记某个数字是否存在，check标记数组。]]></content>
      <categories>
        <category>Summary</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试]]></title>
    <url>%2F2019%2F04%2F15%2F%E7%AC%94%E8%AF%95%2F</url>
    <content type="text"></content>
      <categories>
        <category>Kaaier</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++知识点积累]]></title>
    <url>%2F2019%2F04%2F15%2F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80C%2B%2B%2F</url>
    <content type="text"><![CDATA[编程语言(C/C++) 都是语言，为什么英语比C++难这么多呢？ 目录 Chapter 1 Chapter 2 Chapter 3 Chapter 4 编程基础 面向对象基础 标准模板库 编译及调试 内容编程基础C/C++的内容又多又杂，常常看到有人罗列相关书单，觉得毫无意义，我不相信他们真的完全掌握了其中任何一本。学习任何东西，首先要掌握基本概念，基础不牢地动山摇，因为高级的内容都是通过低级的概念来描述的。当基本概念都没理解透，学习再多都是空中楼阁。这里罗列了一些听基本的问题，虽然看着不难，但是精确理解每句话中的每个词真的并不容易。 变量声明和定义区别？ 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。 相同变量可以再多处声明（外部变量extern），但只能在一处定义。 “零值比较”？ bool类型：if(flag) int类型：if(flag == 0) 指针类型：if(flag == null) float类型：if((flag &gt;= -0.000001) &amp;&amp; (flag &lt;= 0. 000001)) strlen和sizeof区别？ sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。 sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\0’的字符串。 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。 同一不同对象可以互相赋值吗？ 可以，但含有指针成员时需要注意。 对比类的对象赋值时深拷贝和浅拷贝。 结构体内存对齐问题？ 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。 未特殊说明时，按结构体中size最大的成员对齐（若有double成员），按8字节对齐。 static作用是什么？在C和C++中有何区别？ static可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量存储位置在静态区。对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义；对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；修饰函数时作用和修饰全局变量相同，都是为了限定访问域。 C++的static除了上述两种用途，还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。 static的数据记忆性可以满足函数在不同调用期的通信，也可以满足同一个类的多个实例间的通信。 未初始化时，static变量默认值为0。 结构体和类的区别？ 结构体的默认限定符是public；类是private。 结构体不可以继承，类可以。 C++中结构体也可以继承。 malloc和new的区别？ malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。 malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。 malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。 指针和引用区别？ 引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &amp;varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。 宏定义和函数有何区别？ 宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。 宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。 宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。 宏函数不要在最后加分号。 宏定义和const区别？ 宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。 宏不检查类型；const会检查数据类型。 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。 宏定义和typedef区别？ 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。 宏不检查类型；typedef会检查数据类型。 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。 宏定义和内联函数(inline)区别？ 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。 内联函数本身是函数，强调函数特性，具有重载等功能。 内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。 条件编译#ifdef, #else, #endif作用？ 可以通过加#define，并通过#ifdef来判断，将某些具体模块包括进要编译的内容。 用于子程序前加#define DEBUG用于程序调试。 应对硬件的设置（机器类型等）。 条件编译功能if也可实现，但条件编译可以减少被编译语句，从而减少目标程序大小。 区别以下几种变量？ const int a; int const a; const int *a; int *const a; int const a和const int a均表示定义常量类型a。 const int a，其中a为指向int型变量的指针，const在 * 左侧，表示a指向不可变常量。(看成const (a)，对引用加const) int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const) volatile有什么作用？ volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。 多线程中被几个任务共享的变量需要定义为volatile类型。 什么是常引用？ 常引用可以理解为常量指针，形式为const typename &amp; refname = varname。 常引用下，原变量值不会被别名所修改。 原变量的值可以通过原名修改。 常引用通常用作只读变量别名或是形参传递。 区别以下指针类型？ int *p[10] int (*p)[10] int *p(int) int (*p)(int) int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。 int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。 int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。 int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。 常量指针和指针常量区别？ 常量指针是一个指针，读成常量的指针，指向一个只读变量。如int const *p或const int *p。 指针常量是一个不能给改变指向的指针。如int *const p。 a和&amp;a有什么区别？ 假设数组int a[10]; int (*p)[10] = &amp;a; a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。 &amp;a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。 若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。 数组名和指针（这里为指向数组首元素的指针）区别？ 二者均可通过增减偏移量来访问数组中的元素。 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。 野指针是什么？ 也叫空悬指针，不是指向null的指针，是指向垃圾内存的指针。 产生原因及解决办法： 指针变量未及时初始化 =&gt; 定义指针变量及时初始化，要么置空。 指针free或delete之后没有及时置空 =&gt; 释放操作后立即置空。 堆和栈的区别？ 申请方式不同。 栈由系统自动分配。 堆由程序员手动分配。 申请大小限制不同。 栈顶和栈底是之前预设好的，大小固定，可以通过ulimit -a查看，由ulimit -s修改。 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。 申请效率不同。 栈由系统分配，速度快，不会有碎片。 堆由程序员分配，速度慢，且会有碎片。 delete和delete[]区别？ delete只会调用一次析构函数。 delete[]会调用数组中每个元素的析构函数。 面向对象基础能够准确理解下面这些问题是从C程序员向C++程序员进阶的基础。当然了，这只是一部分。 面向对象三大特性？ 封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。 继承性：让某种类型对象获得另一个类型对象的属性和方法。 多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。 public/protected/private的区别？ public的变量和函数在类的内部外部都可以访问。 protected的变量和函数只能在类的内部和其派生类中访问。 private修饰的元素只能在类内访问。 对象存储空间？ 非静态成员的数据类型大小之和。 编译器加入的额外成员变量（如指向虚函数表的指针）。 为了边缘对齐优化加入的panding。 C++空类有哪些成员函数? 首先，空类大小为1字节。 默认函数有： 构造函数 析构函数 拷贝构造函数 赋值运算符 构造函数能否为虚函数，析构函数呢？ 析构函数： 析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。 只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。 析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。 构造函数： 构造函数不能定义为虚函数，不仅如此，构造函数中还不能调用虚函数。因为那样实际执行的是父类对应的函数，因为自己还没有构造好（构造顺序先基类再派生类）。 构造函数调用顺序，析构函数呢？ 基类的构造函数：如果有多个基类，先调用纵向上最上层基类构造函数，如果横向继承了多个类，调用顺序为派生表从左到右顺序。 成员类对象的构造函数：如果类的变量中包含其他类（类的组合），需要在调用本类构造函数前先调用成员类对象的构造函数，调用顺序遵照在类中被声明的顺序。 派生类的构造函数。 析构函数与之相反。 拷贝构造函数中深拷贝和浅拷贝区别？ 深拷贝时，当被拷贝对象存在动态分配的存储空间时，需要先动态申请一块存储空间，然后逐字节拷贝内容。 浅拷贝仅仅是拷贝指针字面值。 当使用浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针。因为所指向的内存空间已经被释放了。 拷贝构造函数和赋值运算符重载的区别？ 拷贝构造函数是函数，赋值运算符是运算符重载。 拷贝构造函数会生成新的类对象，赋值运算符不能。 拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。 形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现”=”的地方都是使用赋值运算符，如下： Student s; Student s1 = s; // 调用拷贝构造函数 Student s2; s2 = s; // 赋值运算符操作 注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符 虚函数和纯虚函数区别？ 虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。 纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。 覆盖、重载和隐藏的区别？ 覆盖是派生类中重新定义的函数，其函数名、参数列表（个数、类型和顺序）、返回值类型和父类完全相同，只有函数体有区别。派生类虽然继承了基类的同名函数，但用派生类对象调用该函数时会根据对象类型调用相应的函数。覆盖只能发生在类的成员函数中。 隐藏是指派生类函数屏蔽了与其同名的函数，这里仅要求基类和派生类函数同名即可。其他状态同覆盖。可以说隐藏比覆盖涵盖的范围更宽泛，毕竟参数不加限定。 重载是具有相同函数名但参数列表不同（个数、类型或顺序）的两个函数（不关心返回值），当调用函数时根据传递的参数列表来确定具体调用哪个函数。重载可以是同一个类的成员函数也可以是类外函数。 在main执行之前执行的代码可能是什么？ 全局对象的构造函数。 哪几种情况必须用到初始化成员列表？ 初始化一个const成员。 初始化一个reference成员。 调用一个基类的构造函数，而该函数有一组参数。 调用一个数据成员对象的构造函数，而该函数有一组参数。 什么是虚指针？ 虚指针或虚函数指针是虚函数的实现细节。 虚指针指向虚表结构。 重载和函数模板的区别？ 重载需要多个函数，这些函数彼此之间函数名相同，但参数列表中参数数量和类型不同。在区分各个重载函数时我们并不关心函数体。 模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表。但只适用于参个数相同而类型不同的函数。 this指针是什么？ this指针是类的指针，指向对象的首地址。 this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。 this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。 类模板是什么？ 用于解决多个功能相同、数据类型不同的类需要重复定义的问题。 在建立类时候使用template及任意类型标识符T，之后在建立类对象时，会指定实际的类型，这样才会是一个实际的对象。 类模板是对一批仅数据成员类型不同的类的抽象，只要为这一批类创建一个类模板，即给出一套程序代码，就可以用来生成具体的类。 构造函数和析构函数调用时机？ 全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数。 局部自动对象：建立对象时调用构造函数，函数结束时调用析构函数。 动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数。 静态局部变量对象：建立时调用一次构造函数，主函数结束时调用析构函数。 标准模板库STL内容虽然看起来很多，单独成书都不是问题（《STL源码剖析》），但从实际使用状况来看，我认为只需要知道以下几点就可以了： 怎么用？ 各种STL基本的增删改查怎么使用。每种容器都提供了很多操作，但实际增删改查我们通常只需要掌握透彻一种方式即可。有些功能只是出于通用性考虑才存在的，但对于相应的STL这些操作完全可以忽略。所以我对STL使用的看法是，不需要花太多时间去了解所有功能，只要掌握最基本的即可，要把精力放在对需求的了解并选择适合的数据结构。 怎么实现？ 本身STL就是封装了我们常用的数据结构，所以最先需要了解每种数据结构的特性。而且了解实现方式对我们能够准确、高效使用STL打下了基础。 如何避免错误？ 在第二阶段了解了STL的实现之后，我们已经可以很清楚地知道他们底层使用的是什么数据结构以及该数据结构做什么操作比较高效。但还有一点需要注意的就是怎么才能用对他们，避免一些未知的错误，比如迭代器失效问题。 string vector 用法： 定义： vector&lt;T&gt; vec; 插入元素： vec.push_back(element); vec.insert(iterator, element); 删除元素： vec.pop_back(); vec.erase(iterator); 修改元素： vec[position] = element; 遍历容器： for(auto it = vec.begin(); it != vec.end(); ++it) {......} 其他： vec.empty(); //判断是否空 vec.size(); // 实际元素 vec.capacity(); // 容器容量 vec.begin(); // 获得首迭代器 vec.end(); // 获得尾迭代器 vec.clear(); // 清空实现： 模拟Vector实现 线性表，数组实现。 支持随机访问。 插入删除操作需要大量移动数据。 需要连续的物理存储空间。 每当大小不够时，重新分配内存（*2），并复制原内容。 错误避免： 迭代器失效 插入元素 尾后插入：size &lt; capacity时，首迭代器不失效尾迭代实现（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。 中间插入：size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效。 删除元素 尾后删除：只有尾迭代失效。 中间删除：删除位置之后所有迭代失效。 map 用法： 定义： map&lt;T_key, T_value&gt; mymap; 插入元素： mymap.insert(pair&lt;T_key, T_value&gt;(key, value)); // 同key不插入 mymap.insert(map&lt;T_key, T_value&gt;::value_type(key, value)); // 同key不插入 mymap[key] = value; // 同key覆盖 删除元素： mymap.erase(key); // 按值删 mymap.erase(iterator); // 按迭代器删 修改元素： mymap[key] = new_value; 遍历容器： for(auto it = mymap.begin(); it != mymap.end(); ++it) { cout &lt;&lt; it-&gt;first &lt;&lt; &quot; =&gt; &quot; &lt;&lt; it-&gt;second &lt;&lt; &apos;\n&apos;; }实现： RBTree实现 树状结构，RBTree实现。 插入删除不需要数据复制。 操作复杂度仅跟树高有关。 RBTree本身也是二叉排序树的一种，key值有序，且唯一。 必须保证key可排序。 基于红黑树实现的map结构（实际上是map, set, multimap，multiset底层均是红黑树），不仅增删数据时不需要移动数据，其所有操作都可以在O(logn)时间范围内完成。另外，基于红黑树的map在通过迭代器遍历时，得到的是key按序排列后的结果，这点特性在很多操作中非常方便。 面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的。 它是二叉排序树（继承二叉排序树特显）： 若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。 左、右子树也分别为二叉排序树。 它满足如下几点要求： 树中所有节点非红即黑。 根节点必为黑节点。 红节点的子节点必为黑（黑节点子节点可为黑）。 从根到NULL的任何路径上黑结点数相同。 查找时间一定可以控制在O(logn)。 红黑树的节点定义如下： 12345678910enum Color &#123; RED = 0, BLACK = 1&#125;;struct RBTreeNode &#123; struct RBTreeNode*left, *right, *parent; int key; int data; Color color;&#125;; 所以对红黑树的操作需要满足两点：1.满足二叉排序树的要求；2.满足红黑树自身要求。通常在找到节点通过和根节点比较找到插入位置之后，还需要结合红黑树自身限制条件对子树进行左旋和右旋。 相比于AVL树，红黑树平衡性要稍微差一些，不过创建红黑树时所需的旋转操作也会少很多。相比于最简单的BST，BST最差情况下查找的时间复杂度会上升至O(n)，而红黑树最坏情况下查找效率依旧是O(logn)。所以说红黑树之所以能够在STL及Linux内核中被广泛应用就是因为其折中了两种方案，既减少了树高，又减少了建树时旋转的次数。 从红黑树的定义来看，红黑树从根到NULL的每条路径拥有相同的黑节点数（假设为n），所以最短的路径长度为n（全为黑节点情况）。因为红节点不能连续出现，所以路径最长的情况就是插入最多的红色节点，在黑节点数一致的情况下，最可观的情况就是黑红黑红排列……最长路径不会大于2n，这里路径长就是树高。 set 编译及调试编译 预处理 展开所有的宏定义，完成字符常量替换。 处理条件编译语句，通过是否具有某个宏来决定过滤掉哪些代码。 处理#include指令，将被包含的文件插入到该指令所在位置。 过滤掉所有注释语句。 添加行号和文件名标识。 保留所有#pragma编译器指令。 编译 词法分析。 语法分析。 语义分析。 中间语言生成。 目标代码生成与优化。 链接 各个源代码模块独立的被编译，然后将他们组装起来成为一个整体，组装的过程就是链接。被链接的各个部分本本身就是二进制文件，所以在被链接时需要将所有目标文件的代码段拼接在一起，然后将所有对符号地址的引用加以修正。 静态链接 静态链接最简单的情况就是在编译时和静态库链接在一起成为完整的可执行程序。这里所说的静态库就是对多个目标文件（.o）文件的打包，通常静态链接的包名为lib****.a，静态链接所有被用到的目标文件都会复制到最终生成的可执行目标文件中。这种方式的好处是在运行时，可执行目标文件已经完全装载完毕，只要按指令序执行即可，速度比较快，但缺点也有很多，在讲动态链接时会比较一下。 既然静态链接是对目标文件的打包，这里介绍些打包命令。 gcc -c test1.c // 生成test1.o gcc -c test2.c // 生成test2.c ar cr libtest.a test1.o test2.o 首先编译得到test1.o和test2.o两个目标文件，之后通过ar命令将这两个文件打包为.a文件，文件名格式为lib + 静态库名 + .a后缀。在生成可执行文件需要使用到它的时候只需要在编译时加上即可。需要注意的是，使用静态库时加在最后的名字不是libtest.a，而是l + 静态库名。 gcc -o main main.c -ltest 动态链接 静态链接发生于编译阶段，加载至内存前已经完整，但缺点是如果多个程序都需要使用某个静态库，则该静态库会在每个程序中都拷贝一份，非常浪费内存资源，所以出现了动态链接的方式来解决这个问题。 动态链接在形式上倒是和静态链接非常相似，首先也是需要打包，打包成动态库，不过文件名格式为lib + 动态库名 + .so后缀。不过动态库的打包不需要使用ar命令，gcc就可以完成，但要注意在编译时要加上-fPIC选项，打包时加上-shared选项。 gcc -fPIC -c test1.c gcc -fPIC -c test2.c gcc -shared test1.o test2.o -o libtest.so 使用动态链接的用法也和静态链接相同。 gcc -o main main.c -ltest 如果仅仅像上面的步骤是没有办法正常使用库的，我们可以通过加-Lpath指定搜索库文件的目录（-L.表示当前目录），默认情况下会到环境变量LD_LIBRARY_PATH指定的目录下搜索库文件，默认情况是/usr/lib，我们可以将库文件拷贝到那个目录下再链接。 比较静态库和动态库我们可以得到二者的优缺点。 动态库运行时会先检查内存中是否已经有该库的拷贝，若有则共享拷贝，否则重新加载动态库（C语言的标准库就是动态库）。静态库则是每次在编译阶段都将静态库文件打包进去，当某个库被多次引用到时，内存中会有多份副本，浪费资源。 动态库另一个有点就是更新很容易，当库发生变化时，如果接口没变只需要用新的动态库替换掉就可以了。但是如果是静态库的话就需要重新被编译。 不过静态库也有优点，主要就是静态库一次性完成了所有内容的绑定，运行时就不必再去考虑链接的问题了，执行效率会稍微高一些。 makefile编写 对于大的工程通常涉及很多头文件和源文件，编译起来很很麻烦，makefile正是为了自动化编译产生的，makefile像是编译说明书，指示编译的步骤和条件，之后被make命令解释。 基本规则 A:B (tab)&lt;command&gt; 其中A是语句最后生成的文件，B是生成A所依赖的文件，比如生成test.o依赖于test.c和test.h，则写成test.o:test.c test.h。接下来一行的开头必须是tab，再往下就是实际的命令了，比如gcc -c test.c -o test.o。 变量 makefile的书写非常像shell脚本，可以在文件中定义”变量名 = 变量值”的形式，之后需要使用这个变量时只需要写一个$符号加上变量名即可，当然，和shell一样，最好用()包裹起语句来。 链接 符号解析 可重定位目标文件 对于独立编译的可重定位目标文件，其ELF文件格式包括ELF头（指定文件大小及字节序）、.text（代码段）、.rodata（只读数据区）、.data（已初始化数据区）、.bss（未初始化全局变量）、.symtab（符号表）等，其中链接时最需要关注的就是符号表。每个可重定位目标文件都有一张符号表，它包含该模块定义和引用的符号的信息，简而言之就是我们在每个模块中定义和引用的全局变量（包括定义在本模块的全局变量、静态全局变量和引用自定义在其他模块的全局变量）需要通过一张表来记录，在链接时通过查表将各个独立的目标文件合并成一个完整的可执行文件。 解析符号表 解析符号引用的目的是将每个引用与可重定位目标文件的符号表中的一个符号定义联系起来。 重定位 合并节 多个可重定位目标文件中相同的节合并成一个完整的聚合节，比如多个目标文件的.data节合并成可执行文件的.data节。链接器将运行时存储地址赋予每个节，完成这步每条指令和全局变量都有运行时地址了。 重定位符号引用 这步修改全部代码节和数据节对每个符号的符号引用，使其指向正确的运行时地址。局部变量可以通过进栈、出栈临时分配，但全局变量（”符号”）的位置则是在各个可重定位目标文件中预留好的。通过上一步合并节操作后，指令中所有涉及符号的引用都会通过一定的寻址方式来定位该符号，比如相对寻址、绝对寻址等。 可执行目标文件 ELF头部 描述文件总体格式，并且包括程序的入口点（entry point），也就是程序运行时执行的第一条指令地址。 段头部表 描述了可执行文件数据段、代码段等各段的大小、虚拟地址、段对齐、执行权限等。实际上通过段头部表描绘了虚拟存储器运行时存储映像，比如每个UNIX程序的代码段总是从虚拟地址Ox0804800开始的。 其他段 和可重定位目标文件各段基本相同，但完成了多个节的合并和重定位工作。 加载 克隆 新程序的执行首先需要通过父进程外壳通过fork得到一个子进程，该子进程除了pid等标识和父进程不同外其他基本均与父进程相同。 重新映射 当子进程执行execve系统调用时会先清空子进程现有的虚拟存储器段（简而言之就是不再映射到父进程的各个段），之后重新创建子进程虚拟存储器各段和可执行目标文件各段的映射。这个阶段我们可以理解为对复制来的父进程页表进程重写，映射到外存中可执行文件的各个段。 虚页调入 加载过程并没有实际将磁盘中可执行文件调入内存，所做的工作紧紧是复制父进程页表、清空旧页表、建立新页表映射工作。之后加载器跳转到入口地址_start开始执行程序，接下来的过程需要配合虚拟存储器来完成。CPU获得指令的虚拟地址后，若包含该指令或数据的页尚未调入内存则将其从外存中调入，调入内存后修改页表得到虚拟页号和物理页号的对应关系。之后重新取同一条指令或数据时因该页已经被调入内存，所以通过虚拟地址得到虚拟页号，虚拟页号通过查页表可以得到物理页号，通过物理页号 + 页内偏移得到具体的物理地址，此时可以通过物理地址取得想要的数据。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures and Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reinforcement Learning Tutorila]]></title>
    <url>%2F2019%2F04%2F15%2FReinforcement-learning%2F</url>
    <content type="text"><![CDATA[Reinforcement Learning Methods and Tutorials转自莫烦大佬强化学习教程，方便自己后期知识巩固。感谢！教程链接 liufuyang’s notebook filesTable of Contents Tutorials Simple entry example Q-learning Sarsa Sarsa(lambda) Deep Q Network (DQN) Using OpenAI Gym Double DQN DQN with Prioitized Experience Replay Dueling DQN Policy Gradients Actor-Critic Deep Deterministic Policy Gradient (DDPG) A3C Dyna-Q Proximal Policy Optimization (PPO) Curiosity Model, Random Network Distillation (RND) Some of my experiments 2D Car Robot arm BipedalWalker LunarLander Some RL NetworksDeep Q Network Double DQN Dueling DQN Actor Critic Deep Deterministic Policy Gradient A3C Proximal Policy Optimization (PPO) Curiosity Model]]></content>
      <categories>
        <category>Deep-Learning</category>
      </categories>
      <tags>
        <tag>Data Structures and Algorithms</tag>
        <tag>Deep-Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow Tutorials]]></title>
    <url>%2F2019%2F03%2F16%2FTensorflow%20Tutorila%2F</url>
    <content type="text"><![CDATA[Tensorflow Tutorials转自莫烦大佬Tensorflow学习教程，方便自己后期知识巩固。感谢！教程链接 liufuyang’s notebook files Tensorflow basic Session Placeholder Variable Activation Build your first network Regression Classification Save and reload Optimizers Tensorboard Dataset Advanced neural network CNN RNN-Classification RNN-Regression AutoEncoder DQN Reinforcement Learning GAN (Generative Adversarial Nets) / Conditional GAN Transfer Learning Others (WIP) Dropout Batch Normalization Visualize Gradient Descent Distributed training Regression Classification CNN RNN Autoencoder GAN (Generative Adversarial Nets) Dropout Batch Normalization Visualize Gradient Descent]]></content>
      <categories>
        <category>Deep-Learning</category>
      </categories>
      <tags>
        <tag>Data Structures and Algorithms</tag>
        <tag>Deep-Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pytorch Tutorila]]></title>
    <url>%2F2019%2F03%2F15%2FPytorch%20Tutorila%2F</url>
    <content type="text"><![CDATA[pyTorch Tutorials转自莫烦大佬Pytorch学习教程，方便自己后期知识巩固。感谢！教程链接 liufuyang’s notebook files pyTorch basic torch and numpy Variable Activation Build your first network Regression Classification An easy way Save and reload Train on batch Optimizers Advanced neural network CNN RNN-Classification RNN-Regression AutoEncoder DQN Reinforcement Learning A3C Reinforcement Learning GAN (Generative Adversarial Nets) / Conditional GAN Others (WIP) Why torch dynamic Train on GPU Dropout Batch Normalization For Chinese speakers: All methods mentioned below have their video and text tutorial in Chinese.Visit 莫烦 Python for more.You can watch my Youtube channel as well. Regression Classification CNN RNN Autoencoder GAN (Generative Adversarial Nets) Dropout Batch Normalization]]></content>
      <categories>
        <category>Deep-Learning</category>
      </categories>
      <tags>
        <tag>Data Structures and Algorithms</tag>
        <tag>Deep-Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题(计算机基础)]]></title>
    <url>%2F2019%2F03%2F14%2F%E7%9C%9F%E9%A2%98%E6%91%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[目录 Chapter 1 Chapter 2 Chapter 3 Tencent NetEase 360 Tencent模拟1Q1 : 题目： 随着IP网络的发展，为了节省可分配的注册IP地址，有一些地址被拿出来用于私有IP地址，以下不属于私有IP地址范围的是： A. 10.6.207.84 B. 172.23.30.28 C. 172.32.50.80 D. 192.168.1.100 答案： C 解答： 1. 私有IP地址共有三个范围段： A: 10.0.0.0~10.255.255.255，即10.0.0.0/8。 B: 172.16.0.0~172.31.255.255，即172.16.0.0/12。 C: 192.168.0.0~192.168.255.255，即192.168.0.0/16。 2. 私有IP在公网上不能使用，但在内网内可以通过NAT技术分配给具体设备，节省IP地址。Q2 : 题目： 下列关于一个类的静态成员的描述中，不正确的是： A. 该类的对象共享其静态成员变量的值 B. 静态成员变量可被该类的所有方法访问 C. 该类的静态方法能访问该类的静态成员变量 D. 该类的静态数据成员变量的值不可修改 答案： D 解答： 1. 类的静态成员和对象无关，和类相关，一个类的所有实例共享同一个静态成员。 2. 静态成员函数不能调用非静态成员。 3. 非静态成员函数可以调用静态成员。 4. 静态成员变量必须初始化，且可以修改。Q3 : 题目： C++将父类的析构函数定义为虚函数，下列正确的是哪个： A. 释放父类指针时能正确释放子类对象 B. 释放子类指针时能正确释放父类对象 C. 这样做是错误的 D. 以上全错 答案： A 解答： 1. 基类通常应定义一个虚析构函数，以确保能正确执行析构函数。 2. 基类指针指向派生类对象，若基类析构函数未声明为虚函数，则只会调用基类析构函数。 3. 基类声明为虚函数，释放指向派生类对象的基类指针时会先调用派生类析构函数，之后调用基类析构函数。Q4 : 题目： 下列哪一个不属于关系数据库的特点： A. 数据冗余度小 B. 数据独立性高 C. 数据共享性好 D. 多用户访问 答案： D 解答： 1. 数据库存在的一个目的就是统一管理数据，减少数据冗余度。 2. 数据独立性，指数据和其管理软件独立，以及数据及其结构的独立。 3. 数据库就是为了方便用户之间共享数据。 4. 数据库中存在锁机制，如果多用户访问可能导致数据不一致等。Q5 : 题目： typedef char *String_t和#define String_d char *这两句在使用上有什么区别？ 答案： 1. typedef char *String_t定义了一个新的类型别名，有类型检查，更安全。发生在编译阶段。 2. #define String_d char *仅仅是做字符串替换，无类型检查。发生在预编译阶段。 3. 用法区别：String_t a, b; String_d c, d; -&gt; char *c, d; a, b ,c是char*类型，而d为char类型。Q6 : 题目： void Func(char str_arg[2]){ int m = sizeof(str_arg); int n = strlen(str_arg); printf(&quot;%d\n&quot;, m); printf(&quot;%d\n&quot;, n); } int main(void){ char str[]=&quot;Hello&quot;; Func(str); } 输出结果为： 答案： 4，5 1. str为定义在main函数中的数组。 2. 数组作为参数传递给函数会退化为指针。 3. sizeof(指针变量) = 指针变量大小，strlen(指针变量) = 指针所指向的字符串长（遇&apos;\0&apos;停止）。Q7 : 题目： 给定一个字符串,求出其最长的重复子串。 答案： 模拟2Q1 : 题目： Internet物理地址和IP地址转换采用什么协议？ 答案： 1. MAC地址 -&gt; IP地址：ARP协议。 2. IP地址 -&gt; MAC地址：RARP协议。Q2 : 题目： static有什么用途？ 答案： 1. 修饰变量： 静态局部变量：只定义一次，程序运行期间一直存在，作用于局限于定义的函数内。多线程中需要加锁保护。 静态全局变量：程序运行期间一直存在，作用域为定义它的源文件。 2. 修饰函数： 一个被声明为静态的函数只可被这一模块内的其它函数调用。Q3 : 题目： 引用与指针有什么区别？ 答案： 1. 指针是个实体，指针的内容是变量地址。引用只是变量别名。 2. 指针可以指向新的变量地址。引用只能在定义时被初始化一次，之后不可变。 3. 指针可以为空。引用不能为空。 4. 指针可以用const修饰，引用不能用const修饰。 5. 获取变量值指针需要解引用。引用不需要解引用。 6. 指针变量需要分配实际内存空间。引用不需要分配内存空间，本身不是变量。 7. 指针的sizeof得到的是指针变量的大小。引用得到的是实际变量的大小。 8. 指针变量++是地址值的增加。引用的++是实际变量值得增加。Q4 : 题目： 全局变量和局部变量在内存中是否有区别？如果有，是什么区别？ 答案： 1. 作用域： 全局变量：具有全局作用域，只需要定义在一个源文件中就可以在所有源文件中使用。不包含变量定义的文件引用时要用extern声明。 局部变量：具有局部作用域，只在函数运行期间存在，函数结束后就被销毁。 2. 生存周期： 全局变量：定义在静态区，与静态变量存储在一起，伴随程序整个生命周期。 局部变量：定义在栈上，函数结束后释放。Q5 : 题目： 什么是平衡二叉树？ 答案： 1. 空树或者左右两棵子树高度差绝对值小于1，且子树递归满足此定义。 2. 最小平衡二叉树节点公式：F(n) = F(n - 1) + F(n - 2) + 1。Q6 : 题目： 堆栈溢出一般是由什么原因导致的？ 答案： 1. 循环的递归调用（每次递归都需要压栈）。 2. 大数据结构的局部变量。Q7 : 题目： 什么函数不能声明为虚函数？ 答案： 1. 构造函数。虚函数主要针对对象而言，而构造函数是在对象创建之前。 2. 内联函数。不能再运行中动态确定其位置。 3. 静态成员函数。全局通用，不受限于具体对象。Q8 : 题目： 写出floatx与“零值”比较的if语句。 答案： 1. if (fabs(x) &lt; 0.00001f)Q9 : 题目： 不能做switch()的参数类型是？ 答案： 1. 只能是char，int，enum。 2. 不能是bool，long，string，float，double。Q10 : 题目： 用户输入M、N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。 答案： 模拟3Q1 : 题目： 写出下列代码的输出内容： int inc(int a){ return(++a); } int multi(int*a, int*b, int*c){ return(*c = *a**b); } typedef int(FUNC1)(int in); typedef int(FUNC2)(int*, int*, int*); void show(FUNC2 fun, int arg1, int*arg2){ FUNC1 *p = &amp;inc; int temp = p(arg1); fun(&amp;temp, &amp;arg1, arg2); printf(&quot;%d\n&quot;, *arg2); } int main(){ int a; show(multi, 10, &amp;a); return 0; } 答案： 110Q2 : 题目： 如何引用一个已经定义过的全局变量? 答案： 1. 用extern重新声明已经在别的模块中定义的全局变量，如果写错变量名将会在链接阶段报错。 2. 引用定义了该全局变量的头文件，如果拼写错误会在编译阶段报错。Q3 : 题目： 语句for(; 1; )有什么问题？它是什么意思？ 答案： 1. 一直循环执行。 2. 此处如果中间是0，则一次不执行。Q4 : 题目： static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？ 答案： 1. static全局变量仅能在定义的源文件中使用，全局变量可以在所有源文件中使用。 2. static局部变量定义于静态区，生命周期为程序整个运行阶段，多次调用函数只定义一次。局部变量定义于栈，调用函数退出即销毁，多次调用多次分配。 3. static函数只能在定义的源文件中使用。普通函数可以在头文件中声明，包含该头文件的源文件均可调用该函数。Q5 : 题目： 请找出下面代码中的所有错误： #include&lt;string.h&gt; int main(){ char*src = &quot;hello,world&quot;; char* dest = NULL; int len = strlen(src); dest = (char*)malloc(len); (1) char* d = dest; char* s = src[len]; (2) while(len-- != 0) (3) d++ = s--; (4) printf(&quot;%s&quot;, dest); return 0; } 答案： 1. 分配的空间要为len + 1，用于存放&apos;\0&apos;。 2. s = &amp;src[len]这里是取地址。 3. 改为while(len-- &gt;= 0)。 4. 改为*d++ = *s--。Q6 : 题目： 搜索引擎的日志要记录所有查询串，有一千万条查询，不重复的不超过三百万，要统计最热门的10条查询。 条件：串内存&lt;1G，字符串长0-255。 给出主要解决思路，算法及其复杂度分析。 答案： 1. 面对的问题有： (1)1G内存不够一次性装入所有数据？ (2)如何去统计每个记录出现次数？ (3)如何快速得到前十的记录？ 2. 解决方式： (1)255约2^8，一百万约2^20，即一百万记录约256MB，一千万约2.6GB。分多次处理。 (2)利用hash统计，定义map，key为string类型日志，value为日志出现次数。 (3)利用大根堆，取top 10，复杂度O(nlogn)。 3. 新问题： 如何划分数据？如何归并结果？ 4. 方案： (1)哈希表常驻内存，大小(255 +4) * 3 * 1000000，约800MB。 (2)分13（200MB * 13 = 2.6GB）次调入日志数据，每次取200MB数据进行hash。 模拟4Q1 : 题目： 考虑函数原型void hello(int a, int b = 7, char* pszC = &quot;*&quot;)，下面的函数调用中，属于不合法调用的是： A. hello(5); B. hello(5, 8); C. hello(6, &quot;#&quot;); D. hello(0, 0, &quot;#&quot;); 答案： C 解答： 1. 参数从左往右依次赋值。 2. 有默认值时，调用函数参数缺失时使用默认值。 3. 参数中字符串会转为指向字符串的指针。Q2 : 题目： 下列程序的运行结果为： #include&lt;iostream&gt; using namespace std; void main(){ int a = 2; int b = ++a; cout &lt;&lt; a / 6 &lt;&lt; endl; } A. 0.5 B. 0 C. 0.7 D. 0.666666 答案： B 解答： 1. 这里的6仅仅是整型数，所以和a进行操作时不存在精度提升。 2. a的值进过++a之后变为3，3 / 6 = 0。Q3 : 题目： #define ADD(x, y) x + y int m = 3; m += m * ADD(m, m); m的值为多少： A. 15 B. 12 C. 18 D. 58 答案： A 解答： 1. 原式 = m + [m * m + m] = 3 + [3 * 3 + 3] = 15 2. 有+=时先算右边部分。 3. 除非出现++m，否则在同一条语句内，变量值不会改变。Q4 : 题目： 下面哪种情况下，B不能隐式转换为A? A. class B:public A{} B. class A:public B{} C. class B{operator A();} D. class A{A(const B&amp;);} 答案： B 解答： 1. 派生类 -&gt; 基类，向上级转换是隐式的，只需要丢弃多余的部分即可，反之基类没有多余的空间存放B独有的变量。 2. C是隐式类型转换操作符。 3. D是拷贝构造函数进行隐式转化。Q5 : 题目： 假设你在编写一个使用多线程技术的程序，当程序中止运行时，需要怎样一个机制来安全有效的中止所有的线程? 答案： 1. 主线程检查是否有子线程在运行。 2. 若有则发起线程退出操作(quit)。 3. wait线程完全停止，delete线程对象。 4. 等待所有线程结束(发出finish信号)，才退出程序。Q6 : 题目： 从程序健壮性进行分析，下面的FillUserInfo函数和main函数分别存在什么问题? #define MAX_NAME_LEN 20 struct USERINFO{ int nAge; char szName[MAX_NAME_LEN]; }; void FillUserInfo(USERINFO *parUserInfo){ stu::cout &lt;&lt; &quot;请输入用户的个数:&quot;; int nCount = 0; std::cin &gt;&gt; nCount; for (int i = 0; i &lt; nCount; i++){ std::cout &lt;&lt; &quot;请输入年龄:&quot;; std::cin &gt;&gt; parUserInfo[i]-&gt;nAge; std::string strName; std::cout &lt;&lt; &quot;请输入姓名:&quot;; std::cin &gt;&gt; strName; strcpy(parUserInfo[i].szName, strName.c_str()); } } int main(int argc, char *argv[]){ USERINFO arUserInfos[100] = {0}; FillUserInfo(arUserInfos); printf(&quot;The first name is:&quot;); printf(arUserInfos[0].szName); printf(&quot;\n&quot;); return 0; } 答案： 模拟5Q1 : 题目： 设某种二叉树有如下特点：每个结点要么是叶子结点，要么有2棵子树。假如一棵这样的二叉树中有m（m &gt; 0）个叶子结点，那么该二叉树上的结点总数为： A. 2m + 1 B. 2m - 1 C. 2(m - 1) D. 2m 答案： B 解答： 1. 关键考点： (1)叶子节点数 = 度为2的节点数 + 1 (2)树的度 = 所有节点度的和 (3)树的节点数 = 树的度 + 1 2. 计算步骤： (1)度为2的节点数 = m - 1 (2)树的度 = m * 0 + 0 * 0 + (m - 1) * 2 = 2m - 2 (3)树的节点数 = (2m - 2) + 1 = 2m - 1Q2 : 题目： 中断响应时间是指： A. 从中断处理开始到中断处理结束所用的时间 B. 从发出中断请求到中断处理结束所用的时间 C. 从发出中断请求到进入中断处理所用的时间 D. 从中断处理结束到再次中断请求的时间 答案： C 解答： 见答案。Q3 : 题目： 试写出“背包题目”的非递归解法。 答案： 模拟6Q1 : 题目： 下推自动识别机的语言是： A. 0型语言 B. 1型语言 C. 2型语言 D. 3型语言 答案： C 解答： 1. 0型文法产生的语言称为0型语言。 2. 1型文法产生的语言称为1型语言，也称作上下文有关语言。 3. 2型文法产生的语言称为2型语言，也称作上下文无关语言。 4. 3型文法产生的语言称为3型语言，也称作正规语言。Q2 : 题目： 浏览器访问某页面，HTTP协议返回状态码为403时表示： A. 找不到该页面 B. 禁止访问 C. 内部服务器访问 D. 服务器繁忙 答案： B 解答： 1. 100-199，指定客服端相应的某些动作 2. 200-299，表示请求成功 3. 300-399，用于已经移动的文件并且包含在定位头信息中指定 4. 400-499，客服端错误 5. 500-599，服务端错误Q3 : 题目： 递归函数最终会结束，那么这个函数一定： A. 使用了局部变量 B. 有一个分支不调用自身 C. 使用了全局变量或者使用了一个或多个参数 D. 没有循环调用 答案： B 解答： 1. 分支不调用自身即函数出口。Q4 : 题目： 编译过程中，语法分析器的任务是： A. 分析单词是怎样构成的 B. 分析单词串是如何构成语言和说明的 C. 分析语句和说明是如何构成程序的 D. 分析程序的结构 答案： B, C, D 解答： 1. 词法分析：词法分析是编译过程的第一个阶段。这个阶段的任务是从左到右的读取每个字符，然后根据构词规则识别单词。词法分析可以用lex等工具自动生成。 2. 语法分析：语法分析是编译过程的一个逻辑阶段。语法分析在词法分析的基础上，将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等。语法分析程序判断程序在结构上是否正确。 3. 语义分析：属于逻辑阶段。对源程序进行上下文有关性质的审查，类型检查。如赋值语句左右端类型匹配问题。Q5 : 题目： 进程进入等待状态有哪几种方式: A. CPU调度给优先级更高的线程 B. 阻塞的线程获得资源或者信号 C. 在时间片轮转的情况下，如果时间片到了 D. 获得spinlock未果 答案： D 解答： 1. A和C均是由从运行态转为就绪状态。 2. B是由阻塞状态转为就绪状态。 3. 自旋锁（spinlock）是一种保护临界区最常见的技术。在同一时刻只能有一个进程获得自旋锁，其他企图获得自旋锁的任何进程将一直进行尝试。Q6 : 题目： 同一进程下的线程可以共享以下： A. stack B. data section C. register set D. file fd 答案： B, D 解答： 1. 线程共享的内容包括： 进程代码段 进程的公有数据 进程打开的文件描述符 信号的处理器 进程的当前目录 进程用户ID与进程组ID 2. 线程独有的内容包括： 线程ID 寄存器组的值 线程的堆栈 错误返回码 线程的信号屏蔽码Q7 : 题目： 设计模式中，属于结构型模式的有哪些： A. 状态模式 B. 装饰模式 C. 代理模式 D. 观察者模式 答案： B, C 解答： 1. 创建型模式： 单例模式 抽象工厂模式 建造者模式 工厂模式 原型模式 2. 结构型模式： 适配器模式 桥接模式 装饰模式 组合模式 外观模式 享元模式 代理模式 3. 行为型模式： 模版方法模式 命令模式 迭代器模式 观察者模式 中介者模式 备忘录模式 解释器模式 状态模式 策略模式 职责链模式 访问者模式Q8 : 题目： Unix系统中，哪些可以用于进程间的通信： A. Socket B. 共享内存 C. 消息队列 D. 信号量 答案： A, B，C，D 解答： 1. Linux进程间通信：管道、信号、消息队列、共享内存、信号量、套接字。 2. Linux线程间通信：互斥量、信号量、条件变量。 3. Windows进程间通信：管道、消息队列、共享内存、信号量、套接字。 3. Windows线程间通信：互斥量、信号量、临界区、事件。Q9 : 题目： 设t是给定的一棵二叉树，下面的递归程序count(t)用于求得： typedef struct node{ int data; struct node *lchild, *rchild; }node; int N2, NL, NR, N0; void count(node *t){ if (t-&gt;lchild != NULL) if (t-&gt;rchild != NULL) N2++; else NL++; else if(t-&gt;rchild != NULL) NR++; else N0++; if(t-&gt;lchild != NULL) count(t-&gt;lchild); if(t-&gt;rchild != NULL) count(t-&gt;rchild); } 答案：Q10 : 题目： 请设计一个排队系统，能够让每个进入队伍的用户都能看到自己在队列中所处的位置和变化，队伍可能随时有人加入和退出；当有人退出影响到用户的位置排名时需要及时反馈到用户。 答案：Q11 : 题目： A、B两个整数集合，设计一个算法求他们的交集，尽可能的高效。 答案： 模拟6Q1 : 题目： 如何减少换页错误： A. 进程倾向于占用CPU B. 访问局部性（locality of reference）满足进程要求 C. 进程倾向于占用I/O D. 使用基于最短剩余时间（shortest remaining time）的调度机制 答案： B 解答： 1. 换页错误又称缺页错误，当一个程序试图访问没有映射到物理内存的地方时，就会出现缺页错误。 2. 减少缺页发生的方法： 增加作业分配的内存块数。 增加页面大小。 页面替换算法。 程序满足局部性原理。Q2 : 题目： 有1000亿条记录，每条记录由url,ip,时间组成，设计一个系统能够快速查询以下内容。 1. 给定url和时间段（精确到分钟）统计url的访问次数。 2. 给定ip和时间段（精确到分钟）统计ip的访问次数。 答案：Q3 : 题目： 给定一个包含了用户query的日志文件，对于输入的任意一个字符串s，输出以s为前缀的在日志中出现频率最高的前10条query。 至少有26台机器，每个机器存储以26个字母开头的query日志文件（机器1以a字母开头的，机器2以b字母开头……）。 各机器维护一张哈希表，每条query在哈希表中存放其地址（哈希地址为链式的），并对其进行排序，按频率由高到低进行排序。 当用户进行搜索时，可以很快定位到某台机器，并根据哈希表，返回出现频率最高的前10条query。 提示： 1. 可以预处理日志。 2. 假设query超过10亿条，每个query不超过50字节。 3. 考虑在大查询量的情况下如何实现分布式服务。 答案： 模拟7Q1 : 题目： 下列哪些http方法对于服务端和用户端一定是安全的？ A. GET B. HEAD C. TRACE D. OPTION E. POST 答案： C 解答：Q2 : 题目： 一个系统，提供多个http协议的接口，返回的结果Y有json格式和jsonp格式。Json的格式为{&quot;code&quot;:100,&quot;msg&quot;:&quot;aaa&quot;}，为了保证该协议变更之后更好的应用到多个接口，为了保证修改协议不影响到原先逻辑的代码，以下哪些设计模式是需要的?协议的变更指的是日后可能返回xml格式，或者是根据需求统一对返回的消息进行过滤。 A. Aadapter B. factory method C. proxy D. decorator E. composite 答案： A, B, D 解答： 模拟8Q1 : 题目： 在数据库系统中，产生不一致的根本原因是： A. 数据存储量太大 B. 没有严格保护数据 C. 未对数据进行完整性控制 D. .数据冗余 答案： 解答：Q2 : 题目： 请问下面的程序一共输出多少个“-”？ int main(void){ int i; for(i = 0; i &lt; 2; i++){ fork(); printf(&quot;-&quot;); } return 0; } A. 2 B. 4 C. 6 D. 8 答案： 解答：Q3 : 题目： 请问下面的程序一共输出多少个“-”？为什么？ #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; int main(void){ int i; for (i = 0; i &lt; 2; i++){ fork(); printf(&quot;-\n&quot;); } return 0; } A. 4 B. 5 C. 6 D. 8 答案： 解答：Q4 : 题目： A. B. C. D. 答案： 解答：Q5 : 题目： A. B. C. D. 答案： 解答： NetEase 360]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Data Structures and Algorithms</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络编程基础]]></title>
    <url>%2F2019%2F02%2F16%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[网络编程基础常见问题Socket API 网络编程一般步骤？ TCP： 服务端：socket -&gt; bind -&gt; listen -&gt; accept -&gt; recv/send -&gt; close。 客户端：socket -&gt; connect -&gt; send/recv -&gt; close。 UDP： 服务端：socket -&gt; bind -&gt; recvfrom/sendto -&gt; close。 客户端：socket -&gt; sendto/recvfrom -&gt; close。 send、sendto区别，recv、recvfrom区别？ TCP/UDP TCP和UDP区别？ TCP面向连接（三次握手），通信前需要先建立连接；UDP面向无连接，通信前不需要连接。 TCP通过序号、重传、流量控制、拥塞控制实现可靠传输；UDP不保障可靠传输，尽最大努力交付。 TCP面向字节流传输，因此可以被分割并在接收端重组；UDP面向数据报传输。 TCP为什么不是两次握手而是三次？ 如果仅两次连接可能出现一种情况：客户端发送完连接报文（第一次握手）后由于网络不好，延时很久后报文到达服务端，服务端接收到报文后向客户端发起连接（第二次握手）。此时客户端会认定此报文为失效报文，但在两次握手情况下服务端会认为已经建立起了连接，服务端会一直等待客户端发送数据，但因为客户端会认为服务端第二次握手的回复是对失效请求的回复，不会去处理。这就造成了服务端一直等待客户端数据的情况，浪费资源。 TCP为什么挥手是四次而不是三次？ TCP是全双工的，它允许两个方向的数据传输被独立关闭。当主动发起关闭的一方关闭连接之后，TCP进入半关闭状态，此时主动方可以只关闭输出流。 之所以不是三次而是四次主要是因为被动关闭方将”对主动关闭报文的确认”和”关闭连接”两个操作分两次进行。 “对主动关闭报文的确认”是为了快速告知主动关闭方，此关闭连接报文已经收到。此时被动方不立即关闭连接是为了将缓冲中剩下的数据从输出流发回主动关闭方（主动方接收到数据后同样要进行确认），因此要把”确认关闭”和”关闭连接”分两次进行。 Linux的close实际上是同时关闭输入流和输出流，并不是我们常说的四次握手。半关闭函数为shutdown，它可以用来断开某个具体描述符的TCP输入流或输出流。 为什么要有TIME_WAIT状态，TIME_WAIT状态过多怎么解决？ 主动关闭连接一方在发送对被动关闭方关闭连接的确认报文时，有可能因为网络状况不佳，被动关闭方超时未能收到此报文而重发断开连接（FIN）报文，此时如果主动方不等待而是直接进入CLOSED状态，则接收到被动关闭方重发的断开连接的报文会触发RST分组而非ACK分组，当被动关闭一方接收到RST后会认为出错了。所以说处于TIME_WAIT状态就是为了在重新收到断开连接分组情况下进行确认。 解决方法： 可以通过修改sysctl中TIME_WAIT时间来减少此情况（HTTP 1.1也可以减少此状态）。 利用SO_LINGER选项的强制关闭方式，发RST而不是FIN，来越过TIMEWAIT状态，直接进入CLOSED状态。 TCP建立连接及断开连接是状态转换？ 客户端：SYN_SENT -&gt; ESTABLISHED -&gt; FIN_WAIT_1 -&gt; FIN_WAIT_2 -&gt; TIME_WAIT。 服务端：LISTEN -&gt; SYN_RCVD -&gt; ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK -&gt; CLOSED。 TCP流量控制和拥塞控制的实现？ 流量控制：TCP采用大小可变的滑动窗口进行流量控制。窗口大小的单位是字节，在TCP报文段首部的窗口字段写入的数值就是当前给对方设置的发送窗口数值的上限，发送窗口在连接建立时由双方商定。但在通信的过程中，接收端可根据自己的资源情况，随时动态地调整对方的发送窗口上限值。 拥塞控制：网络拥塞现象是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象。严重时甚至会导致网络通信业务陷入停顿，即出现死锁现象。拥塞控制是处理网络拥塞现象的一种机制。 TCP重传机制？ 滑动窗口机制，确立收发的边界，能让发送方知道已经发送了多少、尚未确认的字节数、尚待发送的字节数；让接收方知道已经确认收到的字节数。 选择重传，用于对传输出错的序列进行重传。 三次握手过程？ 主动建立连接方A的TCP向主机B发出连接请求报文段，其首部中的SYN(同步)标志位应置为1，表示想与目标主机B进行通信，并发送一个同步序列号x进行同步，表明在后面传送数据时的第一个数据字节的序号是x + 1。SYN同步报文会指明客户端使用的端口以及TCP连接的初始序号。 接收连接方B的TCP收到连接请求报文段后，如同意则发回确认。在确认报中应将ACK位和SYN位置1，表示客户端的请求被接受。确认号应为x + 1，同时也为自己选择一个序号y。 主动方A的TCP收到目标主机B的确认后要向目标主机B给出确认，其ACK置1，确认号为y + 1，而自己的序号为x + 1。 四次挥手过程？ 主动关闭主机A的应用进程先向其TCP发出连接释放请求，并且不再发送数据。TCP通知对方要释放从A到B这个方向的连接，将发往主机B的TCP报文段首部的终止比特FIN置1，其序号x等于前面已传送过的数据的最后一个字节的序号加1。 被动关闭主机B的TCP收到释放连接通知后即发出确认，其序号为y，确认号为x + 1，同时通知高层应用进程，这样，从A到B的连接就释放了，连接处于半关闭状态。但若主机B还有一些数据要发送主机A，则可以继续发送。主机A只要正确收到数据，仍应向主机B发送确认。 若主机B不再向主机A发送数据，其应用进程就通知TCP释放连接。主机B发出的连接释放报文段必须将终止比特FIN和确认比特ACK置1，并使其序号仍为y，但还必须重复上次已发送过的ACK = x + 1。 主机A必须对此发出确认，将ACK置1，ACK = y + 1，而自己的序号是x + 1。这样才把从B到A的反方向的连接释放掉。主机A的TCP再向其应用进程报告，整个连接已经全部释放。 I/O模型 阻塞和非阻塞I/O区别？ 如果内核缓冲没有数据可读时，read()系统调用会一直等待有数据到来后才从阻塞态中返回，这就是阻塞I/O。 非阻塞I/O在遇到上述情况时会立即返回给用户态进程一个返回值，并设置errno为EAGAIN。 对于往缓冲区写的操作同理。 同步和异步区别？ 同步I/O指处理I/O操作的进程和处理I/O操作的进程是同一个。 异步I/O中I/O操作由操作系统完成，并不由产生I/O的用户进程执行。 Reactor和Proactor区别？ Reactor模式已经是同步I/O，处理I/O操作的依旧是产生I/O的程序；Proactor是异步I/O，产生I/O调用的用户进程不会等待I/O发生，具体I/O操作由操作系统完成。 异步I/O需要操作系统支持，Linux异步I/O为AIO，Windows为IOCP。 epoll和select及poll区别？ 文件描述符数量限制：select文件描述符数量受到限制，最大为2048（FD_SETSIZE），可重编内核修改但治标不治本；poll没有最大文件描述符数量限制；epoll没有最大文件描述符数量限制。 检查机制：select和poll会以遍历方式（轮询机制）检查每一个文件描述符以确定是否有I/O就绪，每次执行时间会随着连接数量的增加而线性增长；epoll则每次返回后只对活跃的文件描述符队列进行操作（每个描述符都通过回调函数实现，只有活跃的描述符会调用回调函数并添加至队列中）。当大量连接是非活跃连接时epoll相对于select和poll优势比较大，若大多为活跃连接则效率未必高（设计队列维护及红黑树创建） 数据传递方式：select和poll需要将FD_SET在内核空间和用户空间来回拷贝；epoll则避免了不必要的数据拷贝。 epoll中ET和LT模式的区别与实现原理？ LT：默认工作方式，同时支持阻塞I/O和非阻塞I/O，LT模式下，内核告知某一文件描述符读、写是否就绪了，然后你可以对这个就绪的文件描述符进行I/O操作。如果不作任何操作，内核还是会继续通知。这种模式编程出错误可能性较小但由于重复提醒，效率相对较低。传统的select、poll都是这种模型的代表。 ET：高速工作方式（因为减少了epoll_wait触发次数），适合高并发，只支持非阻塞I/O，ET模式下，内核告知某一文件描述符读、写是否就绪了，然后他假设已经知道该文件描述符是否已经就绪，内核不会再为这个文件描述符发更多的就绪通知（epoll_wait不会返回），直到某些操作导致文件描述符状态不再就绪。 ET模式下要注意什么（如何使用ET模式）？ 对于读操作，如果read没有一次读完buff数据，下一次将得不到就绪通知（ET特性），造成buff中数据无法读出，除非有新数据到达。 解决方法：将套接字设置为非阻塞，用while循环包住read，只要buff中有数据，就一直读。一直读到产生EAGIN错误。 对于写操作主要因为ET模式下非阻塞需要我们考虑如何将用户要求写的数据写完。 解决方法：只要buff还有空间且用户请求写的数据还未写完，就一直写。 操作系统 Linux下进程间通信方式？ 管道： 无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。 有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。 共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。 消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。 信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。 Linux下同步机制？ POSIX信号量：可用于进程同步，也可用于线程同步。 POSIX互斥锁 + 条件变量：只能用于线程同步。 线程和进程的区别？ 调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。 并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。 拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。 系统开销：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁task_struct结构。 介绍虚拟内存？ 内存分配及碎片管理？ 有很多小的碎片文件怎么处理？ Linux fork系统调用？ 什么场景用共享内存，什么场景用匿名管道？ 有没有用过开源的cgi框架？ epoll和select比有什么优势有什么劣势，epoll有什么局限性？ epoll优势：1. 没有描述符数量限制；2. 通过回调代替轮询；3. 内存映射代替数据在用户和内核空间来回拷贝。 epoll劣势（局限性）：select可以跨平台，epoll只能在Linux上使用。 线程（POSIX）锁有哪些？ 互斥锁（mutex） 互斥锁属于sleep-waiting类型的锁。例如在一个双核的机器上有两个线程A和B，它们分别运行在core 0和core 1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞，此时会通过上下文切换将线程A置于等待队列中，此时core 0就可以运行其他的任务（如线程C）。 条件变量(cond) 自旋锁(spin) 自旋锁属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，如果自旋锁已经被线程B所持有，那么线程A就会一直在core 0上进行忙等待并不停的进行锁请求，检查该自旋锁是否已经被线程B释放，直到得到这个锁为止。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。 虽然它的效率比互斥锁高，但是它也有些不足之处： 自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。 在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。 自旋锁只有在内核可抢占式或SMP的情况下才真正需要，在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。 读写锁（rwlock） TKeed 项目整体架构是什么？请求怎么进来？处理完怎么出去？ 整体架构为：I/O多路复用 + 非阻塞I/O + 线程池，即Reactor反应堆模型。 处理流程： 创建监听描述符并在epoll中注册。 监听到新请求，epoll从阻塞中返回并建立新连接。 将新建的连接描述符在epoll中注册。 当某个连接接收到用户请求数据时，将任务投放到线程池任务队列中。 工作线程被条件变量（任务队列不为空）唤醒，并互斥访问线程池。 得到任务的线程完成解析及响应。 工作线程执行函数为do_request，参数即为task结构。 每个task结构在建立连接是被初始化，包含描述符、缓冲区等信息是，并在do_request执行时记录解析结果及状态。 在做压测时，机器配置是什么样的？数据如何？ 本地测试。 四核i5处理器 + 128G固态硬盘。 为了QPS（Query per second, 1秒内完成的请求数量）更高可以做哪些改进？ 对请求结果做缓存。 多次搜索请求采用异步I/O，改串行为并行。 调整并发线程数量（通常和CPU核心数相同）。 有没有注意到压测时内存，CPU，I/O指标？ 压测同时打开top -H -p pid查看CPU，I/O，内存信息。 压测时有没有见过TIME_WAIT？怎么样会见到？怎么解决？ 当服务端关闭连接时会产生TIME_WAIT。 解决方案： HTTP 1.1在同一个TCP连接上尽量传输更多数据。 通过修改sysctl配置减小TIME_WAIT时间。 是会主动关闭还是会等待客户端关闭连接? 服务端会在完成请求之后关闭连接。 写一个Server需要注意哪些问题？ 只支持request/response，除此之外是否需要支持cgi。 并发量，QPS，资源占用（内存，CPU，I/O，网络流量等）。 CPU占用是否过高。 内存是否泄露。 项目中遇到什么困难，你是如何解决的？ CPU占用过高。 压测时，每次最后会挂掉。 做这个项目的目的是什么？ 定时器是如何实现的？里面放了有多少个连接（怎么确定大小）？谁去取超时的连接？检查超时之后还会继续检查吗，还是检查完之后就断了？ 如果发生超时，在关闭连接时同时又收到了新的数据怎么办？ 用什么数据结构存放url，怎么解析的？ 使用tk_request_t结构中buff读取用户请求，buff为循环缓冲（8192 Bytes）。 每次进入while循环时读取用户请求到buff中循环队列尾位置（plast），之后解析用户请求并响应。 支持HTTP 1.1，只要有数据就读取 -&gt; 解析 -&gt; 响应。 实习经历 介绍一下上网行为管理这个系统？ 介绍一下格林威治云平台做哪些任务？ 改变数据获取方式及校验数据一致性？ WTGGroup模块做什么用的？ 数据结构 层序遍历二叉树？ map和hashmap的区别是什么？ Hash发生冲突时怎么处理？ hashmap的时间复杂度是多少？map的时间复杂度？ 优先队列时间复杂度？]]></content>
      <categories>
        <category>Summary</category>
      </categories>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理知识点——(1)]]></title>
    <url>%2F2018%2F07%2F30%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9%E2%80%94%E2%80%94-1%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Computer-Vision</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux相关总结]]></title>
    <url>%2F2018%2F05%2F13%2FLinux%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Linux工具 Linux下还是有很多超棒的开发工具的。 在Linux日常使用中，最常用的命令自然是sudo, ls, cp, mv, cat等，但作为后台开发者，上述命令远远不够。从我的理解来看，合格的C/C++开发者至少需要从开发及调试工具、文件处理、性能分析、网络工具四个方面针对性使用一些开发工具。这里我罗列了一些，大部分都是开发中经常需要使用的命令，有些功能比较简单的命令我会给出一些基本用法，有些本身自带体系（比如vim, gdb等）的命令只能附上链接了。 开发及调试工具介绍了从“编辑 -&gt; 编译 -&gt; 分析目标文件 -&gt; 追踪调用过程”的全套命令，文件处理部分介绍了查找、统计、替换等基本文本操作命令，性能分析介绍了查看进程信息、CPU负载、I/O负载、内存使用情况等基本命令，网络工具介绍了可以查看“链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层”信息的工具。除此以外，其他命令中也列出了开发者经常会用到的一些命令，基本可以满足日常开发需要。 目录 Chapter 1 Chapter 2 Chapter 3 Chapter 4 Chapter 5 开发及调试 文件处理 性能分析 网络工具 其他 开发及调试 编辑器：vim 编译器：gcc/g++ 调试工具：gdb 查看依赖库：ldd 二进制文件分析：objdump ELF文件格式分析：readelf 跟踪进程中系统调用：strace 跟踪进程栈：pstack 进程内存映射：pmap 文件处理 文件查找：find 文本搜索：grep 排序：sort 转换：tr 按列切分文本：cut 按列拼接文本：paste 统计行和字符：wc 文本替换：sed 数据流处理：awk 性能分析 进程查询：ps 进程监控：top 打开文件查询：lsof 内存使用量：free 监控性能指标：sar 网络工具 网卡配置：ifconfig 查看当前网络连接：netstat 查看路由表：route 检查网络连通性：ping 转发路径：traceroute 网络Debug分析：nc 命令行抓包：tcpdump 域名解析工具：dig 网络请求：curl 其他 终止进程：kill 修改文件权限：chmod 创建链接：ln 显示文件尾：tail 版本控制：git 设置别名：alias 内容开发及调试 开发工具大部分都提供了完善的功能，所以这里不一一列举用法。从技术层面来说，调试工具比开发工具更考验一个人的工程能力。 编辑器：vim 服务器端开发必知必会，功能强大，这里不一一列举，但基本的打开文件、保存退出要会。 详见 编译器：gcc/g++ C/C++编译器，必知必会，除此以外需要了解预处理-&gt; 编译 -&gt; 汇编 -&gt; 链接等一系列流程。 详见 调试工具：gdb 服务器端调试必备。 详见 查看依赖库：ldd 程序依赖库查询12345# ldd后接可执行文件# 第一列为程序依赖什么库，第二列为系统提供的与程序需要的库所对应的库，第三列为库加载的开始地址# 前两列可以判断系统提供的库和需要的库是否匹配，第三列可以知道当前库在进程地址空间中对应的开始位置ldd a.out 二进制文件分析：objdump 反汇编，需要理解汇编语言 详见 ELF文件格式分析：readelf 可以得到ELF文件各段内容，分析链接、符号表等需要用到 详见 跟踪进程中系统调用：strace 详见 跟踪进程栈：pstack 详见 进程内存映射：pmap 显示进程内存映射1234567891011# -x显示扩展信息，后接进程pid# Address: 内存开始地址# 显示信息： Kbytes: 占用内存的字节数 RSS: 保留内存的字节数 Dirty: 脏页的字节数（包括共享和私有的） Mode: 内存的权限：read、write、execute、shared、private Mapping: 占用内存的文件、或[anon]（分配的内存）、或[stack]（堆栈） Device: 设备名 (major:minor)pmap -x 12345 文件处理 Everything is file. 在Linux环境下，对文本处理相当频繁，所以有些命令的参数还是需要记忆的。另外其他很多命令的输出信息都需要通过文件处理命令来筛选有用信息。 文件查找：find 按名查找： 查找具体文件（一般方式） 1find . -name *.cpp 查找具体文件（正则方式） 123# -regex为正则查找，-iregex为忽略大小写的正则查找 find -regex ".*.cpp$" 定制查找： 按类型查找 123# f(file)为文件，d(dictionary)为目录，l(link)为链接find . -type f 按时间查找 1234# atime为访问时间，x天内加参数"-atime -x"，超过x天加"-atime -x"# mtime为修改时间find . -type f -atime -7 按大小查找 123# -size后接文件大小，单位可以为k(kb)，m(MB)，g(GB)find . -type f -size -1k 按权限查询 123# -perm后接权限find . -type -perm 644 文本搜索：grep 模式匹配 123# 匹配test.cpp文件中含有"iostream"串的内容grep "iostream" test.cpp 多个模式匹配 123# 匹配test.cpp文件中含有"iostream"和"using"串的内容grep -e "using" -e "iostream" test.cpp 输出信息 123# -n为打印匹配的行号；-i搜索时忽略大小写；-c统计包含文本次数grep -n "iostream" test.cpp 排序：sort 文件内容行排序123456# 排序在内存进行，不改变文件# -n(number)表示按数字排序，-d(dictionary)表示按字典序# -k N表示按各行第N列进行排序# -r(reverse)为逆序排序sort -n -k 1 test 转换：tr 字符替换 1234# 转换在内存进行，不改变文件# 将打开文件中所有目标字符替换cat test | tr '1' '2' 字符删除 1234# 转换在内存进行，不改变文件# -d删除(delete)cat test | tr -d '1' 字符压缩 1234# 转换在内存进行，不改变文件# -s位于后部cat test | tr ' ' -s 按列切分文本：cut 截取特定列 12345# 截取的内存进行，不改变文件# -b(byte)以字节为单位，-c(character)以字符为单位，-f以字段为单位# 数字为具体列范围cut -f 1,2 test 指定界定符 1234# 截取的内存进行，不改变文件# -d后接界定符cut -f 2 -d ',' new 按列拼接文本：paste 按列拼接 123456# 在内存中拼接，不改变文件# 将两个文件按对应列拼接# 最后加上-d "x"会将x作为指定分隔符（paste test1 test2 -d ","）# 两文件列数可以不同 paste test1 test2 指定界定符拼接 1234# 在内存中拼接，不改变文件# 按照-d之后给出的界定符拼接paste test1 test2 -d "," 统计行和字符：wc 基本统计123# -l统计行数(line)，-w统计单词数(word)，-c统计字符数(character)wc -l test 文本替换：sed 区别于上面的命令，sed是可以直接改变被编辑文件内容的。 详见 数据流处理：awk 区别于上面的命令，awk是可以直接改变被编辑文件内容的。 详见 系统信息 性能监视工具对于程序员的作用就像是听诊器对于医生的作用一样。系统信息主要针对于服务器性能较低时的排查工作，主要包括CPU信息，文件I/O和内存使用情况，通过进程为纽带得到系统运行的瓶颈。 进程查询：ps 查看正在运行进程 123# 常结合grep筛选信息(e.g, ps -ef | grep xxx)ps -ef 以完整格式显示所有进程 123# 常结合grep筛选信息ps -ajx 进程监控：top 显示实时进程信息123456# 这是个大招，都不带参数的，具体信息通过grep筛选# 交互模式下键入M进程列表按内存使用大小降序排列，键入P进程列表按CPU使用大小降序排列# %id表示CPU空闲率，过低表示可能存在CPU存在瓶颈# %wa表示等待I/O的CPU时间百分比，过高则I/O存在瓶颈 &gt; 用iostat进一步分析top 打开文件查询：lsof 查看占用某端口的进程 1234# 最常见的就是mysql端口被占用使用(lsof i:3307)# 周知端口(ftp:20/21, ssh:22, telnet:23, smtp:25, dns:53, http:80, pop3:110, https:443)lsof -i:53 查看某用户打开的文件 123# -u(user)为用户，后接用户名lsof -u inx 查看指定进程打开的文件 123# -p(process)为进程，后接进程PIDlsof -p 12345 查看指定目录下被进程打开的文件 123# 这里是"+d"，需要注意，使用"+D"递归目录lsof +d /test 内存使用量：free 内存使用量123# 可获得内存及交换区的总量，已使用量，空闲量等信息free 监控性能指标：sar 监控CPU 监控CPU负载 1234# 加上-q可以查看运行队列中进程数，系统上进程大小，平均负载等# 这里"1"表示采样时间间隔是1秒，这里"2"表示采样次数为2sar -q 1 2 监控CPU使用率 1234# 可以显示CPU使用情况# 参数意义同上sar -u 1 2 监控内存 查询内存 1234# 可以显示内存使用情况# 参数意义同上 sar -r 1 2 页面交换查询 1234 # 可以查看是否发生大量页面交换，吞吐率大幅下降时可用 # 参数意义同上sar -W 1 2 网络工具 网络工具部分只介绍基本功能，参数部分一笔带过。这部分重点不在于工具的使用而是对反馈的数据进行解读，并且这部分命令功能的重合度还是比较高的。 网卡配置（链路层）：ifconfig 显示设备信息 123# 可以显示已激活的网络设备信息ifconfig 启动关闭指定网卡 1234# 前一个参数为具体网卡，后一个为开关信息# up为打开，down为关闭ifconfig eth0 up 配置IP地址 123# 前一个参数为具体网卡，后一个为配置的IP地址ifconfig eth0 192.168.1.1 设置最大传输单元 1234前一个参数为具体网卡，后面为MTU的大小# 设置链路层MTU值，通常为1500ifconfig eth0 mtu 1500 启用和关闭ARP协议 123# 开启arp如下，若关闭则-arpifconfig eth0 arp 查看当前网络连接（链路层/网络层/传输层）：netstat 网络接口信息 123# 显示网卡信息，可结合ifconfig学习netstat -i 列出端口 1234# -a(all)表示所有端口，-t(tcp)表示所有使用中的TCP端口# -l(listening)表示正在监听的端口netstat -at 显示端口统计信息 1234# -s(status)显示各协议信息# -加上-t(tcp)显示tcp协议信息，加上-u(udp)显示udp协议信息netstat -s 显示使用某协议的应用名 123# -p(progress)表示程序，可以显示使用tcp/udp协议的应用的名称netstat -pt 查找指定进程、端口 12345# 互逆操作第一个显示某程序使用的端口号，第二个显示某端口号的使用进程# 第二个操作可以用lsof替代netstat -ap | grep sshnetstat -an | grep ':80' 查看路由表（网络层IP协议）：route 查看路由信息1234# 得到路由表信息，具体分析路由表工作需要网络知识# 可以通过netstat -r(route)得到同样的路由表route 检查网络连通性（网络层ICMP协议）：ping 检查是否连通1234# 主要功能是检测网络连通性# 可以额外得到网站的ip地址和连接最大/最小/平均耗时。ping baidu.com 转发路径（网络层ICMP协议）：traceroute 文件包途径的IP1234# # 可以打印从沿途经过的路由器IP地址traceroute baidu.com 网络Debug分析（网络层/传输层）：nc 端口扫描 1234567# 黑客很喜欢# 扫描某服务器端口使用情况# -v(view)显示指令执行过程，-w(wait)设置超时时长# -z使用输入输出模式（只在端口扫描时使用）# 数字为扫描的端口范围 nc -v -w 1 baidu.com -z 75-1000 其他详见 命令行抓包（网络层/传输层）：tcpdump 抓包利器，没有什么比数据更值得信赖。可以跟踪整个传输过程。 详见 域名解析工具（应用层DNS协议）：dig 12345# 应用层，DNS# 打印域名解析结果# 打印域名解析过程中涉及的各级DNS服务器地址dig baidu.com 网络请求（应用层）：curl 详见 其他 这里都是日常开发中高频命令。 终止进程：kill 杀死具体进程 123# 加具体进程PIDkill 12345 杀死某进程相关进程 123# 加上"-9"杀死某进程相关进程kill -9 12345 修改文件权限：chmod 更改文件权限1234567# 可以对三种使用者设置权限，u(user, owner)，g(group)，o(other)# 文件可以有三种权限，r(read)，w(write)，x(execute)# 这里u+r表示文件所有者在原有基础上增加文件读取权限# 这里777分别对应，u=7，g=7，o=7，具体数字含义自行googlechmod u+r filechmod 777 file 创建链接：ln 创建硬链接 123# 文件inode中链接数会增加，只有链接数减为0时文件才真正被删除ln file1 file2 创建软（符号链接）链接 12345# -s(symbol)为符号链接，仅仅是引用路径# 相比于硬链接最大特点是可以跨文件系统# 类似于Windows创建快捷方式，实际文件删除则链接失效ln -s file1 file2 显示文件尾：tail 查看文件尾部1234# -f参数可以不立即回传结束信号，当文件有新写入数据时会及时更新# 查看日志时常用tail -f test 版本控制：git 版本控制最好用的软件，没有之一。至少要知道”git init”，”git add”，”git commit”，”git pull”，”git push”几个命令。 详见 设置别名：alias 常用命令添加别名123# ".bashrc"文件中配置常用命令别名，生效后在命令行只需要使用别名即可代替原先很长的命令alias rm='rm -i' 实战假设已经通过vim编辑，gcc编译得到可执行文件server，这时就可以使用一些开发者常用的工具来进行后期调试。这里都是给出最简单的用法，意在快速掌握一些基本开发工具。 先clone这个项目，然后使用src_code下代码编译通过后通过下面命令调试。代码 单步调试：gdb 运行得不到正确结果可以通过gdb设置断点来查看每个中间变量值，以此来确定哪里出了问题。因为gdb调试内容较多，这里不详细说明。另外，gdb出了可以单步查看变量值，还可以分析coredump文件来排查错误。 动态库依赖：ldd 命令：ldd ./server 可以查看可执行文件server所需的所有动态库，动态库所在目录及其被映射到的虚拟地址空间。 性能分析：top top可以查看当前系统很多信息，比如1,5,15分钟内负载，运行、休眠、僵尸进程数，用户、内核程序占CPU百分比，存储信息等。top可以定位具体哪个进程CPU占用率高和内存使用率高。我们可以以此定位性能问题出在什么程序上（比如你后台执行TKeed server之后，可以看到CPU占用率为99%，这时候我们就需要从这个程序入手了）。 系统调用：strace 命令：strace ./server 上面已经提到TKeed server的CPU占用率为99%，那么问题通常一定是出在了死循环上。我们接下来在代码中找到死循环位置。因为程序中epoll_wait需要阻塞进程，我们怀疑是不是这里没有阻塞，这时就可以通过上面的方式运行server程序。此时可以打印出没次系统调用及其参数等，我们也可以加-o filename将系统调用信息保存下来。 打印进程：ps 命令：ps -ejH 我们在命令行下打开的程序的父进程是shell程序，之前用strace打开server程序，strace也是server的父进程。我们有时候需要知道进程间的层级关系就需要打印进程树，上面的ps命令可以做到。当出现僵尸进程时就可以通过进程树定位具体是哪个进程出了问题。另外当想要知道进程pid时，ps -el | grep XXX也是很常用的。 打开文件：lsof lsof -i:3000 比如在运行server时发现端口被占用了，可以通过lsof -i:port来查看对应端口号正在被哪个进程所占用。端口占用是非常常见的问题，比如3306被占用我遇到过好几次，要么是某个程序正好占用了要么是之前没能结束进程，这些都可以借助lsof帮助查看端口。 修改权限：chmod chmod 000 ./index.html 可以修改文件权限，这里设为000，这样任何人都无法访问，重新在浏览器请求127.0.0.1:3000/index.html就会因为文件权限不够而无法展示，服务器返回状态码为403，符合我们预期。修改权限后再请求一次可得到状态码200。 网卡信息：ifconfig ifconfig 如果想看一下整个传输过程，可以使用tcpdump来抓包，但是抓包时参数需要加上网卡信息，这时候可以通过ifconfig来获得网卡信息。 抓包分析：tcpdump tcpdump -i eth0 port 3000 可以用tcpdump来抓包分析三次握手及数据传输过程，-i之后加上上一步得到的网卡地址，port可以指定监听的端口号。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树系列]]></title>
    <url>%2F2017%2F01%2F04%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[一.最近公共祖先思路：递归的求每个节点的最近公共祖先 条件:3 到达点了需要返回出来。 12345678910111213141516171819def lowestancestor(root,A,B): if root==A or root==B or not root: return root right=lowestancestor(root.right,A,B) left=lowestancestor(root.left,A,B) if left and right: return root if not left : return right if not right: return root#满二叉树：root=child/2def LCS:(a,b): while (a!=b): if a&gt;b: a=a/2 if a&lt;b: b=b/2 return a #####]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯递归系列]]></title>
    <url>%2F2017%2F01%2F04%2F%E5%9B%9E%E6%BA%AF%E9%80%92%E5%BD%92%2F</url>
    <content type="text"></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表系列]]></title>
    <url>%2F2017%2F01%2F04%2F%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划系列]]></title>
    <url>%2F2017%2F01%2F03%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[一、和为sum的组合数:思路:dp(i)(j)为前i个元素构成和为j的组合总数，通过递推关系。 1234567891011def combination1(nums,target): dp=[[0 for _ in range(target+1)] for _ in range(len(nums))] for i in range(len(dp)): dp[i][0]=1 for i in range(len(nums)): for j in range(1,target+1): if nums[i]&gt;j: dp[i][j]=dp[i-1][j] else: dp[i][j]=dp[i-1][j]+dp[i-1][j-nums[i]] return dp[-1][-1] 二、零钱兑换两种: (重复/非重复)三、字符串混编：A、B和C。如果C包含且仅包含来自A和B的所有字符，而且在C中属于A的字符之间保持原来在A中的顺序，属于B的字符之间保持原来在B中的顺序，那么称C是A和B的混编。实现一个函数，判断C是否是A和B的混编。 给定三个字符串A,B和C，及他们的长度。请返回一个bool值，代表C是否是A和B的混编。保证三个串的长度均小于等于100。 测试样例： 1&quot;ABC&quot;,3,&quot;12C&quot;,3,&quot;A12BCC&quot;,6 1返回：true 四、子序列1.最长递增子序列的长度(不连续)** 123456789def LIS(nums): dp=[1 for _ in range(len(nums))] #dp[i]表示以i个元素结尾的最长子序列长度 dp[0]=1 for i in range(1,len(nums)): for j in range(i): if nums[j]&lt;nums[i]: dp[i]=max(dp[i],dp[j]+1) return dp#dp[0...i-1],找出arr[j]&lt;arr[i]小且dp[j]是最大的 dp[i]=dp[j]+1; 2.最长递增子序列长度(连续) 123456789def LIS(nums): dp=[1 for _ in range(len(nums))] #dp[i]表示以i结尾的最长子序列长度 dp[0]=1 for i in range(1,len(nums)): if nums[i]&lt;=nums[i-1]: dp[i]=1 else: dp[i]=dp[i-1]+1 return dp 3.最大连续子序列和 123456def maxsequence(nums): dp=[0 for _ in range(len(nums))] #dp[i]表示以i结尾的最大和 dp[0]=nums[0] for i in range(1,len(nums)): dp[i]=max(dp[i-1]+nums[i],nums[i]) return dp 4.不相邻的最大子数组和 1234567def maxsequence(nums): dp=[0 for _ in range(len(nums))] dp[0]=nums[0] dp[1]=nums[1] for i in range(2,len(nums)): dp[i]=max(dp[i-2]+nums[i],dp[i-1]) # 前i个元素最大和dp[i] = max(dp[i-1],dp[i-2]+num) return dp 5.最长公共子序列(不连续) 6.最长公共子串(连续) 当str1[i] == str2[j]时，子序列长度dpi-1；只是当str1[i] ！= str2[j]时，veca[i][j]长度要为0，而不是max{veca[i - 1][j], veca[i][j - 1]}。 7.数组中的最长山脉Leetcode845 1.length &gt;= 3` 2.存在 0 &lt; i &lt; B.length - 1 使得 B[0] &lt; B[1] &lt; … B[i-1] &lt; B[i] &gt; B[i+1] &gt; … &gt; B[B.length - 1] 12345678910111213#最长递增子序列，子数组#A[i]结尾的最长递增 #A[i]为首的最长递减 相加-1def longestmountain(nums): dp1=[1 for _ in range(len(nums))] #记录以A[i]为结尾的最长递增子数组 dp2=[1 for _ in range(len(nums))] #记录以A[i]为起始的最长递减子数组 for i in range(1,len(nums)): if nums[i]&gt;nums[i-1]: dp1[i]=dp1[i-1]+1 for j in range(len(nums)-2,-1,-1): if nums[j]&gt;nums[j+1]: dp2[j]=dp2[j+1]+1 result=list(map(lambda x:x[0]+x[1],zip(dp1,dp2))) return max(result)-1 #中间的山顶计算了两遍得减1 8.编辑距离]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
</search>
